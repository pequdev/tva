//@version=6
// â”€â”€ Pine v6 Runtime Constraints
//   - Execution: 40s max, 500ms per bar loop
//   - Plots: 64 total, Drawing objects: 500 line/box/label, 100 polyline
//   - Compiled tokens: 100k (libraries: 1M combined)
//   - Dynamic requests: 40 max per script
//   - calc_bars_count: compile-time literal (0 = all bars)
indicator(title = 'Shox Fibonacci Pivots [PQ_MOD]', shorttitle = 'FIBS/1.17', overlay = true, max_lines_count=500, max_labels_count=500, max_boxes_count=500, max_polylines_count=100, max_bars_back=5000, dynamic_requests=true, calc_bars_count=0)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS & THEME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Colors
color COLOR_FG_MAIN     = chart.fg_color
color COLOR_RED         = #f44336
color COLOR_GREEN       = #4caf50
color COLOR_TEAL        = #009688
color COLOR_BLUE        = #2196f3
color COLOR_PURPLE      = #9c27b0
color COLOR_PINK        = #e91e63
color COLOR_GRAY        = #a2a2a2
color COLOR_LIGHT_GREEN = #81c784
color COLOR_LIGHT_BLUE  = #64b5f6

// Theme Transparencies
int STATIC_TRANS_MAIN          = 25
int STATIC_TRANS_SUPP          = 70

// Static Colors
color COLOR_TZ          = color.new(COLOR_FG_MAIN, 80)
color COLOR_ZZ          = color.new(COLOR_FG_MAIN, 75)
color COLOR_TEXT        = color.new(COLOR_FG_MAIN, 0)

// Configuration Constants
int STATIC_LEVELS_COUNT        = 22

// Alert IDs
string STATIC_ALERT_ID_UPDATE     = 'FBU'
string STATIC_ALERT_ID_EXHAUSTION = 'EXH'
string STATIC_ALERT_ID_VOLATILITY = 'HVO'
string STATIC_ALERT_ID_CROSSING   = 'RCL'
string STATIC_ALERT_ID_SETUP      = 'SCT'
string STATIC_ALERT_ID_ENTRY      = 'SEN'
string STATIC_ALERT_ID_OUTCOME    = 'SOT'
string STATIC_ALERT_ID_LEARNING   = 'LRN'

// Alert Schema Version
string STATIC_ALERT_SCHEMA_VERSION = '1.0.0'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIBONACCI CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float FIB_GOLDEN_RATIO    = 0.618
float FIB_GOLDEN_POCKET_H = 0.65
float FIB_EXTENSION_1272  = 1.272
float FIB_EXTENSION_1618  = 1.618

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOGARITHMIC RETURNS CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Annualization factors (periods per year)
int   LOG_PERIODS_DAILY         = 252   // Trading days per year (equities)
int   LOG_PERIODS_CRYPTO        = 365   // Calendar days (24/7 markets)
float LOG_PERIODS_1M            = 252.0 * 6.5 * 60  // 1-min bars per trading year
float LOG_PERIODS_5M            = 252.0 * 6.5 * 12  // 5-min bars per trading year
float LOG_PERIODS_15M           = 252.0 * 6.5 * 4   // 15-min bars per trading year
float LOG_PERIODS_1H            = 252.0 * 6.5       // 1-hour bars per trading year
float LOG_PERIODS_4H            = 252.0 * 1.625     // 4-hour bars per trading year

// Volatility window defaults
int   LOG_VOL_WINDOW            = 20    // Rolling volatility window

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SHANNON ENTROPY CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Default parameters
int   ENTROPY_WINDOW_DEFAULT    = 20    // Rolling window for log returns
int   ENTROPY_BINS_DEFAULT      = 5     // Number of bins for discretization
float ENTROPY_THRESH_DEFAULT    = 0.7   // Normalized entropy threshold (0-1)

// Entropy modes
string ENTROPY_MODE_LEGACY      = "LEGACY_BINS"       // Original binned log-return entropy
string ENTROPY_MODE_BINARY      = "BINARY_UPDOWN"     // Binary up/down symbolic entropy
string ENTROPY_MODE_KGRAM       = "BINARY_KGRAM"      // K-gram pattern symbolic entropy

// Symbolic entropy defaults
int   ENTROPY_K_DEFAULT         = 3     // Default k-gram length (2^3 = 8 states)
int   ENTROPY_K_MIN             = 1     // Minimum k (2 states)
int   ENTROPY_K_MAX             = 8     // Maximum k (256 states) - runtime safe

// Regime classification
int   ENTROPY_REGIME_ORDERED    = 0     // Low entropy: structured/trending
int   ENTROPY_REGIME_TRANSITION = 1     // Highâ†’Low entropy: breakout
int   ENTROPY_REGIME_DISORDERED = 2     // High entropy: choppy/random

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HURST EXPONENT CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Default parameters
int   HURST_WINDOW_DEFAULT      = 100   // Rolling window for R/S calculation
float STATIC_HURST_TREND_THRESH        = 0.55  // H > this â†’ persistent/trending
float STATIC_HURST_MEANREV_THRESH      = 0.45  // H < this â†’ anti-persistent/mean-reverting
int   HURST_MIN_WINDOW          = 20    // Minimum window for stable estimate

// Regime classification
int   HURST_REGIME_TREND        = 0     // H > upper: persistent/trending
int   HURST_REGIME_RANDOM       = 1     // H near 0.5: random walk
int   HURST_REGIME_MEANREV      = 2     // H < lower: anti-persistent/mean-reverting

// Hurst modes
string STATIC_HURST_MODE_LEGACY        = "ğŸ”¸ Legacy (Geometric)"       // Original O(N*scales) implementation
string STATIC_HURST_MODE_DYADIC_STABLE = "ğŸŸ¢ Dyadic Stable (Chunk Avg)" // O(log N) dyadic with chunk averaging
string STATIC_HURST_MODE_DYADIC_FAST   = "âš¡ Dyadic Fast (Single Chunk)" // O(log N) dyadic, most recent chunk only

// â”€â”€ PERFORMANCE CONTROLLER - Preset-driven feature degradation

// Performance Preset Modes
string PERF_PRESET_BALANCED     = "ğŸŸ¢ Balanced"      // Default: all features, confirmed bars
string PERF_PRESET_FAST         = "âš¡ Fast"           // Degrades optional features for speed
string PERF_PRESET_DEBUG        = "ğŸ” Debug"         // Enables all debug overlays (table-based)

// Performance preset-driven parameter adjustments
int    PERF_ENTROPY_WINDOW_FAST = 10     // Reduced window for Fast mode
int    PERF_HURST_WINDOW_FAST   = 50     // Reduced window for Fast mode
int    PERF_VISUAL_KEEP_FAST    = 100    // Max visual objects to keep in Fast mode
int    PERF_VISUAL_KEEP_BALANCED = 250   // Max visual objects in Balanced mode

// Declared early for PerfController helper functions
string GROUP_PERF_CTRL  = 'âš¡ Performance Controller'
INPUT_PERF_PRESET       = input.string(PERF_PRESET_BALANCED, 'âš¡ Performance Preset', options=[PERF_PRESET_BALANCED, PERF_PRESET_FAST, PERF_PRESET_DEBUG], group=GROUP_PERF_CTRL, tooltip="Controls runtime/feature trade-offs:\n\nğŸŸ¢ Balanced: All features enabled, confirmed bar gating (default).\nâš¡ Fast: Degrades optional heavy features (smaller windows, skips stable Hurst).\nğŸ” Debug: Enables all debug overlays (table-based, no plot count impact).\n\nDefault behavior unchanged with Balanced preset.")
INPUT_PERF_SHOW_DASHBOARD = input.bool(false, '   â†³ Show Performance Dashboard', group=GROUP_PERF_CTRL, tooltip="Displays a performance dashboard table on the last bar.\nShows active preset, feature toggles, window sizes, and object counts.\nUses table (no plot count impact).")
INPUT_PERF_DEGRADE_HURST = input.bool(true, '   â†³ Fast: Degrade Hurst Mode', group=GROUP_PERF_CTRL, tooltip="When Fast preset is active:\nâ€¢ Forces Dyadic Fast mode (O(log N) single chunk)\nâ€¢ Reduces window from user setting to 50 bars\nâ€¢ Reduces computation by ~70% vs Legacy mode.")
INPUT_PERF_DEGRADE_ENTROPY = input.bool(true, '   â†³ Fast: Degrade Entropy Window', group=GROUP_PERF_CTRL, tooltip="When Fast preset is active:\nâ€¢ Forces Binary K-gram mode (O(1) incremental)\nâ€¢ Reduces window from user setting to 10 bars\nâ€¢ Reduces computation by ~80% vs Legacy binned mode.")
INPUT_PERF_SKIP_ALERTS  = input.bool(false, '   â†³ Fast: Skip Alert JSON', group=GROUP_PERF_CTRL, tooltip="When Fast preset is active:\nâ€¢ Skips JSON serialization for alerts\nâ€¢ Reduces string operations significantly\nâ€¢ Alerts still fire but with minimal payload.")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Z-SCORE MOMENTUM CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Default parameters
int   ZSCORE_LR_LEN_DEFAULT     = 14    // Linear regression lookback
int   ZSCORE_ATR_LEN_DEFAULT    = 14    // ATR period for normalization
int   ZSCORE_Z_LEN_DEFAULT      = 50    // Rolling window for Z-score stats
float STATIC_ZSCORE_THRESH_DEFAULT     = 2.0   // Z-score threshold for significance
int   ZSCORE_MIN_SAMPLES        = 10    // Minimum samples for valid Z-score

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BAYESIAN WIN-RATE & SORTINO CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Beta prior parameters (uninformative Bayes-Laplace prior)
float STATIC_BAYES_ALPHA_PRIOR         = 1.0   // Prior alpha (pseudo-wins)
float STATIC_BAYES_BETA_PRIOR          = 1.0   // Prior beta (pseudo-losses)
float STATIC_BAYES_CONFIDENCE_LEVEL    = 0.95  // Confidence level for credible interval
float STATIC_BAYES_PERCENTILE          = 0.05  // Lower bound percentile (1 - CL)

// Sortino ratio parameters
float STATIC_SORTINO_MAR               = 0.0   // Minimum Acceptable Return (target)
float STATIC_SORTINO_RF                = 0.0   // Risk-free rate
float STATIC_SORTINO_MAX_CAP           = 10.0  // Cap Sortino when downside deviation is zero

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MONTE CARLO PERMUTATION CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int   MC_SIMS_DEFAULT           = 100   // Default number of permutation simulations
int   MC_SIMS_MAX               = 500   // Maximum simulations (Pine runtime safety)
int   MC_MIN_TRADES             = 10    // Minimum trades for valid permutation test
float STATIC_MC_PVALUE_THRESH          = 0.05  // p-value threshold for significance (5%)
int   MC_SEED_BASE              = 42    // Base seed for reproducible randomness

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DYNAMIC REQUEST ENGINE CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int   EXT_MAX_SYMBOLS_CAP       = 20    // Hard cap on external symbols (budget safety)
int   EXT_MAX_CONTEXTS          = 40    // TradingView unique request limit
int   EXT_DEFAULT_SYMBOLS       = 5     // Default symbol count
string EXT_TF_CURRENT           = "CURRENT"
string EXT_TF_CUSTOM            = "CUSTOM"
string EXT_FIELDS_CLOSE         = "CLOSE_ONLY"
string EXT_FIELDS_OHLCV         = "OHLCV"
string EXT_GATE_ALWAYS          = "ALWAYS"
string EXT_GATE_ENTROPY         = "ON_ENTROPY_DISORDER"
string EXT_GATE_HURST           = "ON_LOW_HURST"
string EXT_GATE_CUSTOM          = "CUSTOM"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE FLAGS - Bitwise Trade/Setup State Representation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Direction Flag (Bit 0)
int STATIC_FLAG_IS_LONG        = 1

// Entry State (Bit 1)
int STATIC_FLAG_ZONE_TOUCHED   = 2

// Exit States (Bits 2-3) - Mutually exclusive
int STATIC_FLAG_SL_HIT         = 4
int STATIC_FLAG_TP_HIT         = 8

// Confluence Flags (Bit 4)
int STATIC_FLAG_HAD_RSI_DIV    = 16

// TP Mode (Bit 5)
int STATIC_FLAG_TP_AGGRESSIVE  = 32

// Analytics Tracking (Bits 6-7)
int STATIC_FLAG_CONS_TP_HIT    = 64
int STATIC_FLAG_AGGR_TP_HIT    = 128

// Lifecycle States (Bits 8-10) - Mutually exclusive
int STATIC_FLAG_PENDING        = 256
int STATIC_FLAG_ACTIVE         = 512
int STATIC_FLAG_CLOSED         = 1024

// Outcome (Bit 11)
int STATIC_FLAG_WON            = 2048

// Intrabar Resolution (Bit 12)
int STATIC_FLAG_LTF_RESOLVED   = 4096

// Composite Masks
int STATIC_MASK_OUTCOME        = 12
int STATIC_MASK_CLOSED         = 1024
int STATIC_MASK_LIFECYCLE      = 1792
int STATIC_MASK_TP_TRACKING    = 192

// Max bit index
int STATE_MAX_BIT       = 12

// â”€â”€ STATE FLAGS API - Arithmetic bitwise simulation (Pine v6 lacks native bitops)
//   Flags = powers of 2. Methods: hasFlag, setFlag, clearFlag, hasAny, hasAll, setLifecycle, setOutcome

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTRABAR RESOLUTION - Chronological TP/SL Resolution Using LTF Data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Resolve TP/SL chronologically via LTF data; returns [outcome:int, isResolved:bool, hitIndex:int]
f_resolveIntrabar(array<float> ltf_highs, array<float> ltf_lows, bool is_long, float sl_price, float tp_price, bool conservative_tiebreak) =>
    int outcome = 0          // 0 = undetermined, 1 = TP first, -1 = SL first
    bool ltf_resolved = false
    int hit_index = -1
    
    // Check if LTF data is available
    int ltf_count = array.size(ltf_highs)
    
    if ltf_count > 0
        // Iterate LTF bars chronologically (index 0 = earliest in HTF bar)
        for i = 0 to ltf_count - 1
            float ltf_high = array.get(ltf_highs, i)
            float ltf_low = array.get(ltf_lows, i)
            
            // Check TP/SL hits for this LTF bar
            bool sl_hit = is_long ? (ltf_low <= sl_price) : (ltf_high >= sl_price)
            bool tp_hit = is_long ? (ltf_high >= tp_price) : (ltf_low <= tp_price)
            
            // Resolve outcome for this intrabar
            if sl_hit and tp_hit
                // Both hit in same LTF bar - apply tie-break policy
                outcome := conservative_tiebreak ? -1 : 1  // -1 = SL, 1 = TP
                ltf_resolved := true
                hit_index := i
                break
            else if sl_hit
                outcome := -1  // SL hit first
                ltf_resolved := true
                hit_index := i
                break
            else if tp_hit
                outcome := 1   // TP hit first
                ltf_resolved := true
                hit_index := i
                break
    
    [outcome, ltf_resolved, hit_index]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOGARITHMIC RETURNS - Canonical Return Computation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_logReturn(float price_now, float price_prev) =>
    float result = 0.0
    if not na(price_now) and not na(price_prev) and price_prev > 0 and price_now > 0
        result := math.log(price_now / price_prev)
    result

f_logToSimpleReturn(float sum_log_returns) =>
    math.exp(sum_log_returns) - 1

f_getPeriodsPerYear() =>
    float result = float(LOG_PERIODS_DAILY)
    if timeframe.isseconds
        result := LOG_PERIODS_1M * 60 / timeframe.multiplier
    else if timeframe.isminutes
        if timeframe.multiplier <= 1
            result := LOG_PERIODS_1M
        else if timeframe.multiplier <= 5
            result := LOG_PERIODS_5M
        else if timeframe.multiplier <= 15
            result := LOG_PERIODS_15M
        else if timeframe.multiplier <= 60
            result := LOG_PERIODS_1H
        else
            result := LOG_PERIODS_4H
    else if timeframe.isdaily
        result := float(LOG_PERIODS_DAILY)
    else if timeframe.isweekly
        result := 52.0
    else if timeframe.ismonthly
        result := 12.0
    result

f_annualizedVol(float log_return_stdev, float periods_per_year) =>
    log_return_stdev * math.sqrt(periods_per_year)

// â”€â”€ MEMORY OPTIMIZATION - Circular buffer pattern (var arrays, push/shift, O(1) access)
//   All rolling-window storage: var array<T> initialized once, constant memory after warm-up
//   Pine v6: negative indexing (array.get(buf, -1)) = O(1) last-element access

method pushBounded(array<float> buf, float v, int window) =>
    if not na(v)
        buf.push(v)
        while buf.size() > window
            buf.shift()

method pushBounded(array<int> buf, int v, int window) =>
    if not na(v)
        buf.push(v)
        while buf.size() > window
            buf.shift()

method isFull(array<float> buf, int window) =>
    buf.size() >= window

method lastVal(array<float> buf) =>
    buf.size() > 0 ? buf.get(-1) : na

method prev(array<float> buf) =>
    buf.size() > 1 ? buf.get(-2) : na

// Single-pass O(N) computation; returns [mean, stdev]
method meanStdev(array<float> buf) =>
    int n = buf.size()
    float mean_val = 0.0
    float stdev_val = 0.0
    if n > 0
        float sum = 0.0
        float sq_sum = 0.0
        for i = 0 to n - 1
            float v = buf.get(i)
            sum += v
            sq_sum += v * v
        mean_val := sum / float(n)
        float variance = (sq_sum / float(n)) - (mean_val * mean_val)
        stdev_val := variance > 0 ? math.sqrt(variance) : 0.0
    [mean_val, stdev_val]

// â”€â”€ LAZY EVALUATION GUARDS - Execution flow optimization
//   Pine v6: strict bool (true|false only, never na), lazy and/or evaluation
//   Order conditions cheapest â†’ expensive to exploit short-circuit
//   Side-effect calls must NOT be in and/or operands (evaluation may be skipped)

f_readyForRegime(int window_bars) =>
    bar_index >= window_bars

// â”€â”€ PERFORMANCE CONTROLLER - Runtime budget management

perf_shouldComputeHeavy(bool enabled, int window_bars) =>
    enabled and barstate.isconfirmed and bar_index >= window_bars

perf_shouldRenderDebug() =>
    INPUT_PERF_PRESET == PERF_PRESET_DEBUG and barstate.islast

perf_shouldShowDebugOverlay(bool explicit_toggle) =>
    (explicit_toggle or INPUT_PERF_PRESET == PERF_PRESET_DEBUG) and barstate.islast

perf_shouldShowDashboard() =>
    INPUT_PERF_SHOW_DASHBOARD and barstate.islast

perf_getEntropyWindow(int user_window) =>
    INPUT_PERF_PRESET == PERF_PRESET_FAST and INPUT_PERF_DEGRADE_ENTROPY ? math.min(user_window, PERF_ENTROPY_WINDOW_FAST) : user_window

perf_getHurstWindow(int user_window) =>
    INPUT_PERF_PRESET == PERF_PRESET_FAST and INPUT_PERF_DEGRADE_HURST ? math.min(user_window, PERF_HURST_WINDOW_FAST) : user_window

perf_getHurstMode(string user_mode) =>
    INPUT_PERF_PRESET == PERF_PRESET_FAST and INPUT_PERF_DEGRADE_HURST ? STATIC_HURST_MODE_DYADIC_FAST : user_mode

perf_getEntropyMode(string user_mode) =>
    INPUT_PERF_PRESET == PERF_PRESET_FAST and INPUT_PERF_DEGRADE_ENTROPY ? ENTROPY_MODE_KGRAM : user_mode

perf_getVisualMaxKeep() =>
    INPUT_PERF_PRESET == PERF_PRESET_FAST ? PERF_VISUAL_KEEP_FAST : PERF_VISUAL_KEEP_BALANCED

perf_skipAlertJson() =>
    INPUT_PERF_PRESET == PERF_PRESET_FAST and INPUT_PERF_SKIP_ALERTS

perf_getPresetName() =>
    switch INPUT_PERF_PRESET
        PERF_PRESET_BALANCED => "Balanced"
        PERF_PRESET_FAST => "Fast"
        PERF_PRESET_DEBUG => "Debug"
        => "Unknown"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_canRunLearning(bool enabled, int min_samples, int history_size) =>
    enabled and barstate.islast and history_size >= min_samples

f_canComputeRegime(bool enabled, int window_bars) =>
    enabled and barstate.isconfirmed and bar_index >= window_bars

f_canSpawnSetup(bool changed, bool no_active, bool has_pivots) =>
    changed and no_active and has_pivots

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SHANNON ENTROPY - Regime Filter for Price Action Structure
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_shannonEntropy(array<int> bin_counts, int total_count, int num_bins) =>
    float entropy = 0.0
    if total_count > 0
        for i = 0 to num_bins - 1
            int count = array.get(bin_counts, i)
            if count > 0
                float p = float(count) / float(total_count)
                entropy -= p * math.log(p) / math.log(2)
    float max_entropy = math.log(float(num_bins)) / math.log(2)
    float entropy_norm = max_entropy > 0 ? entropy / max_entropy : 0.0
    [entropy, entropy_norm]

f_rollingEntropy(float log_return, int window, int num_bins, float threshold, bool allow_transition) =>
    var array<float> return_buffer = array.new<float>(0)
    var array<int> bin_counts = array.new<int>(0)
    var float prev_entropy_norm = na
    
    // Push using bounded pattern
    return_buffer.pushBounded(log_return, window)
    
    float entropy = 0.0
    float entropy_norm = 0.0
    int regime = ENTROPY_REGIME_DISORDERED
    
    int buf_size = return_buffer.size()
    if buf_size >= num_bins
        float min_ret = return_buffer.min()
        float max_ret = return_buffer.max()
        float range_ret = max_ret - min_ret
        
        // Reuse persistent bin_counts array (clear and resize)
        bin_counts.clear()
        for _i = 0 to num_bins - 1
            bin_counts.push(0)
        
        if range_ret > 0
            for i = 0 to buf_size - 1
                float r = return_buffer.get(i)
                int bin_idx = int(math.floor((r - min_ret) / range_ret * float(num_bins - 1)))
                bin_idx := math.min(bin_idx, num_bins - 1)
                bin_counts.set(bin_idx, bin_counts.get(bin_idx) + 1)
        else
            bin_counts.set(num_bins / 2, buf_size)
        
        [raw_h, norm_h] = f_shannonEntropy(bin_counts, buf_size, num_bins)
        entropy := raw_h
        entropy_norm := norm_h
        
        if entropy_norm < threshold
            regime := ENTROPY_REGIME_ORDERED
        else if allow_transition and not na(prev_entropy_norm) and prev_entropy_norm >= threshold and entropy_norm < threshold
            regime := ENTROPY_REGIME_TRANSITION
        else
            regime := ENTROPY_REGIME_DISORDERED
    
    prev_entropy_norm := entropy_norm
    [entropy, entropy_norm, regime]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SYMBOLIC ENTROPY ENGINE - O(1) incremental entropy
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Performance: O(window) per-bar loop replaced with O(1) incremental updates
// Uses binary symbolization and k-gram patterns with precomputed lookup tables.
// Doc-backed: Pine v6 arrays, var persistence, negative indexing (TradingView docs/arrays)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type SymbolicEntropyState
    bool  initialized = false
    string mode = ""
    int   k = 3
    int   window = 20
    int   states = 8
    int   mask = 7
    int   pattern = 0
    array<int> patternBuf = na
    array<int> counts = na
    array<float> cLog2c = na
    float sumCLogC = 0.0
    float log2N = 0.0
    float log2States = 0.0
    float prevEntropyNorm = na
    float entropy = 0.0
    float entropyNorm = 0.0
    int   regime = 2

method init(SymbolicEntropyState this, string mode, int k, int window) =>
    // Compute derived values
    int effectiveK = mode == ENTROPY_MODE_BINARY ? 1 : math.max(1, math.min(k, ENTROPY_K_MAX))
    int numStates = int(math.pow(2, effectiveK))
    int bitMask = numStates - 1
    
    // Store configuration
    this.mode := mode
    this.k := effectiveK
    this.window := window
    this.states := numStates
    this.mask := bitMask
    this.pattern := 0
    this.sumCLogC := 0.0
    this.prevEntropyNorm := na
    this.entropy := 0.0
    this.entropyNorm := 0.0
    this.regime := ENTROPY_REGIME_DISORDERED
    
    // Precompute log2(N) and log2(states) - only computed once per init
    // Doc-backed: math.log() is safe in init blocks (not per-bar)
    this.log2N := window > 0 ? math.log(float(window)) / math.log(2.0) : 0.0
    this.log2States := numStates > 1 ? math.log(float(numStates)) / math.log(2.0) : 1.0
    
    // Initialize pattern buffer (bounded)
    if na(this.patternBuf)
        this.patternBuf := array.new<int>(0)
    else
        this.patternBuf.clear()
    
    // Initialize frequency counts (one per state)
    if na(this.counts)
        this.counts := array.new<int>(numStates, 0)
    else
        this.counts.clear()
        for _i = 0 to numStates - 1
            this.counts.push(0)
    
    // Precompute c * log2(c) lookup table
    // This avoids math.log() calls during per-bar updates
    if na(this.cLog2c)
        this.cLog2c := array.new<float>(window + 1, 0.0)
    else
        this.cLog2c.clear()
        for c = 0 to window
            this.cLog2c.push(0.0)
    
    // Populate lookup: cLog2c[0] = 0, cLog2c[c] = c * log2(c) for c > 0
    float log2Base = math.log(2.0)
    this.cLog2c.set(0, 0.0)
    for c = 1 to window
        float clog2c = float(c) * math.log(float(c)) / log2Base
        this.cLog2c.set(c, clog2c)
    
    this.initialized := true
    this

method needsReinit(SymbolicEntropyState this, string mode, int k, int window) =>
    not this.initialized or this.mode != mode or this.k != k or this.window != window

f_binaryState(float price_now, float price_prev) =>
    // Edge case: first bar or na prices â†’ default to 0
    if na(price_now) or na(price_prev)
        0
    else
        price_now > price_prev ? 1 : 0

method update(SymbolicEntropyState this, int state, float threshold, bool allowTransition) =>
    if not this.initialized
        this
    else
        // Update k-gram pattern (bitwise shift + mask)
        // Pattern slides left, new state enters from right
        this.pattern := ((this.pattern * 2) + state) % (this.mask + 1)
        
        int patternId = this.pattern
        int bufSize = this.patternBuf.size()
        
        // Incremental frequency update
        // Step 1: Get old count for new pattern, update sumCLogC
        int oldCountNew = this.counts.get(patternId)
        float oldCLogCNew = this.cLog2c.get(oldCountNew)
        int newCountNew = oldCountNew + 1
        float newCLogCNew = newCountNew <= this.window ? this.cLog2c.get(newCountNew) : float(newCountNew) * math.log(float(newCountNew)) / math.log(2.0)
        
        // Update sumCLogC incrementally
        this.sumCLogC := this.sumCLogC - oldCLogCNew + newCLogCNew
        this.counts.set(patternId, newCountNew)
        
        // Push new pattern to buffer
        this.patternBuf.push(patternId)
        
        // Step 2: If buffer exceeds window, remove oldest
        if this.patternBuf.size() > this.window
            int oldPatternId = this.patternBuf.shift()
            
            // Update counts and sumCLogC for removed pattern
            int oldCountOld = this.counts.get(oldPatternId)
            float oldCLogCOld = this.cLog2c.get(oldCountOld)
            int newCountOld = math.max(0, oldCountOld - 1)
            float newCLogCOld = this.cLog2c.get(newCountOld)
            
            this.sumCLogC := this.sumCLogC - oldCLogCOld + newCLogCOld
            this.counts.set(oldPatternId, newCountOld)
        
        // Compute entropy only when buffer is full (warm-up complete)
        int currentBufSize = this.patternBuf.size()
        if currentBufSize >= this.window
            // Entropy formula: H = log2(N) - sumCLogC / N
            // Doc-backed: This avoids per-bar math.log() calls
            float N = float(this.window)
            this.entropy := this.log2N - (this.sumCLogC / N)
            
            // Clamp to valid range [0, log2(states)]
            this.entropy := math.max(0.0, math.min(this.entropy, this.log2States))
            
            // Normalize to [0, 1]
            this.entropyNorm := this.log2States > 0 ? this.entropy / this.log2States : 0.0
            
            // Regime classification
            if this.entropyNorm < threshold
                this.regime := ENTROPY_REGIME_ORDERED
            else if allowTransition and not na(this.prevEntropyNorm) and this.prevEntropyNorm >= threshold and this.entropyNorm < threshold
                this.regime := ENTROPY_REGIME_TRANSITION
            else
                this.regime := ENTROPY_REGIME_DISORDERED
            
            this.prevEntropyNorm := this.entropyNorm
        else
            // Buffer not full - return na/default
            this.entropy := na
            this.entropyNorm := na
            this.regime := ENTROPY_REGIME_DISORDERED
        
        this

method getResults(SymbolicEntropyState this) =>
    [this.entropy, this.entropyNorm, this.regime]

method getDebugInfo(SymbolicEntropyState this) =>
    string info = "ENTROPY DEBUG\n"
    info += "Mode: " + this.mode + "\n"
    info += "K: " + str.tostring(this.k) + "\n"
    info += "States: " + str.tostring(this.states) + "\n"
    info += "Window: " + str.tostring(this.window) + "\n"
    info += "Buffer: " + str.tostring(this.patternBuf.size()) + "\n"
    info += "H_raw: " + str.tostring(this.entropy, "#.####") + "\n"
    info += "H_norm: " + str.tostring(this.entropyNorm, "#.####") + "\n"
    info += "Regime: " + (this.regime == ENTROPY_REGIME_ORDERED ? "ORDERED" : this.regime == ENTROPY_REGIME_TRANSITION ? "TRANSITION" : "DISORDERED") + "\n"
    // Counts sum check (for validation)
    int countsSum = 0
    for i = 0 to this.counts.size() - 1
        countsSum += this.counts.get(i)
    info += "Counts Sum: " + str.tostring(countsSum) + " (expected: " + str.tostring(this.patternBuf.size()) + ")"
    info

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HURST EXPONENT - Regime Filter for Market Persistence
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_computeRS(array<float> data, int start_idx, int length) =>
    float result = na
    if length >= 2 and start_idx >= 0 and start_idx + length <= array.size(data)
        // Compute mean of window
        float sum = 0.0
        for i = 0 to length - 1
            sum += array.get(data, start_idx + i)
        float mean_val = sum / float(length)
        
        // Compute mean-adjusted cumulative deviations and stdev
        float cum_dev = 0.0
        float min_cum = 0.0
        float max_cum = 0.0
        float sq_sum = 0.0
        
        for i = 0 to length - 1
            float val = array.get(data, start_idx + i)
            float dev = val - mean_val
            cum_dev += dev
            min_cum := i == 0 ? cum_dev : math.min(min_cum, cum_dev)
            max_cum := i == 0 ? cum_dev : math.max(max_cum, cum_dev)
            sq_sum += dev * dev
        
        // Range = max(cumulative) - min(cumulative)
        float range_val = max_cum - min_cum
        // Standard deviation
        float stdev = math.sqrt(sq_sum / float(length))
        
        // R/S = Range / StdDev (with S=0 handling)
        result := stdev > 0 ? range_val / stdev : 0.0
    result

f_rollingHurst(float log_return, int window, int min_window, float trend_thresh, float meanrev_thresh) =>
    var array<float> return_buffer = array.new<float>(0)
    var array<float> log_n = array.new<float>(0)
    var array<float> log_rs = array.new<float>(0)
    
    // Push using bounded pattern
    return_buffer.pushBounded(log_return, window)
    
    float hurst = 0.5
    int regime = HURST_REGIME_RANDOM
    
    int buf_size = return_buffer.size()
    
    if buf_size >= min_window
        // Clear persistent regression arrays for reuse
        log_n.clear()
        log_rs.clear()
        
        int n = min_window
        while n <= buf_size
            int num_chunks = buf_size / n
            if num_chunks > 0
                float rs_sum = 0.0
                int valid_chunks = 0
                for chunk = 0 to num_chunks - 1
                    int start = chunk * n
                    float rs = f_computeRS(return_buffer, start, n)
                    if not na(rs) and rs > 0
                        rs_sum += rs
                        valid_chunks += 1
                
                if valid_chunks > 0
                    float avg_rs = rs_sum / float(valid_chunks)
                    log_n.push(math.log(float(n)))
                    log_rs.push(math.log(avg_rs))
            
            n := int(math.ceil(float(n) * 1.5))
        
        int num_points = log_n.size()
        if num_points >= 2
            float sum_x = 0.0
            float sum_y = 0.0
            float sum_xy = 0.0
            float sum_xx = 0.0
            
            for i = 0 to num_points - 1
                float x = log_n.get(i)
                float y = log_rs.get(i)
                sum_x += x
                sum_y += y
                sum_xy += x * y
                sum_xx += x * x
            
            float n_pts = float(num_points)
            float denom = n_pts * sum_xx - sum_x * sum_x
            if math.abs(denom) > 1e-10
                hurst := (n_pts * sum_xy - sum_x * sum_y) / denom
                hurst := math.max(0.0, math.min(1.0, hurst))
        
        if hurst > trend_thresh
            regime := HURST_REGIME_TREND
        else if hurst < meanrev_thresh
            regime := HURST_REGIME_MEANREV
        else
            regime := HURST_REGIME_RANDOM
    
    [hurst, regime]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DYADIC HURST ENGINE - O(log N) optimized implementation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Dyadic scales: powers-of-two for predictable runtime
//       Precomputes regression X constants to eliminate per-bar array allocations.
//       Provides STABLE (multi-chunk average) and FAST (single recent chunk) modes.

type DyadicHurstState
    // Configuration (detect changes for reinit)
    int configWindow        // Current window setting
    int configMinWindow     // Current min window setting
    string configMode       // Current mode setting
    bool initialized        // Whether state is ready
    
    // Dyadic Scales (built once, rebuilt on config change)
    array<int> scales       // Array of power-of-two scales: 4, 8, 16, 32, ...
    
    // Precomputed regression X constants
    array<float> logScales  // log(n) for each scale
    float sumX              // Î£ log(n)
    float sumXX             // Î£ log(n)Â²
    int numScales           // Number of dyadic scales
    
    // Return buffer (persistent, bounded)
    array<float> returnBuf  // Rolling buffer of log returns
    
    // Current Hurst result
    float hurst             // Last computed Hurst exponent
    int hurstRegime         // Last computed regime

method init(DyadicHurstState this, int minW, int maxW, string mode) =>
    this.configWindow := maxW
    this.configMinWindow := minW
    this.configMode := mode
    
    // Build dyadic scales: powers of 2 from minW to maxW
    this.scales := array.new<int>(0)
    this.logScales := array.new<float>(0)
    
    // Find smallest power-of-two >= minW
    int pwr = 1
    while pwr < minW
        pwr *= 2
    
    // Build scales up to maxW
    while pwr <= maxW
        this.scales.push(pwr)
        this.logScales.push(math.log(float(pwr)))
        pwr *= 2
    
    this.numScales := this.scales.size()
    
    // Precompute X regression constants (computed once)
    this.sumX := 0.0
    this.sumXX := 0.0
    for i = 0 to this.numScales - 1
        float x = this.logScales.get(i)
        this.sumX += x
        this.sumXX += x * x
    
    // Initialize return buffer if needed
    if na(this.returnBuf)
        this.returnBuf := array.new<float>(0)
    
    this.hurst := 0.5
    this.hurstRegime := HURST_REGIME_RANDOM
    this.initialized := true

method needsReinit(DyadicHurstState this, int minW, int maxW, string mode) =>
    not this.initialized or this.configWindow != maxW or this.configMinWindow != minW or this.configMode != mode

method computeAvgRS(DyadicHurstState this, int n, bool fast) =>
    float result = na
    int bufSize = this.returnBuf.size()
    
    if bufSize >= n
        if fast
            // FAST mode: Only compute R/S on most recent chunk (O(n) per scale)
            int start = bufSize - n
            result := f_computeRS(this.returnBuf, start, n)
        else
            // STABLE mode: Average R/S across all non-overlapping chunks
            int numChunks = bufSize / n
            if numChunks > 0
                float rsSum = 0.0
                int validChunks = 0
                for chunk = 0 to numChunks - 1
                    int start = chunk * n
                    float rs = f_computeRS(this.returnBuf, start, n)
                    if not na(rs) and rs > 0
                        rsSum += rs
                        validChunks += 1
                if validChunks > 0
                    result := rsSum / float(validChunks)
    result

method update(DyadicHurstState this, float logReturn, bool fast, float trendThresh, float meanrevThresh) =>
    // Push log return to bounded buffer
    this.returnBuf.pushBounded(logReturn, this.configWindow)
    
    int bufSize = this.returnBuf.size()
    
    // Only compute if we have enough data for at least one scale
    if bufSize >= this.configMinWindow and this.numScales >= 2
        // Compute regression without per-bar array allocations
        // We accumulate Î£y and Î£xy directly using precomputed logScales
        float sumY = 0.0
        float sumXY = 0.0
        int validPts = 0
        
        for i = 0 to this.numScales - 1
            int n = this.scales.get(i)
            if bufSize >= n
                float avgRS = this.computeAvgRS(n, fast)
                if not na(avgRS) and avgRS > 0
                    float logRS = math.log(avgRS)
                    float logN = this.logScales.get(i)
                    sumY += logRS
                    sumXY += logN * logRS
                    validPts += 1
        
        // Compute Hurst via linear regression slope
        if validPts >= 2
            // Use precomputed X constants but only for valid points
            // Recalculate sumX and sumXX for only the valid scales
            float validSumX = 0.0
            float validSumXX = 0.0
            int validIdx = 0
            for i = 0 to this.numScales - 1
                int n = this.scales.get(i)
                if bufSize >= n
                    float avgRS = this.computeAvgRS(n, fast)
                    if not na(avgRS) and avgRS > 0
                        float logN = this.logScales.get(i)
                        validSumX += logN
                        validSumXX += logN * logN
                        validIdx += 1
                        if validIdx >= validPts
                            break
            
            float nPts = float(validPts)
            float denom = nPts * validSumXX - validSumX * validSumX
            if math.abs(denom) > 1e-10
                this.hurst := (nPts * sumXY - validSumX * sumY) / denom
                this.hurst := math.max(0.0, math.min(1.0, this.hurst))
        
        // Classify regime
        if this.hurst > trendThresh
            this.hurstRegime := HURST_REGIME_TREND
        else if this.hurst < meanrevThresh
            this.hurstRegime := HURST_REGIME_MEANREV
        else
            this.hurstRegime := HURST_REGIME_RANDOM
    else
        this.hurst := 0.5
        this.hurstRegime := HURST_REGIME_RANDOM

method getResults(DyadicHurstState this) =>
    [this.hurst, this.hurstRegime]

method getDebugInfo(DyadicHurstState this) =>
    string scaleStr = ""
    if this.numScales > 0
        scaleStr := str.tostring(this.scales.get(0))
        if this.numScales > 1
            scaleStr += "â†’" + str.tostring(this.scales.get(this.numScales - 1))
    string info = "Mode: " + this.configMode + 
                  "\nScales: " + str.tostring(this.numScales) + " (" + scaleStr + ")" +
                  "\nWindow: " + str.tostring(this.configWindow) + 
                  "\nBuffer: " + str.tostring(this.returnBuf.size()) +
                  "\nH: " + str.tostring(this.hurst, "#.####") +
                  "\nRegime: " + (this.hurstRegime == HURST_REGIME_TREND ? "TREND" : this.hurstRegime == HURST_REGIME_MEANREV ? "MEANREV" : "RANDOM")
    info

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Z-SCORE MOMENTUM - Regression Slope for Displacement Validation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_linregSlope(float src, int length) =>
    float slope = 0.0
    if length >= 2 and bar_index >= length - 1
        float sum_x = 0.0
        float sum_y = 0.0
        float sum_xy = 0.0
        float sum_xx = 0.0
        for i = 0 to length - 1
            float x = float(i)
            float y = nz(src[length - 1 - i])
            sum_x += x
            sum_y += y
            sum_xy += x * y
            sum_xx += x * x
        float n = float(length)
        float denom = n * sum_xx - sum_x * sum_x
        slope := math.abs(denom) > 1e-10 ? (n * sum_xy - sum_x * sum_y) / denom : 0.0
    slope

f_rollingZScore(float norm_slope, int z_len, int min_samples, float z_thresh) =>
    var array<float> slope_buffer = array.new<float>(0)
    
    // Push using bounded pattern
    slope_buffer.pushBounded(norm_slope, z_len)
    
    float z_score = 0.0
    bool strong_momentum = false
    
    int buf_size = slope_buffer.size()
    if buf_size >= min_samples
        // Single-pass mean/stdev computation
        [mean_val, stdev] = slope_buffer.meanStdev()
        
        // Compute Z-score using last value via negative indexing
        float last_slope = slope_buffer.lastVal()
        z_score := stdev > 1e-10 ? (last_slope - mean_val) / stdev : 0.0
        strong_momentum := math.abs(z_score) >= z_thresh
    
    [z_score, strong_momentum]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DYNAMIC REQUEST ENGINE - External Context Fetching with Budget Awareness
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_parseSymbols(string csv, int max_count) =>
    array<string> result = array.new<string>(0)
    if na(csv) or str.length(csv) == 0
        result
    else
        array<string> parts = str.split(csv, ",")
        int parsed = 0
        for i = 0 to array.size(parts) - 1
            if parsed >= max_count
                break
            string raw = array.get(parts, i)
            string trimmed = str.replace_all(str.replace_all(raw, " ", ""), "\t", "")
            if str.length(trimmed) > 0
                array.push(result, trimmed)
                parsed += 1
        result

f_getExtTimeframe(string tf_mode, string tf_custom) =>
    tf_mode == EXT_TF_CURRENT ? timeframe.period : tf_custom

f_computeExtGate(string gate_mode, int entropy_regime, float hurst, float hurst_meanrev) =>
    switch gate_mode
        EXT_GATE_ALWAYS => true
        EXT_GATE_ENTROPY => entropy_regime == ENTROPY_REGIME_DISORDERED
        EXT_GATE_HURST => not na(hurst) and hurst < hurst_meanrev
        EXT_GATE_CUSTOM => true
        => true

f_reqExtClose(string sym, string tf) =>
    request.security(sym, tf, close, ignore_invalid_symbol = true)

f_reqExtOHLCV(string sym, string tf) =>
    request.security(sym, tf, [open, high, low, close, volume], ignore_invalid_symbol = true)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BAYESIAN WIN-RATE - Beta-Binomial Model for Sample-Size Penalized Estimation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_betaMean(float alpha, float beta_param) =>
    float total = alpha + beta_param
    total > 0 ? alpha / total : 0.5

f_betaVariance(float alpha, float beta_param) =>
    float total = alpha + beta_param
    float denom = total * total * (total + 1.0)
    denom > 1e-10 ? (alpha * beta_param) / denom : 0.0

//              Valid when Î±, Î² > 1 and sample size is moderate.
//              Clamps result to [0, 1] to ensure valid probability.
f_betaLowerBound(float alpha, float beta_param, float percentile) =>
    float mean_val = f_betaMean(alpha, beta_param)
    float var_val = f_betaVariance(alpha, beta_param)
    float stdev = math.sqrt(var_val)
    
    // Z-score for percentile (approximation for common values)
    // percentile 0.05 â†’ z â‰ˆ -1.645, percentile 0.10 â†’ z â‰ˆ -1.282
    float z_score = percentile <= 0.05 ? -1.645 : percentile <= 0.10 ? -1.282 : percentile <= 0.25 ? -0.674 : 0.0
    
    float lower_bound = mean_val + z_score * stdev
    // Clamp to valid probability range
    math.max(0.0, math.min(1.0, lower_bound))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SORTINO RATIO - Downside-Risk Adjusted Performance Metric
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_sortino(array<float> returns, float mar, float rf, float max_cap) =>
    int n = array.size(returns)
    if n < 2
        0.0
    else
        // Compute mean return
        float sum_returns = 0.0
        for i = 0 to n - 1
            sum_returns += array.get(returns, i)
        float mean_return = sum_returns / float(n)
        
        // Compute downside deviation (only returns below MAR)
        float sum_sq_downside = 0.0
        int downside_count = 0
        for i = 0 to n - 1
            float ret = array.get(returns, i)
            if ret < mar
                float diff = ret - mar
                sum_sq_downside += diff * diff
                downside_count += 1
        
        // Downside deviation = sqrt(mean of squared downside deviations)
        float downside_dev = downside_count > 0 ? math.sqrt(sum_sq_downside / float(n)) : 0.0
        
        // Sortino = (mean - rf) / downside_dev
        if downside_dev > 1e-10
            (mean_return - rf) / downside_dev
        else
            // No downside returns: return capped positive or 0 based on mean
            mean_return > rf ? max_cap : 0.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MONTE CARLO PERMUTATION - Fisher-Yates Shuffle & Significance Testing
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_lcgNext(int seed) =>
    int a = 1664525
    int c = 1013904223
    int m = 2147483647
    (a * seed + c) % m

f_fisherYatesShuffle(array<float> arr, int seed) =>
    int n = array.size(arr)
    int current_seed = seed
    if n > 1
        for i = n - 1 to 1
            current_seed := f_lcgNext(current_seed)
            int j = current_seed % (i + 1)
            float temp = array.get(arr, i)
            array.set(arr, i, array.get(arr, j))
            array.set(arr, j, temp)
    current_seed

f_maxDrawdown(array<float> returns) =>
    int n = array.size(returns)
    if n < 1
        0.0
    else
        float equity = 1.0
        float peak = 1.0
        float max_dd = 0.0
        for i = 0 to n - 1
            float ret = array.get(returns, i)
            equity := equity * math.exp(ret)
            peak := math.max(peak, equity)
            float dd = (peak - equity) / peak
            max_dd := math.max(max_dd, dd)
        max_dd

f_monteCarloDD(array<float> returns, int num_sims, int seed_base) =>
    int n = array.size(returns)
    float original_dd = 0.0
    float mean_shuffled_dd = 0.0
    float p_value = 1.0
    int sims_run = 0
    
    if n >= MC_MIN_TRADES
        original_dd := f_maxDrawdown(returns)
        float sum_shuffled_dd = 0.0
        int better_count = 0
        
        array<float> shuffled = array.copy(returns)
        int current_seed = seed_base
        
        for sim = 0 to num_sims - 1
            shuffled := array.copy(returns)
            current_seed := f_fisherYatesShuffle(shuffled, current_seed + sim)
            float shuffled_dd = f_maxDrawdown(shuffled)
            sum_shuffled_dd += shuffled_dd
            if shuffled_dd < original_dd
                better_count += 1
            sims_run += 1
        
        mean_shuffled_dd := sum_shuffled_dd / float(num_sims)
        p_value := float(better_count) / float(num_sims)
    
    [original_dd, mean_shuffled_dd, p_value, sims_run]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEARNING ENGINE CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Minimum sample thresholds
int   LEARN_MIN_SAMPLES_SL      = 20
int   LEARN_MIN_SAMPLES_BUFFER  = 10
int   LEARN_MIN_SAMPLES_WR      = 10
int   LEARN_MIN_SAMPLES_MAE     = 5
int   LEARN_MIN_SAMPLES_DIV     = 5
int   LEARN_MIN_SAMPLES_DIR     = 5
int   LEARN_MIN_SAMPLES_LOSING  = 3
int   LEARN_MIN_SAMPLES_TP_COMP = 10
int   LEARN_MIN_SAMPLES_TIME    = 10

// Volatility regime thresholds
int   VOL_REGIME_HIGH_THRESH    = 60
int   VOL_REGIME_LOW_THRESH     = 40

// Near-miss detection
float STATIC_NEAR_MISS_RATE_THRESH     = 0.10
float STATIC_NEAR_MISS_BUFFER_MULT     = 5.0
float STATIC_NEAR_MISS_BUFFER_MAX      = 5.0
float STATIC_NEAR_MISS_CLOSE_THRESH    = 0.3

// Time decay Fibonacci thresholds
int   TIME_DECAY_T1             = 8
int   TIME_DECAY_T2             = 13
int   TIME_DECAY_T3             = 21
int   TIME_DECAY_T4             = 34
int   TIME_DECAY_T5             = 55
float TIME_DECAY_DEFAULT_RATE   = 0.85
float STATIC_TIME_DECAY_SCALE_MIN      = 0.5
float STATIC_TIME_DECAY_SCALE_MAX      = 2.0
int   TIME_DECAY_REFERENCE_BARS = 13

// SL learning
float STATIC_SL_BUFFER_ATR             = 0.5
float STATIC_SL_LOSING_MAE_FACTOR      = 1.5

// Confidence scoring thresholds
int   CONF_UI_GRADE_D_THRESH       = 25
int   CONF_UI_GRADE_C_THRESH       = 50
int   CONF_UI_GRADE_B_THRESH       = 70
int   CONF_UI_GRADE_A_THRESH       = 85

// Streak tracking
int   STREAK_WIN_BONUS_THRESH   = 3
int   STREAK_LOSS_PENALTY_THRESH = 3
int   STREAK_PENALTY_MAX        = 15
float STATIC_STREAK_PENALTY_RATE       = 5.0
int   STREAK_LOSS_PENALTY_BASE  = 2
int   STREAK_BONUS_MAX          = 10
float STATIC_STREAK_BONUS_RATE         = 3.33
int   STREAK_WIN_BONUS_BASE     = 2

// Health check thresholds
int   HEALTH_STALE_BARS         = 100
float STATIC_HEALTH_WR_MIN             = 0.25
float STATIC_HEALTH_WR_MAX             = 0.85
float STATIC_HEALTH_PF_MIN             = 0.7

// Kelly calculation
float STATIC_KELLY_MIN_EDGE            = 0.01

// Decay rate learning
float STATIC_DECAY_RATE_MIN            = 0.75
float STATIC_DECAY_RATE_MAX            = 0.95
float STATIC_DECAY_RATE_ADJUST         = 0.14

// Confidence scoring weights
int   CONF_WR_WEIGHT            = 35
float STATIC_CONF_WR_MIN_MAP           = 0.3
float STATIC_CONF_WR_MAX_MAP           = 0.8
int   CONF_RSI_WEIGHT           = 20
int   CONF_PF_WEIGHT            = 15
int   CONF_HEALTH_WEIGHT        = 15
float STATIC_CONF_PF_MIN_MAP           = 0.5
float STATIC_CONF_PF_MAX_MAP           = 2.0

// Default initial values
float DEFAULT_WIN_RATE          = 0.618
float DEFAULT_DECAY_RATE        = 0.85
float DEFAULT_CONFIDENCE        = 50.0
float DEFAULT_MIN_DISTANCE      = 100.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI TEXT CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string TEXT_LONG        = "LONG"
string TEXT_SHORT       = "SHORT"
string TEXT_SETUP       = " SETUP"
string TEXT_ACTIVE      = " [ACTIVE]"
string TEXT_SL_HIT      = " [SL HIT]"
string TEXT_TP_HIT      = " [TP HIT]"
string TEXT_EXPIRED     = " [EXPIRED]"
string TEXT_FRESH       = "FRESH"
string TEXT_STALE       = "STALE"
string TEXT_LEARNING    = "ğŸ“Š Learning..."
string TEXT_SAMPLES     = " samples"

// UI Icons
string UI_ICON_BRAIN       = "ğŸ§ "
string UI_ICON_CHART       = "ğŸ“Š"
string UI_ICON_TARGET      = "ğŸ¯"
string UI_ICON_FIRE        = "ğŸ”¥"
string UI_ICON_ICE         = "â„ï¸"
string UI_ICON_LIGHTNING   = "âš¡"
string UI_ICON_WAVE        = "ğŸŒŠ"
string UI_ICON_CHECK       = "âœ“"
string UI_ICON_WARNING     = "âš "
string UI_ICON_HOURGLASS   = "â³"
string UI_ICON_STOP        = "ğŸ›‘"
string UI_ICON_SCALE       = "âš–ï¸"

// Position Display
string TEXT_TP_PREFIX   = "\n" + UI_ICON_TARGET + " TP: "
string TEXT_SL_PREFIX   = "\n" + UI_ICON_STOP + " SL: "
string TEXT_RR_PREFIX   = "\n" + UI_ICON_SCALE + " R:R "
string TEXT_PROJ_TAG    = " " + UI_ICON_LIGHTNING + "PROJ"
string TEXT_ACTIVE_TAG  = " " + UI_ICON_CHECK + "ACTIVE"
string TEXT_SMART_SL    = "\n   " + UI_ICON_TARGET + " Smart SL: "

// Learning Display
string TEXT_L_BUF       = " | Buf:+"
string TEXT_L_WR        = " | WR:"
string TEXT_L_MAE       = "\n   MAE:"
string TEXT_L_MFE       = " MFE:"
string TEXT_L_SL_MULT   = " SL*:"
string TEXT_L_TAU       = " Ï„:"
string TEXT_L_DIV       = "\n   DIV:"
string TEXT_L_EDGE      = "% edge"
string TEXT_L_LONG      = "\n   L:"
string TEXT_L_SHORT     = " S:"
string TEXT_L_XMAE      = " âœ—MAE:"
string TEXT_L_TP        = "\n   " + UI_ICON_BRAIN + " TP:"
string TEXT_L_DECAY     = " Decay:"
string TEXT_L_RSIWT     = " RSIwt:"
string TEXT_L_CONF      = "\n   " + UI_ICON_TARGET + " Conf:"
string TEXT_L_PF        = "\n   PF:"
string TEXT_L_EXP       = " Exp:"
string TEXT_L_HIGHVOL   = "\n   " + UI_ICON_LIGHTNING + "HighVol"
string TEXT_L_LOWVOL    = "\n   " + UI_ICON_WAVE + " LowVol"
string TEXT_L_SR        = "\n   SR:"
string TEXT_L_WARN      = "\n   " + UI_ICON_WARNING + " "
string TEXT_L_FIRE      = "\n   " + UI_ICON_FIRE + " "
string TEXT_L_STREAK_L  = "L streak"
string TEXT_L_STREAK_W  = "W streak"

// Backtest Display
string TEXT_BT_PREFIX   = "\n" + UI_ICON_CHART + " Backtested "
string TEXT_BT_TRADES   = " Trades: "
string TEXT_BT_WR       = "% WR"
string TEXT_BT_LOW      = " " + UI_ICON_WARNING + "LOW"
string TEXT_BT_EMPTY    = "\n" + UI_ICON_CHART + " Backtesting... (0 trades)"

// Rating Symbols
string UI_SYM_UP           = "â–²"
string UI_SYM_DOWN         = "â–¼"
string UI_SYM_EQUAL        = "="
string UI_SYM_MINUS        = "âˆ’"
string UI_SYM_CIRCLE       = "â—‹"
string UI_SYM_PLUS         = "+"
string UI_UI_SYM_PLUSPLUS     = "++"
string UI_SYM_CROSS        = "âœ—"

// Grade Labels
string UI_GRADE_D          = "D"
string UI_GRADE_C          = "C"
string UI_GRADE_B          = "B"
string UI_GRADE_A          = "A"
string UI_UI_GRADE_APLUS      = "A+"

// TP Mode Labels
string TEXT_TP_AGGR     = "Aggr"
string TEXT_TP_CONS     = "Cons"

// Misc Text
string TEXT_R_SUFFIX    = "R"
string TEXT_BARS        = "bars"
string TEXT_PCT_SUFFIX  = "%"
string TEXT_SPACE       = " "
string TEXT_DASH        = "â€”"

// Plotchar Labels
string UI_LABEL_EXHAUST    = "Exhaustion Bar"
string UI_LABEL_HIGH_VOL   = "High Volatile Bar"
string UI_ICON_TRAFFIC     = "ğŸš¦"

// Table Headers
string UI_TBL_ENTROPY      = "Entropy Debug"
string UI_TBL_HURST        = "Hurst Debug"
string UI_TBL_EXT          = "External Context"
string UI_TBL_PERF         = "âš¡ Perf Dashboard"

// Table Fields
string UI_FLD_MODE         = "Mode"
string UI_FLD_COMPLEXITY   = "Complexity"
string UI_FLD_STATES       = "States"
string UI_FLD_K_GRAM       = "K (k-gram)"
string UI_FLD_WINDOW       = "Window"
string UI_FLD_H_RAW        = "H_raw"
string UI_FLD_H_NORM       = "H_norm"
string UI_FLD_REGIME       = "Regime"
string UI_FLD_ENTROPY_OK   = "entropyOk"
string UI_FLD_BUFFER       = "Buffer"
string UI_FLD_BUFFER_OK    = "Buffer âœ“"
string UI_FLD_SCALES       = "Scales"
string UI_FLD_H_VALUE      = "H Value"
string UI_FLD_HURST_OK     = "hurstOk"
string UI_FLD_CHUNKS       = "Chunks"
string UI_FLD_ENABLED      = "Enabled"
string UI_FLD_GATED        = "Gated"
string UI_FLD_BUDGET_OK    = "Budget OK"

// Dashboard Section Headers
string UI_TBL_SECTION_SETTINGS = UI_TBL_SECTION_SETTINGS
string UI_TBL_SECTION_TOGGLES  = UI_TBL_SECTION_TOGGLES
string UI_TBL_SECTION_RUNTIME  = UI_TBL_SECTION_RUNTIME
string UI_TBL_EXEC_FLOW        = UI_TBL_EXEC_FLOW

// Dashboard Fields (additional)
string UI_FLD_ENTROPY_MODE     = UI_FLD_ENTROPY_MODE
string UI_FLD_ENTROPY_WINDOW   = UI_FLD_ENTROPY_WINDOW
string UI_FLD_HURST_MODE       = UI_FLD_HURST_MODE
string UI_FLD_HURST_WINDOW     = UI_FLD_HURST_WINDOW
string UI_FLD_ENTROPY_FILTER   = UI_FLD_ENTROPY_FILTER
string UI_FLD_HURST_FILTER     = UI_FLD_HURST_FILTER
string UI_FLD_ZSCORE_FILTER    = UI_FLD_ZSCORE_FILTER
string UI_FLD_MONTE_CARLO      = UI_FLD_MONTE_CARLO
string UI_FLD_LEARNING_ENGINE  = UI_FLD_LEARNING_ENGINE
string UI_FLD_VISUAL_MAX_KEEP  = UI_FLD_VISUAL_MAX_KEEP
string UI_FLD_ENTROPY_RUNS     = UI_FLD_ENTROPY_RUNS
string UI_FLD_HURST_RUNS       = UI_FLD_HURST_RUNS
string UI_FLD_ZSCORE_RUNS      = UI_FLD_ZSCORE_RUNS
string UI_FLD_LEARNING_RUNS    = UI_FLD_LEARNING_RUNS
string UI_FLD_SPAWN_ATTEMPTS   = UI_FLD_SPAWN_ATTEMPTS
string UI_FLD_SPAWN_BLOCKED    = UI_FLD_SPAWN_BLOCKED
string UI_FLD_BLOCK_RATE       = UI_FLD_BLOCK_RATE
string UI_FLD_CONTEXTS         = UI_FLD_CONTEXTS
string UI_FLD_VALID            = UI_FLD_VALID
string UI_FLD_SYMBOL_0         = UI_FLD_SYMBOL_0
string UI_FLD_EXT_OK           = UI_FLD_EXT_OK

// EV Grade Labels
string UI_TEXT_EV_NEG      = "âˆ’EV"
string UI_TEXT_EV_MARGINAL = "marginal"
string UI_TEXT_EV_DECENT   = "decent"
string UI_TEXT_EV_STRONG   = "strong"
string UI_TEXT_EV_EXCEPT   = "exceptional"
string UI_TEXT_EV_CONF_YES = UI_ICON_CHECK
string UI_TEXT_EV_CONF_NO  = "?"

// Status Labels
string UI_TEXT_ON          = UI_ICON_CHECK + " ON"
string UI_TEXT_OFF         = UI_SYM_CROSS + " OFF"
string UI_TEXT_EXCEEDED    = UI_ICON_WARNING + " EXCEEDED"
string UI_TEXT_DEGRADE_PFX = UI_ICON_LIGHTNING + " "

// Tooltips
string TOOLTIP_THRESHOLD   = 'Deviation is a multiplier that affects how much the price should deviate from the previous pivot in order for the bar to become a new pivot\n\nDepth affects the minimum number of bars that will be taken into account when building'
string TOOLTIP_PIVOT_POINT = 'A pivot point is a technical analysis indicator used to determine the overall trend of the market over different time frames'
string TOOLTIP_ZIGZAG      = 'The Zig Zag indicator is used to identify price trends then connected by straight lines that help the trader visual the price action.'
string TOOLTIP_VOL_EXHAUST = 'Moments where huge volume detected'
string TOOLTIP_HIGH_VOL    = 'Moments where price range of the current bar is greater than average true range'
string TOOLTIP_STAT_POS    = 'Calculates the Statistical "Golden Pocket" (0.618-0.65) entry zone.\n\nStop Loss is placed at the Pivot Start (Invalidation) adjusted by an ATR variance to prevent Stop Hunting.\n\nTake Profit targets the Pivot End (Conservative) or 1.272 Extension (Aggressive).'

// Groups
string GROUP_PICK       = 'Pick a Fibonacci Tool'
string GROUP_PIVOT      = 'Fibonacci Pivot Points Settings'
string GROUP_THRESH_SEC = 'Threshold (sec)'
string GROUP_THRESH_MIN = 'Threshold (minutes)'
string GROUP_THRESH_H   = 'Threshold (hours)'
string GROUP_THRESH_D   = 'Threshold (days)'
string GROUP_THRESH_W   = 'Threshold (weeks)'
string GROUP_THRESH_M   = 'Threshold (months)'
string GROUP_DEPTH_SEC  = 'Depth (seconds)'
string GROUP_DEPTH_MIN  = 'Depth (minutes)'
string GROUP_DEPTH_H    = 'Depth (hours)'
string GROUP_DEPTH_D    = 'Depth (days)'
string GROUP_DEPTH_W    = 'Depth (weeks)'
string GROUP_DEPTH_M    = 'Depth (months)'
string GROUP_FIB_TOOL   = 'Fibonacci Extention / Retracement / TimeZone Settings'
string GROUP_FIB_LEVELS = 'Fibonacci Levels'
string GROUP_ZIGZAG     = 'ZigZag Settings'
string GROUP_VOL_VOL    = 'Volume / Volatility AddOns'
string GROUP_ALERTS     = 'Alerts'
string GROUP_STAT_POS   = 'Statistical Position Engine'
string GROUP_EXT_CTX    = 'External Context (Dynamic Requests)'
// Declared early for PerfController helpers

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INPUT_SHOW_FIB_TIME     = input.bool(true, 'Fib Time Zones', inline='TZ', group=GROUP_PICK)
INPUT_CUSTOM_THRESHOLD  = input.bool(true, 'Custom thresholds', inline='C')
INPUT_CUSTOM_DEPTH      = input.bool(true, 'Custom depths', inline='C')

// Pivot Settings
INPUT_HTF_MODE          = input.string('Auto', 'Pivot Points TimeFrame', options=['Auto', 'User Defined'], inline='HTF', group=GROUP_PIVOT, tooltip=TOOLTIP_PIVOT_POINT)
INPUT_HTF_USER_RAW      = input.string('15 Min', 'â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒor User Defined', options=['15 Min', '1 Hour', '4 Hour', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Yearly'], inline='HTF1', group=GROUP_PIVOT)

// Parse HTF input
REQ_htfUserParsed = INPUT_HTF_USER_RAW == '15 Min'? '15' : 
                  INPUT_HTF_USER_RAW == '1 Hour'? '60' : 
                  INPUT_HTF_USER_RAW == '4 Hour'? '240' : 
                  INPUT_HTF_USER_RAW == 'Daily'? 'D' : 
                  INPUT_HTF_USER_RAW == 'Weekly'? 'W' : 
                  INPUT_HTF_USER_RAW == 'Monthly'? 'M' : 
                  INPUT_HTF_USER_RAW == 'Quarterly'? '3M' : '12M'

INPUT_LEVELS_PVT        = input.string('Prices', 'Level Labels', options=['Levels', 'Prices', 'Levels + Prices', 'None'], inline='pvt', group=GROUP_PIVOT)
INPUT_LEVELS_PVT_POS    = input.string('Pivot End', '', options=['Last Bar', 'Pivot End'], inline='pvt', group=GROUP_PIVOT)
INPUT_LEVELS_PVT_SIZE   = input.string('Small', '', options=['Small', 'Normal'], inline='pvt', group=GROUP_PIVOT)
INPUT_EXTEND_PVT        = input.bool(false, 'Extend Pivot Point Lines', inline='fLines', group=GROUP_PIVOT)

dev_treshold(float dev_treshold) => ta.atr(2) / close * 100 * dev_treshold
// Deviation Thresholds (map-based for O(1) lookup)
var map<string, float> STATE_tfDevThresholds = map.new<string, float>()
STATE_tfDevThresholds.put("DEFAULT", dev_treshold(input.float(2.0, 'Deviation (default)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC, tooltip=TOOLTIP_THRESHOLD)))
STATE_tfDevThresholds.put("1S", dev_treshold(input.float(2.0, 'Deviation (1S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
STATE_tfDevThresholds.put("5S", dev_treshold(input.float(2.0, 'Deviation (5S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
STATE_tfDevThresholds.put("10S", dev_treshold(input.float(2.0, 'Deviation (10S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
STATE_tfDevThresholds.put("15S", dev_treshold(input.float(2.0, 'Deviation (15S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
STATE_tfDevThresholds.put("30S", dev_treshold(input.float(2.0, 'Deviation (30S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
STATE_tfDevThresholds.put("45S", dev_treshold(input.float(2.0, 'Deviation (45S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
STATE_tfDevThresholds.put("1", dev_treshold(input.float(2.0, 'Deviation (1M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
STATE_tfDevThresholds.put("2", dev_treshold(input.float(2.0, 'Deviation (2M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
STATE_tfDevThresholds.put("3", dev_treshold(input.float(2.0, 'Deviation (3M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
STATE_tfDevThresholds.put("5", dev_treshold(input.float(2.0, 'Deviation (5M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
STATE_tfDevThresholds.put("10", dev_treshold(input.float(2.0, 'Deviation (10M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
STATE_tfDevThresholds.put("15", dev_treshold(input.float(2.0, 'Deviation (15M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
STATE_tfDevThresholds.put("30", dev_treshold(input.float(2.0, 'Deviation (30M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
STATE_tfDevThresholds.put("45", dev_treshold(input.float(2.0, 'Deviation (45M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
STATE_tfDevThresholds.put("60", dev_treshold(input.float(2.0, 'Deviation (1H)', minval=0, inline='Pivots', group=GROUP_THRESH_H)))
STATE_tfDevThresholds.put("120", dev_treshold(input.float(2.0, 'Deviation (2H)', minval=0, inline='Pivots', group=GROUP_THRESH_H)))
STATE_tfDevThresholds.put("180", dev_treshold(input.float(2.0, 'Deviation (3H)', minval=0, inline='Pivots', group=GROUP_THRESH_H)))
STATE_tfDevThresholds.put("240", dev_treshold(input.float(2.0, 'Deviation (4H)', minval=0, inline='Pivots', group=GROUP_THRESH_H)))
STATE_tfDevThresholds.put("1D", dev_treshold(input.float(2.0, 'Deviation (1D)', minval=0, inline='Pivots', group=GROUP_THRESH_D)))
STATE_tfDevThresholds.put("7D", dev_treshold(input.float(2.0, 'Deviation (7D)', minval=0, inline='Pivots', group=GROUP_THRESH_D)))
STATE_tfDevThresholds.put("4W", dev_treshold(input.float(2.0, 'Deviation (4W)', minval=0, inline='Pivots', group=GROUP_THRESH_W)))
STATE_tfDevThresholds.put("3M", dev_treshold(input.float(2.0, 'Deviation (3Mo)', minval=0, inline='Pivots', group=GROUP_THRESH_M)))
STATE_tfDevThresholds.put("6M", dev_treshold(input.float(2.0, 'Deviation (6Mo)', minval=0, inline='Pivots', group=GROUP_THRESH_M)))
STATE_tfDevThresholds.put("12M", dev_treshold(input.float(2.0, 'Deviation (12Mo)', minval=0, inline='Pivots', group=GROUP_THRESH_M)))

// Depths (map-based for O(1) lookup)
var map<string, int> STATE_tfDepths = map.new<string, int>()
STATE_tfDepths.put("DEFAULT", input.int(10, 'Depth (default)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
STATE_tfDepths.put("1S", input.int(10, 'Depth (1S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
STATE_tfDepths.put("5S", input.int(10, 'Depth (5S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
STATE_tfDepths.put("10S", input.int(10, 'Depth (10S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
STATE_tfDepths.put("15S", input.int(10, 'Depth (15S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
STATE_tfDepths.put("30S", input.int(10, 'Depth (30S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
STATE_tfDepths.put("45S", input.int(10, 'Depth (45S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
STATE_tfDepths.put("1", input.int(10, 'Depth (1M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
STATE_tfDepths.put("2", input.int(10, 'Depth (2M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
STATE_tfDepths.put("3", input.int(10, 'Depth (3M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
STATE_tfDepths.put("5", input.int(10, 'Depth (5M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
STATE_tfDepths.put("10", input.int(10, 'Depth (10M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
STATE_tfDepths.put("15", input.int(10, 'Depth (15M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
STATE_tfDepths.put("30", input.int(10, 'Depth (30M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
STATE_tfDepths.put("45", input.int(10, 'Depth (45M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
STATE_tfDepths.put("60", input.int(10, 'Depth (1H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H))
STATE_tfDepths.put("120", input.int(10, 'Depth (2H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H))
STATE_tfDepths.put("180", input.int(10, 'Depth (3H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H))
STATE_tfDepths.put("240", input.int(10, 'Depth (4H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H))
STATE_tfDepths.put("1D", input.int(10, 'Depth (1D)', minval=1, inline='Pivots', group=GROUP_DEPTH_D))
STATE_tfDepths.put("7D", input.int(10, 'Depth (7D)', minval=1, inline='Pivots', group=GROUP_DEPTH_D))
STATE_tfDepths.put("4W", input.int(10, 'Depth (4W)', minval=1, inline='Pivots', group=GROUP_DEPTH_W))
STATE_tfDepths.put("3M", input.int(10, 'Depth (3Mo)', minval=1, inline='Pivots', group=GROUP_DEPTH_M))
STATE_tfDepths.put("6M", input.int(10, 'Depth (6Mo)', minval=1, inline='Pivots', group=GROUP_DEPTH_M))
STATE_tfDepths.put("12M", input.int(10, 'Depth (12Mo)', minval=1, inline='Pivots', group=GROUP_DEPTH_M))

// Fibonacci Tools
INPUT_LEVELS_LABEL      = input.string('Prices', 'Level Labels', options=['Levels', 'Prices', 'Levels + Prices', 'None'], inline='fLines', group=GROUP_FIB_TOOL)
INPUT_LEVELS_POS        = input.string('Pivot Start', '', options=['Last Bar', 'Pivot Start'], inline='fLines', group=GROUP_FIB_TOOL)
INPUT_LEVELS_SIZE       = input.string('Small', '', options=['Small', 'Normal'], inline='fLines', group=GROUP_FIB_TOOL)
INPUT_REVERSE           = input.bool(false, 'Reverse Extention / Retracement Levels', group=GROUP_FIB_TOOL)
INPUT_EXTEND_ER         = input.bool(false, 'Extend Extention / Retracement Lines', inline='fLine', group=GROUP_FIB_TOOL)
INPUT_HIST_PIVOT        = input.int (0, 'Historical Extention / Retracement Levels', minval=0, group=GROUP_FIB_TOOL)
INPUT_HIST_PIVOT_2      = input.int(0, 'Historical Time Zones', minval=0, group=GROUP_FIB_TOOL)
INPUT_FIB_TZ_LABEL      = input.bool(false, 'Time Zone Lables', inline='tz poz', group=GROUP_FIB_TOOL)
INPUT_FIB_TZ_POS_X      = input.string('Left', '', options=['Right', 'Left'], inline='tz poz', group=GROUP_FIB_TOOL)
UI_fibTzLabelPos                = INPUT_FIB_TZ_POS_X == 'Left' ? label.style_label_left : label.style_label_right
INPUT_FIB_TZ_POS_Y      = input.string('Bottom', '', options=['Bottom', 'Top'], inline='tz poz', group=GROUP_FIB_TOOL)

// --- STATISTICAL POSITION ENGINE INPUTS ---
INPUT_SHOW_POS          = input.bool(true, 'Show Stat Position Preview', group=GROUP_STAT_POS, tooltip=TOOLTIP_STAT_POS)
INPUT_POS_SL_MULT       = input.float(1.5, 'Stop Loss Variance (ATR Mult)', minval=0.1, step=0.1, group=GROUP_STAT_POS, tooltip="Buffer added to the Structural Invalidation Point (Pivot Start) to prevent Stop Hunts.")
INPUT_POS_SL_DYNAMIC    = input.bool(true, 'Dynamic SL (Volatility-Adjusted)', group=GROUP_STAT_POS, tooltip="Automatically widens SL during high-volatility regimes and tightens during low-volatility.\nUses ATR percentile ranking over 100 bars to scale the SL multiplier Â±50%.")
INPUT_POS_RSI_DIV       = input.bool(true, 'RSI Divergence Filter', group=GROUP_STAT_POS, tooltip="Adds momentum confluence by detecting RSI divergence at the Golden Pocket.\nBullish div: price lower but RSI higher (for longs).\nBearish div: price higher but RSI lower (for shorts).\nBoosts confidence when divergence confirms the setup.")
INPUT_POS_RSI_LEN       = input.int(14, 'RSI Length', minval=2, maxval=50, group=GROUP_STAT_POS, tooltip="Period for RSI calculation. Default 14 is standard.")
INPUT_POS_TIME_DECAY    = input.bool(true, 'Fib Time Decay', group=GROUP_STAT_POS, tooltip="Applies time-based decay to zone validity using Fibonacci sequence thresholds (8, 13, 21, 34, 55, 89 bars).\nZone fades 15% at each Fib threshold, reducing win probability and visual opacity.\nCrypto moves fastâ€”stale setups lose edge.")
INPUT_POS_TP_MODE       = input.string('Conservative', 'Take Profit Mode', options=['Conservative', 'Aggressive'], group=GROUP_STAT_POS, tooltip="Conservative: Targets Pivot End (0.0).\nAggressive: Targets 1.272 Extension.")
INPUT_POS_WIN_RATE      = input.float(61.8, 'Assumed Win Rate %', minval=1.0, maxval=99.0, step=1.0, group=GROUP_STAT_POS, tooltip="Estimated win probability for Kelly Criterion sizing.\nDefault 61.8% aligns with Golden Ratio confluence.\nAdjust based on your backtested strategy performance.")
INPUT_POS_KELLY_FRAC    = input.float(0.5, 'Kelly Fraction', minval=0.1, maxval=1.0, step=0.1, group=GROUP_STAT_POS, tooltip="Fraction of Kelly to use (Half-Kelly = 0.5 is standard for reduced variance).\n1.0 = Full Kelly (aggressive), 0.25 = Quarter Kelly (conservative).")
// --- LEARNING ENGINE INPUTS ---
INPUT_LEARNING_ENABLED  = input.bool(true, 'ğŸ“Š Adaptive Learning', group=GROUP_STAT_POS, tooltip="Enables backtesting-based learning.\nTracks setup outcomes over historical bars to:\nâ€¢ Adapt zone buffer based on near-misses\nâ€¢ Calculate empirical win rate\nâ€¢ Optimize parameters automatically.")
INPUT_LEARNING_SAMPLES  = input.int(50, 'Learning Sample Size', minval=10, maxval=500, group=GROUP_STAT_POS, tooltip="Number of past setups to analyze for learning.\nMore samples = more stable estimates but slower adaptation.")
INPUT_ZONE_BUFFER_BASE  = input.float(0.0, 'Zone Buffer % (Base)', minval=0.0, maxval=100.0, step=0.05, group=GROUP_STAT_POS, tooltip="Manual buffer added to Golden Pocket boundaries.\nLearning engine may increase this if near-misses detected.")
INPUT_NEAR_MISS_THRESH  = input.float(0.5, 'Near-Miss Threshold %', minval=0.1, maxval=100.0, step=0.1, group=GROUP_STAT_POS, tooltip="Distance threshold for detecting near-misses.\nIf price comes within this % of zone but doesn't enter, it's a near-miss.")
INPUT_USE_LEARNED_SL    = input.bool(true, 'ğŸ§  Use Learned SL', group=GROUP_STAT_POS, tooltip="When enabled, uses the learned optimal SL multiplier from MAE analysis.\nRequires 20+ samples with 5+ winning trades.\nThe learned SL is based on: avg MAE of winners + 0.5 ATR buffer.")
// â”€â”€ ADVANCED LEARNING CONTROLS
INPUT_LEARN_TP          = input.bool(true, 'ğŸ§  Learn Optimal TP Mode', group=GROUP_STAT_POS, tooltip="Learns whether Conservative or Aggressive TP mode has better expected value.\nCompares hit rates and R:R of each mode from historical data.")
INPUT_LEARN_DECAY       = input.bool(true, 'ğŸ§  Learn Time Decay Rate', group=GROUP_STAT_POS, tooltip="Learns optimal time decay rate from bars_to_outcome distribution.\nIf most wins happen early, accelerates decay. If wins persist, slows decay.")
INPUT_LEARN_RSI_WEIGHT  = input.bool(true, 'ğŸ§  Learn RSI Weight', group=GROUP_STAT_POS, tooltip="Learns how much to weight RSI divergence in Kelly calculation.\nBased on the edge gained from divergence-confirmed vs non-confirmed setups.")
INPUT_LEARN_MIN_SAMPLES = input.int(30, 'Min Samples for Learning', minval=10, maxval=100, group=GROUP_STAT_POS, tooltip="Minimum number of samples required before applying learned parameters.\nHigher = more stable but slower adaptation.")
// --- PROJECTION MODE ---
INPUT_PROJECTION_MODE   = input.bool(true, 'âš¡ Projection Mode (Early Pivot)', group=GROUP_STAT_POS, tooltip="Shows tentative Golden Pocket in real-time when price retraces by deviation threshold from local high/low.\nDoes not wait for full depth confirmation.\nAllows earlier entry signals but may repaint.")
INPUT_PROJ_SENSITIVITY  = input.float(0.5, '   â†³ Sensitivity', minval=0.1, maxval=1.0, step=0.1, group=GROUP_STAT_POS, tooltip="Scalar for deviation threshold. < 1.0 reduces lag for tentative setups but increases false positive rate.\n0.5 = 50% of normal threshold (faster signals).\n1.0 = same as confirmed ZigZag (no early warning).")
// --- INTRABAR PRECISION (Backtest Engine) ---
INPUT_INTRABAR_ENABLED  = input.bool(true, 'ğŸ”¬ Intrabar Precision', group=GROUP_STAT_POS, tooltip="Uses lower timeframe data to resolve TP/SL order when both are hit in the same HTF bar.\nEliminates look-ahead bias and improves backtest accuracy.\nRequires dynamic_requests=true in indicator declaration.")
INPUT_INTRABAR_TF       = input.string('5', '   â†³ LTF Resolution', options=['1', '5', '15'], group=GROUP_STAT_POS, tooltip="Lower timeframe for intrabar inspection.\n1 = 1 minute (most precise, higher overhead)\n5 = 5 minutes (balanced, recommended)\n15 = 15 minutes (fastest, less precise)")
INPUT_INTRABAR_TIEBREAK = input.string('Conservative', '   â†³ Tie-Break Policy', options=['Conservative', 'Optimistic'], group=GROUP_STAT_POS, tooltip="When TP and SL are hit in the same LTF bar:\nConservative: Assume SL hit first (capital preservation)\nOptimistic: Assume TP hit first (best case)")
// --- SHANNON ENTROPY FILTER ---
INPUT_ENTROPY_ENABLED   = input.bool(true, 'ğŸ² Entropy Regime Filter', group=GROUP_STAT_POS, tooltip="Filters trades based on Shannon Entropy of recent price action.\nBlocks signals during high-entropy (choppy/random) regimes.\nAllows signals during low-entropy (structured/trending) regimes.")
INPUT_ENTROPY_MODE      = input.string(ENTROPY_MODE_LEGACY, '   â†³ Entropy Mode', options=[ENTROPY_MODE_LEGACY, ENTROPY_MODE_BINARY, ENTROPY_MODE_KGRAM], group=GROUP_STAT_POS, tooltip="LEGACY_BINS: Original binned log-return entropy (default).\nBINARY_UPDOWN: Optimized binary up/down symbolic entropy (O(1)).\nBINARY_KGRAM: K-gram pattern entropy for multi-bar patterns (O(1)).")
INPUT_ENTROPY_WINDOW    = input.int(20, '   â†³ Window Length', minval=5, maxval=100, group=GROUP_STAT_POS, tooltip="Number of bars for entropy calculation.\nLarger = more stable but slower to adapt.\n20 is recommended for most timeframes.")
INPUT_ENTROPY_BINS      = input.int(5, '   â†³ Bin Count', minval=3, maxval=10, group=GROUP_STAT_POS, tooltip="Number of bins for discretizing returns.\n5 bins = [Large Down, Small Down, Neutral, Small Up, Large Up]\nMore bins = finer resolution but needs more data.\n(Only used in LEGACY_BINS mode)")
INPUT_ENTROPY_K         = input.int(3, '   â†³ K-Gram Length', minval=1, maxval=8, group=GROUP_STAT_POS, tooltip="Pattern length for BINARY_KGRAM mode.\nk=1: 2 states (up/down)\nk=3: 8 states (default)\nk=8: 256 states (max)")
INPUT_ENTROPY_THRESH    = input.float(0.7, '   â†³ Threshold', minval=0.1, maxval=1.0, step=0.05, group=GROUP_STAT_POS, tooltip="Normalized entropy threshold (0-1).\nBelow = ORDERED (allow trades)\nAbove = DISORDERED (block trades)\n0.7 is a balanced default.")
INPUT_ENTROPY_TRANSITION = input.bool(false, '   â†³ Allow Transitions', group=GROUP_STAT_POS, tooltip="When enabled, allows trades during highâ†’low entropy transitions.\nDetects breakouts from consolidation (chopâ†’trend).\nExperimental: may increase false positives.")
INPUT_ENTROPY_DEBUG     = input.bool(false, '   â†³ Debug Overlay', group=GROUP_STAT_POS, tooltip="Shows entropy debug info on last bar:\nMode, states, window, H_norm, regime, buffer size.\nNo per-bar labels (performance safe).")
// --- HURST EXPONENT FILTER ---
INPUT_HURST_ENABLED     = input.bool(true, 'ğŸ“ˆ Hurst Regime Filter', group=GROUP_STAT_POS, tooltip="Filters trades based on Hurst Exponent (market persistence).\nH > 0.5 = trending (persistent), H < 0.5 = mean-reverting.\nOptionally blocks trades near H â‰ˆ 0.5 (random walk).")
INPUT_HURST_MODE        = input.string(STATIC_HURST_MODE_LEGACY, '   â†³ Hurst Mode', options=[STATIC_HURST_MODE_LEGACY, STATIC_HURST_MODE_DYADIC_STABLE, STATIC_HURST_MODE_DYADIC_FAST], group=GROUP_STAT_POS, tooltip="Calculation mode:\nâ€¢ Legacy (Geometric): Original multi-scale R/S\nâ€¢ Dyadic Stable: O(log N) with chunk averaging\nâ€¢ Dyadic Fast: O(log N), single recent chunk\nLegacy is default for backward compatibility.")
INPUT_HURST_WINDOW      = input.int(100, '   â†³ Window Length', minval=20, maxval=500, group=GROUP_STAT_POS, tooltip="Number of bars for Hurst calculation.\nLarger = more stable but slower to adapt.\n100 is recommended for most timeframes.")
INPUT_HURST_TREND       = input.float(0.55, '   â†³ Trend Threshold', minval=0.50, maxval=0.80, step=0.01, group=GROUP_STAT_POS, tooltip="H above this = TRENDING regime.\nPersistent price movement, favor breakouts.\n0.55 is a conservative default.")
INPUT_HURST_MEANREV     = input.float(0.45, '   â†³ Mean-Revert Threshold', minval=0.20, maxval=0.50, step=0.01, group=GROUP_STAT_POS, tooltip="H below this = MEAN-REVERTING regime.\nAnti-persistent movement, favor fades.\n0.45 is a conservative default.")
INPUT_HURST_BLOCK_RANDOM = input.bool(false, '   â†³ Block Random Regime', group=GROUP_STAT_POS, tooltip="When enabled, blocks trades when H is near 0.5 (random walk).\nReduces exposure during unpredictable conditions.\nExperimental: may reduce trade frequency significantly.")
INPUT_HURST_DEBUG       = input.bool(false, '   â†³ Debug Overlay', group=GROUP_STAT_POS, tooltip="Shows Hurst debug info on last bar:\nMode, scales, window, H value, regime.\nNo per-bar labels (performance safe).")
// --- Z-SCORE MOMENTUM FILTER ---
INPUT_ZSCORE_ENABLED    = input.bool(true, 'âš¡ Momentum Z-Score Filter', group=GROUP_STAT_POS, tooltip="Filters trades based on displacement velocity.\nRequires statistically significant momentum (Z > threshold).\nBlocks slow drift fakeouts.")
INPUT_ZSCORE_LR_LEN     = input.int(14, '   â†³ Regression Length', minval=5, maxval=50, group=GROUP_STAT_POS, tooltip="Lookback for linear regression slope.\n14 bars is a balanced default.\nShorter = more sensitive, longer = smoother.")
INPUT_ZSCORE_ATR_LEN    = input.int(14, '   â†³ ATR Length', minval=5, maxval=50, group=GROUP_STAT_POS, tooltip="ATR period for volatility normalization.\nMakes momentum comparable across assets.\n14 is standard.")
INPUT_ZSCORE_Z_LEN      = input.int(50, '   â†³ Z-Score Window', minval=20, maxval=200, group=GROUP_STAT_POS, tooltip="Rolling window for mean/stdev of normalized slope.\nLarger = more stable Z-score.\n50 is recommended.")
INPUT_ZSCORE_THRESH     = input.float(2.0, '   â†³ Z Threshold', minval=1.0, maxval=4.0, step=0.1, group=GROUP_STAT_POS, tooltip="Z-score threshold for significant momentum.\n2.0 = ~95% confidence (2 sigma).\nHigher = stricter filtering.")
// --- BAYESIAN WIN-RATE & SORTINO ---
INPUT_BAYES_ENABLED     = input.bool(true, 'ğŸ“Š Bayesian Win-Rate', group=GROUP_STAT_POS, tooltip="Replaces naive win rate with Bayesian Beta-Binomial model.\nAutomatically penalizes small sample sizes.\nOutputs conservative lower credible bound.")
INPUT_STATIC_BAYES_ALPHA_PRIOR = input.float(1.0, '   â†³ Prior Î± (Pseudo-Wins)', minval=0.1, maxval=10.0, step=0.1, group=GROUP_STAT_POS, tooltip="Prior pseudo-wins for Beta distribution.\n1.0 = uninformative Bayes-Laplace prior.\nHigher = more conservative (shrinks toward 0.5).")
INPUT_STATIC_BAYES_BETA_PRIOR  = input.float(1.0, '   â†³ Prior Î² (Pseudo-Losses)', minval=0.1, maxval=10.0, step=0.1, group=GROUP_STAT_POS, tooltip="Prior pseudo-losses for Beta distribution.\n1.0 = uninformative Bayes-Laplace prior.\nHigher = more conservative (shrinks toward 0.5).")
INPUT_BAYES_CONFIDENCE  = input.float(0.95, '   â†³ Confidence Level', minval=0.80, maxval=0.99, step=0.01, group=GROUP_STAT_POS, tooltip="Confidence level for credible interval.\n0.95 = 95% confidence (5th percentile lower bound).\nHigher = more conservative estimate.")
INPUT_SORTINO_ENABLED   = input.bool(true, 'ğŸ“‰ Sortino Ratio', group=GROUP_STAT_POS, tooltip="Downside-risk adjusted performance metric.\nPenalizes losses/drawdowns without penalizing upside volatility.\nAligns with asymmetric payoff goals.")
INPUT_STATIC_SORTINO_MAR       = input.float(0.0, '   â†³ Min Acceptable Return', minval=-0.10, maxval=0.10, step=0.01, group=GROUP_STAT_POS, tooltip="Minimum Acceptable Return (MAR) threshold.\nReturns below this are considered 'downside'.\n0.0 = break-even target.")
// --- MONTE CARLO PERMUTATION TEST ---
INPUT_MC_ENABLED        = input.bool(true, 'ğŸ² Monte Carlo Validation', group=GROUP_STAT_POS, tooltip="Permutation test to validate timing edge.\nShuffles trade sequence to test if drawdown control is real.\nRejects strategies that look good by chance.")
INPUT_MC_SIMS           = input.int(100, '   â†³ Simulations', minval=20, maxval=500, group=GROUP_STAT_POS, tooltip="Number of permutation simulations.\nMore = more accurate p-value, but slower.\n100 is a good balance.")
INPUT_MC_PVALUE         = input.float(0.05, '   â†³ p-value Threshold', minval=0.01, maxval=0.20, step=0.01, group=GROUP_STAT_POS, tooltip="Significance threshold.\np < 0.05 = 95% confidence timing edge is real.\nLower = stricter filter.")
// --- EXTERNAL CONTEXT (DYNAMIC REQUESTS) ---
INPUT_EXT_ENABLED       = input.bool(false, 'ğŸŒ External Context', group=GROUP_EXT_CTX, tooltip="Enables dynamic data requests for external symbol context.\nUsed to improve confidence signals using another symbol (index/VIX/etc).\nOFF by default - no requests when disabled.")
INPUT_EXT_TF_MODE       = input.string(EXT_TF_CURRENT, '   â†³ Timeframe Mode', options=[EXT_TF_CURRENT, EXT_TF_CUSTOM], group=GROUP_EXT_CTX, tooltip="CURRENT: Uses chart timeframe.\nCUSTOM: Uses user-defined timeframe.")
INPUT_EXT_TF_CUSTOM     = input.string('60', '   â†³ Custom Timeframe', group=GROUP_EXT_CTX, tooltip="Timeframe string when using CUSTOM mode.\nExamples: 1, 5, 15, 60, 240, D, W, M")
INPUT_EXT_SYMBOLS       = input.string('', '   â†³ Symbols (CSV)', group=GROUP_EXT_CTX, tooltip="Comma-separated ticker list.\nExample: CBOE:VIX, SP:SPX, BINANCE:BTCUSDT\nEmpty = no external requests.")
INPUT_EXT_MAX_SYMBOLS   = input.int(EXT_DEFAULT_SYMBOLS, '   â†³ Max Symbols', minval=1, maxval=EXT_MAX_SYMBOLS_CAP, group=GROUP_EXT_CTX, tooltip="Maximum symbols to request.\nHigher values consume more of the 40-request budget.\nDefault 5 is conservative.")
INPUT_EXT_FIELDS        = input.string(EXT_FIELDS_CLOSE, '   â†³ Fields', options=[EXT_FIELDS_CLOSE, EXT_FIELDS_OHLCV], group=GROUP_EXT_CTX, tooltip="CLOSE_ONLY: Requests only close price.\nOHLCV: Requests open/high/low/close/volume tuple.")
INPUT_EXT_GATE_MODE     = input.string(EXT_GATE_ALWAYS, '   â†³ Gating Mode', options=[EXT_GATE_ALWAYS, EXT_GATE_ENTROPY, EXT_GATE_HURST, EXT_GATE_CUSTOM], group=GROUP_EXT_CTX, tooltip="Controls when external requests execute:\nALWAYS: Every bar when enabled.\nON_ENTROPY_DISORDER: Only during disordered entropy regime.\nON_LOW_HURST: Only when Hurst < mean-revert threshold.\nCUSTOM: Placeholder for custom logic.")
INPUT_EXT_DEBUG         = input.bool(false, '   â†³ Debug Overlay', group=GROUP_EXT_CTX, tooltip="Shows debug info on last bar:\nGating state, used contexts, fetched values.\nNo per-bar labels (performance safe).")
// --- DEBUG EXECUTION FLOW (Internal) ---
INPUT_DEBUG_FLOW        = input.bool(false, 'ğŸ” Debug Execution Flow', group=GROUP_EXT_CTX, tooltip="Shows execution flow diagnostics on last bar:\nGuard pass counts, heavy function executions.\nNo per-bar labels (performance safe).")
// Declared early for PerfController helpers

// Fibonacci Levels
INPUT_SHOW_0            = input.bool(true, '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_VAL_0             = input.float(0., '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_COL_0             = input.color(color.new(COLOR_GRAY, STATIC_TRANS_MAIN), '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_236        = input.bool(true, '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_236         = input.float(0.236, '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_COL_0_236         = input.color(color.new(COLOR_RED, STATIC_TRANS_MAIN), '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_382        = input.bool(true, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_382         = input.float(0.382, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_COL_0_382         = input.color(color.new(COLOR_LIGHT_GREEN, STATIC_TRANS_MAIN), '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_5          = input.bool(true, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_5           = input.float(0.5, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_COL_0_5           = input.color(color.new(COLOR_GREEN, STATIC_TRANS_MAIN), '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_618        = input.bool(true, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_618         = input.float(0.618, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_COL_0_618         = input.color(color.new(COLOR_TEAL, STATIC_TRANS_MAIN), '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_65         = input.bool(true, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_65          = input.float(0.65, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_COL_0_65          = input.color(color.new(COLOR_TEAL, STATIC_TRANS_SUPP), '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_786        = input.bool(true, '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_786         = input.float(0.786, '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_COL_0_786         = input.color(color.new(COLOR_LIGHT_BLUE, STATIC_TRANS_MAIN), '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1            = input.bool(true, '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_VAL_1             = input.float(1., '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_COL_1             = input.color(color.new(#787b86, 15), '', inline='Level3', group=GROUP_FIB_LEVELS) 
INPUT_SHOW_1_272        = input.bool(true, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_272         = input.float(1.272, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_COL_1_272         = input.color(color.new(COLOR_LIGHT_GREEN, STATIC_TRANS_MAIN), '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1_414        = input.bool(false, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_414         = input.float(1.414, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_COL_1_414         = input.color(color.new(COLOR_RED, STATIC_TRANS_SUPP), '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1_618        = input.bool(true, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_618         = input.float(1.618, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_COL_1_618         = input.color(color.new(COLOR_BLUE, STATIC_TRANS_MAIN), '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1_65         = input.bool(false, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_65          = input.float(1.65, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_COL_1_65          = input.color(color.new(COLOR_BLUE, STATIC_TRANS_SUPP), '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_SHOW_2_618        = input.bool(false, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_VAL_2_618         = input.float(2.618, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_COL_2_618         = input.color(color.new(COLOR_RED, STATIC_TRANS_SUPP), '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_SHOW_2_65         = input.bool(true, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_VAL_2_65          = input.float(2.65, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_COL_2_65          = input.color(color.new(COLOR_RED, STATIC_TRANS_SUPP), '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_SHOW_3_618        = input.bool(false, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_VAL_3_618         = input.float(3.618, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_COL_3_618         = input.color(color.new(COLOR_PURPLE, STATIC_TRANS_SUPP), '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_SHOW_3_65         = input.bool(true, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_VAL_3_65          = input.float(3.65, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_COL_3_65          = input.color(color.new(COLOR_PURPLE, STATIC_TRANS_SUPP), '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_SHOW_4_236        = input.bool(true, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_VAL_4_236         = input.float(4.236, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_COL_4_236         = input.color(color.new(COLOR_PINK, STATIC_TRANS_SUPP), '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_SHOW_4_618        = input.bool(true, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_VAL_4_618         = input.float(4.669, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_COL_4_618         = input.color(color.new(COLOR_LIGHT_GREEN, STATIC_TRANS_SUPP) , '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_236    = input.bool(true, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_236     = input.float(-0.236, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_236     = input.color(color.new(COLOR_RED, STATIC_TRANS_SUPP), '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_382    = input.bool(true, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_382     = input.float(-0.382, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_382     = input.color(color.new(COLOR_LIGHT_GREEN, STATIC_TRANS_SUPP), '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_618    = input.bool(false, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_618     = input.float(-0.618, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_618     = input.color(color.new(COLOR_TEAL, STATIC_TRANS_SUPP), '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_65     = input.bool(true, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_65      = input.float(-0.65, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_65      = input.color(color.new(COLOR_TEAL, STATIC_TRANS_SUPP), '', inline='Level10', group=GROUP_FIB_LEVELS)

// ZigZag
INPUT_SHOW_ZIGZAG       = input.bool(true, 'Zig Zag', inline='ZZ', group=GROUP_ZIGZAG, tooltip=TOOLTIP_ZIGZAG)

// ZigZag rendering mode (PolylinePlus architecture)
string TOOLTIP_ZZ_RENDER = 'LINES: Classic per-segment line drawing (max 500 lines).\nPOLYLINE_BUFFER: Buffered polyline rendering (max 100 polylines, 10k points each).\nPolyline mode uses xloc.bar_time for stable deep-history rendering.'
string TOOLTIP_ZZ_POLY_MAX = 'Maximum polylines to keep before garbage collection. Oldest polylines are deleted when limit exceeded.'
string TOOLTIP_ZZ_POLY_POINTS = 'Maximum points per polyline before flushing to a new polyline. Use < 10000 for safety margin.'
string TOOLTIP_ZZ_LIVE_SEG = 'Keep a single live line for the current unconfirmed leg. Updates per bar until pivot confirmation.'

INPUT_ZZ_RENDER_MODE    = input.string('LINES', 'Render Mode', options=['LINES', 'POLYLINE_BUFFER'], group=GROUP_ZIGZAG, tooltip=TOOLTIP_ZZ_RENDER)
INPUT_ZZ_POLY_MAX_KEEP  = input.int(50, 'Max Polylines', minval=1, maxval=100, group=GROUP_ZIGZAG, tooltip=TOOLTIP_ZZ_POLY_MAX)
INPUT_ZZ_POLY_MAX_POINTS = input.int(9500, 'Max Points/Poly', minval=100, maxval=10000, group=GROUP_ZIGZAG, tooltip=TOOLTIP_ZZ_POLY_POINTS)
INPUT_ZZ_LIVE_SEGMENT   = input.bool(true, 'Live Segment Line', group=GROUP_ZIGZAG, tooltip=TOOLTIP_ZZ_LIVE_SEG)

// Alerts
INPUT_ALERT_ENABLED     = input.bool(false, 'Enable Alerts', group=GROUP_ALERTS)
INPUT_ALERT_MODE        = input.string('calculateAlertUpdates', 'Alert data collection mode', options=['calculateAlertData', 'calculateAlertUpdates'], group = GROUP_ALERTS)
INPUT_ALERT_SEPARATOR   = input.string('|', 'Alert data separator', group = GROUP_ALERTS)

// Volatility & Volume AddOns
INPUT_SHOW_HIGH_ATR     = input.bool(false, 'âš¡', inline='ATR', group=GROUP_VOL_VOL, tooltip=TOOLTIP_HIGH_VOL)
INPUT_ATR_LENGTH        = input.int(7, 'ATR : Length', inline='ATR', group=GROUP_VOL_VOL)
INPUT_ATR_MULT          = input.float(2.0, 'Mult', minval=.1, step=.1, inline='ATR', group=GROUP_VOL_VOL)
INPUT_VOL_SMA_LEN       = input.int(89, 'Volume Moving Average Length', group=GROUP_VOL_VOL)
INPUT_SHOW_VOL_SPIKE    = input.bool(false, 'ğŸš¦', inline='SRS1', group=GROUP_VOL_VOL, tooltip=TOOLTIP_VOL_EXHAUST)
INPUT_VOL_SPIKE_THRESH  = input.float(2.5, 'Volume Spike Thesholdâ€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡', minval=.1, step=.1, inline='SRS1', group=GROUP_VOL_VOL)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULATIONS & LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Data Structures - Level Log Maps (wrapped in LevelLog UDT after type definition)
var map<float, float> GLOBAL_pivotLevelsLogRetracementsMap = map.new<float, float>()
var map<float, float> GLOBAL_pivotLevelsLogCrossedMap = map.new<float, float>()

//              Used for generating alert data.
type LevelLog
    map<float, float> data

method clear(LevelLog this) =>
    this.data.clear()
    this

method put(LevelLog this, float level, float value) =>
    this.data.put(level, value)
    this

method get(LevelLog this, float level) =>
    this.data.get(level)

// toJson method defined after BUF_fibLevels array

type PivotContext
    float pMid
    float pEnd
    bool reverse = false

method getLevel(PivotContext this, float ratio) =>
    float diff = math.abs(this.pMid - this.pEnd)
    float result = this.pEnd < this.pMid ? 
         (this.reverse ? this.pEnd : this.pMid) - (this.reverse ? -1 : 1) * diff * ratio : 
         (this.reverse ? this.pEnd : this.pMid) + (this.reverse ? -1 : 1) * diff * ratio
    result

type ZigZagEngine
    line ln = na
    int iLast = 0
    float pLast = 0.0
    int tLast = 0
    bool isHighLast = false
    int iPrev = 0
    int tPrev = 0
    int iPrevPivot = 0
    float pPrevPivot = 0.0
    int tPrevPivot = 0
    int iLastPivot = 0
    float pLastPivot = 0.0
    int tLastPivot = 0
    bool changed = false

method resetChanged(ZigZagEngine this) =>
    this.changed := false
    this

method wasChanged(ZigZagEngine this) =>
    this.changed

f_calcDev(float base_price, float price) =>
    100 * (price - base_price) / price

method processPivot(ZigZagEngine this, float dev, bool isHigh, int index, int tPivot, float price, float dev_threshold, color zz_color, bool show_zigzag, bool usePolylineMode = false) =>
    bool newSegment = false
    
    if this.isHighLast == isHigh
        // Same direction - check if we should extend the existing line
        if this.isHighLast ? price > this.pLast : price < this.pLast
            if not na(this.ln) and not usePolylineMode
                line.set_xy2(this.ln, index, price)
            // Update tracking vars
            this.iPrev := this.iLast
            this.iLast := index
            this.pLast := price
            this.tPrev := this.tLast
            this.tLast := tPivot
    else
        // Different direction or no existing line
        bool isFirstSegment = na(this.ln) and this.pLast != 0 and this.iPrevPivot == 0
        if isFirstSegment
            // First segment ever - set tracking vars for polyline buffer
            this.iPrevPivot := this.iLast
            this.pPrevPivot := this.pLast
            this.tPrevPivot := this.tLast
            this.iLastPivot := index
            this.pLastPivot := price
            this.tLastPivot := tPivot
            
            if not usePolylineMode
                line newLine = line.new(this.iLast, this.pLast, index, price, color=zz_color, width=2, style=line.style_solid)
                this.ln := newLine
            this.isHighLast := isHigh
            this.iPrev := this.iLast
            this.iLast := index
            this.pLast := price
            this.tPrev := this.tLast
            this.tLast := tPivot
            newSegment := true
        else if math.abs(dev) > dev_threshold or (na(this.ln) and not usePolylineMode)
            // Deviation threshold met - create new line segment
            // Capture the previous segment's coordinates for caching
            if not na(this.ln)
                this.iPrevPivot := line.get_x1(this.ln)
                this.pPrevPivot := line.get_y1(this.ln)
                this.iLastPivot := line.get_x2(this.ln)
                this.pLastPivot := line.get_y2(this.ln)
                this.tPrevPivot := this.tPrev
                this.tLastPivot := this.tLast
            else
                // In polyline mode (no line object), the new segment goes from
                // current end (iLast,pLast,tLast) to new point (index,price,tPivot)
                this.iPrevPivot := this.iLast
                this.pPrevPivot := this.pLast
                this.tPrevPivot := this.tLast
                this.iLastPivot := index
                this.pLastPivot := price
                this.tLastPivot := tPivot
            
            // Delete old line if ZigZag display is disabled or polyline mode active
            if not show_zigzag or usePolylineMode
                if not na(this.ln)
                    line.delete(this.ln)
                    this.ln := na
            
            // Create new line (only in LINES mode)
            if not usePolylineMode
                line newLine = line.new(this.iLast, this.pLast, index, price, color=zz_color, width=2, style=line.style_solid)
                this.ln := newLine
            this.isHighLast := isHigh
            this.iPrev := this.iLast
            this.iLast := index
            this.pLast := price
            this.tPrev := this.tLast
            this.tLast := tPivot
            this.changed := true
            newSegment := true
    
    newSegment

method initFirst(ZigZagEngine this, int index, int tTime, float price, bool isHigh) =>
    this.iLast := index
    this.pLast := price
    this.tLast := tTime
    this.isHighLast := isHigh
    this

//              Supports active chunk re-rendering, manual garbage collection, and optional live segment line.
type ZigZagVisualBuffer
    array<chart.point> points = na
    array<polyline> sealed = na
    polyline active = na
    line liveLine = na
    int maxPolys = 50
    int maxPoints = 9500
    bool liveEnabled = true

method configure(ZigZagVisualBuffer this, int maxPolys, int maxPoints, bool liveEnabled) =>
    if na(this.points)
        this.points := array.new<chart.point>()
    if na(this.sealed)
        this.sealed := array.new<polyline>()
    this.maxPolys := maxPolys
    this.maxPoints := maxPoints
    this.liveEnabled := liveEnabled
    this

method clearAll(ZigZagVisualBuffer this) =>
    if not na(this.active)
        polyline.delete(this.active)
        this.active := na
    if not na(this.sealed)
        if array.size(this.sealed) > 0
            for i = 0 to array.size(this.sealed) - 1
                polyline.delete(array.get(this.sealed, i))
        array.clear(this.sealed)
    if not na(this.points)
        array.clear(this.points)
    if not na(this.liveLine)
        line.delete(this.liveLine)
        this.liveLine := na
    this

method gcPolys(ZigZagVisualBuffer this) =>
    if not na(this.sealed)
        while array.size(this.sealed) > this.maxPolys
            polyline doomed = array.shift(this.sealed)
            polyline.delete(doomed)
    this

method renderActive(ZigZagVisualBuffer this, color col) =>
    if array.size(this.points) >= 2
        array<chart.point> snapshot = array.copy(this.points)
        if not na(this.active)
            polyline.delete(this.active)
        this.active := polyline.new(snapshot, curved=false, closed=false, xloc=xloc.bar_time, line_color=col, line_style=line.style_solid, line_width=2)
    this

method flushIfFull(ZigZagVisualBuffer this) =>
    if array.size(this.points) >= this.maxPoints and not na(this.active)
        array.push(this.sealed, this.active)
        this.active := na
        this.gcPolys()
        chart.point lastPoint = array.get(this.points, array.size(this.points) - 1)
        array.clear(this.points)
        array.push(this.points, lastPoint)
    this

method addSegment(ZigZagVisualBuffer this, int tStart, float pStart, int tEnd, float pEnd, color col) =>
    // Skip if any coordinate is invalid
    if tStart == 0 or tEnd == 0 or na(pStart) or na(pEnd)
        this
    else
        chart.point ptStart = chart.point.from_time(tStart, pStart)
        chart.point ptEnd = chart.point.from_time(tEnd, pEnd)
        if array.size(this.points) == 0
            array.push(this.points, ptStart)
        else
            chart.point lastPt = array.get(this.points, array.size(this.points) - 1)
            if lastPt.time != ptStart.time or lastPt.price != ptStart.price
                array.push(this.points, ptStart)
        array.push(this.points, ptEnd)
        this.renderActive(col)
        this.flushIfFull()
        this

method updateLive(ZigZagVisualBuffer this, int tStart, float pStart, int tEnd, float pEnd, color col, bool show) =>
    bool canShow = show and this.liveEnabled and tStart != 0 and tEnd != 0
    if not canShow
        if not na(this.liveLine)
            line.delete(this.liveLine)
            this.liveLine := na
    else
        if na(this.liveLine)
            this.liveLine := line.new(tStart, pStart, tEnd, pEnd, xloc=xloc.bar_time, style=line.style_dotted, width=1, color=col)
        else
            line.set_xloc(this.liveLine, tStart, tEnd, xloc.bar_time)
            line.set_xy1(this.liveLine, tStart, pStart)
            line.set_xy2(this.liveLine, tEnd, pEnd)
            line.set_style(this.liveLine, line.style_dotted)
            line.set_color(this.liveLine, col)
            line.set_width(this.liveLine, 1)
    this

type RegimeState
    float logReturn = na
    float logReturnStdev = na
    float periodsPerYear = na
    float annualizedVol = na
    float entropy = na
    float entropyNorm = na
    int   entropyRegime = 2
    bool  entropyOk = true
    float hurst = na
    int   hurstRegime = 1
    bool  hurstOk = true
    float zscoreAtr = na
    float linregSlope = na
    float normSlope = na
    float zscore = na
    bool  strongMomentum = false
    bool  momentumOk = true
    float rawAtr = na
    float atrPercentile = na
    float rsi = na

//              Supports tuple-consolidated requests for up to MAX_SYMBOLS symbols.
//              Integrates with regime gating for conditional execution.
type ExternalContextState
    bool  enabled = false
    bool  gated = false
    bool  budgetExceeded = false
    int   usedContexts = 0
    array<string> symbols = na
    array<float>  closes = na
    array<float>  opens = na
    array<float>  highs = na
    array<float>  lows = na
    array<float>  volumes = na
    bool  extOk = true
    int   validCount = 0

method reset(ExternalContextState this) =>
    this.gated := false
    this.extOk := true
    this.validCount := 0
    if not na(this.closes)
        this.closes.clear()
    if not na(this.opens)
        this.opens.clear()
    if not na(this.highs)
        this.highs.clear()
    if not na(this.lows)
        this.lows.clear()
    if not na(this.volumes)
        this.volumes.clear()
    this

//              Updated only when new trade is recorded (needsRecalc flag).
//              Provides accessor methods for key metrics and health status.
type LearningMetrics
    // Core metrics
    float zoneBuffer = 0.0
    float winRate = 0.55
    float stopLossMultiplier = 1.5
    float averageMaxAdverseExcursion = 0.0
    float averageMaxFavorableExcursion = 0.0
    int   averageBarsHeld = 0
    // RSI divergence analytics
    float winRateWithDivergence = 0.55
    float winRateWithoutDivergence = 0.5
    float divergenceEdge = 0.0
    float rsiWeight = 0.0
    // Direction-specific win rates
    float winRateLong = 0.55
    float winRateShort = 0.55
    // Loss analysis
    float losingMaxAdverseExcursion = 0.0
    // Time-based
    int   optimalHoldBars = 0
    float decayRate = 0.03
    // TP mode comparison
    bool  useTakeProfitAggressive = false
    float conservativeWinRate = 0.0
    float aggressiveWinRate = 0.0
    float conservativeExpectedValue = 0.0
    float aggressiveExpectedValue = 0.0
    // Performance metrics
    float confidence = 50.0
    float profitFactor = 1.0
    float expectancy = 0.0
    int   winStreak = 0
    int   lossStreak = 0
    // Volatility regime
    float winRateHighVolatility = 0.55
    float winRateLowVolatility = 0.55
    // Entropy regime analytics
    float winRateOrdered = 0.55
    float winRateDisordered = 0.55
    float entropyEdge = 0.0
    // Hurst regime analytics
    float winRateTrend = 0.55
    float winRateMeanRevert = 0.55
    float winRateRandom = 0.55
    float hurstEdge = 0.0
    // Z-score momentum analytics
    float winRateStrongMomentum = 0.55
    float winRateWeakMomentum = 0.55
    float momentumEdge = 0.0
    // Log-return performance metrics
    float cumulativeLogReturn = 0.0
    float averageLogReturn = 0.0
    float logReturnStandardDeviation = 0.0
    float sharpeRatio = 0.0
    // Bayesian win-rate estimation (Beta-Binomial model)
    float bayesianAlpha = 1.0         // Posterior alpha (prior + wins)
    float bayesianBeta = 1.0          // Posterior beta (prior + losses)
    float bayesianMean = 0.5          // Posterior mean E[Î¸] = Î± / (Î± + Î²)
    float bayesianLowerBound = 0.0    // Conservative lower credible bound
    // Sortino ratio (downside-risk adjusted)
    float sortinoRatio = 0.0       // (Rp - Rf) / Ïƒ_down
    float downsideDeviation = 0.0        // Downside deviation (Ïƒ_down)
    float meanTradeReturn = 0.0    // Mean trade log return
    // Monte Carlo permutation test
    float monteCarloOriginalDrawdown = 0.0       // Original max drawdown
    float monteCarloMeanShuffledDrawdown = 0.0   // Mean of shuffled max drawdowns
    float monteCarloPValue = 1.0           // p-value (fraction of shuffles with lower DD)
    int   monteCarloSimulationsRun = 0            // Number of simulations completed
    bool  isMonteCarloSignificant = false    // True if timing edge is statistically significant
    // Health tracking
    int   lastOutcomeBar = 0
    bool  isHealthy = true
    // State tracking (consolidated from orphan var primitives)
    int   nearMissCount = 0
    int   totalSetups = 0
    bool  needsRecalculation = false

method getWinRate(LearningMetrics this, bool isLong) =>
    isLong ? this.winRateLong : this.winRateShort

method getRegimeWinRate(LearningMetrics this, bool isHighVol) =>
    isHighVol ? this.winRateHighVolatility : this.winRateLowVolatility

method getStopLossMultiplier(LearningMetrics this) =>
    this.stopLossMultiplier

method getDecayRate(LearningMetrics this) =>
    this.decayRate

method getConfidence(LearningMetrics this) =>
    this.confidence

method checkHealth(LearningMetrics this) =>
    this.isHealthy

method hasDivergenceEdge(LearningMetrics this) =>
    this.divergenceEdge > 0

//              Handles create/update/delete lifecycle and projection vs confirmed styling.
type PositionVisual
    box boxEntry = na
    line lineSl = na
    line lineSmartSl = na
    line lineTp = na
    label lblRisk = na

method deleteAll(PositionVisual this) =>
    if not na(this.boxEntry)
        box.delete(this.boxEntry)
        this.boxEntry := na
    if not na(this.lineSl)
        line.delete(this.lineSl)
        this.lineSl := na
    if not na(this.lineSmartSl)
        line.delete(this.lineSmartSl)
        this.lineSmartSl := na
    if not na(this.lineTp)
        line.delete(this.lineTp)
        this.lineTp := na
    if not na(this.lblRisk)
        label.delete(this.lblRisk)
        this.lblRisk := na
    this

method exists(PositionVisual this) =>
    not na(this.boxEntry)

method create(PositionVisual this, float zoneTop, float zoneBottom, float slPrice, float tpPrice, float labelPrice, string labelText, color bgCol, color borderCol, color slCol, color tpCol, string lineStyle, float smartSlPrice, color smartSlCol, color textCol) =>
    this.boxEntry := box.new(bar_index, zoneTop, bar_index + 5, zoneBottom, bgcolor=bgCol, border_color=borderCol, border_style=lineStyle == "solid" ? line.style_solid : line.style_dotted)
    this.lineSl := line.new(bar_index, slPrice, bar_index + 5, slPrice, color=slCol, style=lineStyle == "solid" ? line.style_solid : line.style_dotted, width=2)
    if not na(smartSlPrice)
        this.lineSmartSl := line.new(bar_index, smartSlPrice, bar_index + 5, smartSlPrice, color=smartSlCol, style=line.style_dotted, width=3)
    this.lineTp := line.new(bar_index, tpPrice, bar_index + 5, tpPrice, color=tpCol, style=lineStyle == "solid" ? line.style_solid : line.style_dotted, width=3)
    this.lblRisk := label.new(bar_index + 5, labelPrice, labelText, xloc.bar_index, yloc.price, color.new(textCol, 100), label.style_label_left, color.new(textCol, 0), size.small, text.align_left)
    this

method update(PositionVisual this, float zoneTop, float zoneBottom, float slPrice, float tpPrice, float labelPrice, string labelText, color bgCol, color borderCol, color slCol, color tpCol, float smartSlPrice, color smartSlCol) =>
    // Update box
    box.set_top(this.boxEntry, zoneTop)
    box.set_bottom(this.boxEntry, zoneBottom)
    box.set_right(this.boxEntry, bar_index + 5)
    box.set_bgcolor(this.boxEntry, bgCol)
    box.set_border_color(this.boxEntry, borderCol)
    // Update SL line
    line.set_x2(this.lineSl, bar_index + 5)
    line.set_y1(this.lineSl, slPrice)
    line.set_y2(this.lineSl, slPrice)
    line.set_color(this.lineSl, slCol)
    // Update Smart SL line (if available)
    if not na(smartSlPrice) and not na(this.lineSmartSl)
        line.set_x2(this.lineSmartSl, bar_index + 5)
        line.set_y1(this.lineSmartSl, smartSlPrice)
        line.set_y2(this.lineSmartSl, smartSlPrice)
    else if not na(smartSlPrice) and na(this.lineSmartSl)
        this.lineSmartSl := line.new(bar_index, smartSlPrice, bar_index + 5, smartSlPrice, color=smartSlCol, style=line.style_dotted, width=2)
    // Update TP line
    line.set_x2(this.lineTp, bar_index + 5)
    line.set_y1(this.lineTp, tpPrice)
    line.set_y2(this.lineTp, tpPrice)
    line.set_color(this.lineTp, tpCol)
    // Update label
    label.set_x(this.lblRisk, bar_index + 5)
    label.set_y(this.lblRisk, labelPrice)
    label.set_text(this.lblRisk, labelText)
    this

//              Provides methods for updating state and checking projection activity.
type ProjectionState
    float localHigh = na
    int localHighBar = na
    float localLow = na
    int localLowBar = na
    bool isHighLast = true
    int iMidPivot = na
    float pMidPivot = na
    int iEndBase = na
    float pEndBase = na
    bool active = false

method resetLocals(ProjectionState this, float currentHigh, float currentLow, bool wasHigh) =>
    this.localHigh := currentHigh
    this.localHighBar := bar_index
    this.localLow := currentLow
    this.localLowBar := bar_index
    this.isHighLast := wasHigh
    this

method updateLocals(ProjectionState this, float currentHigh, float currentLow) =>
    if currentHigh > nz(this.localHigh, currentHigh)
        this.localHigh := currentHigh
        this.localHighBar := bar_index
    if currentLow < nz(this.localLow, currentLow)
        this.localLow := currentLow
        this.localLowBar := bar_index
    this

method detectTentativeHigh(ProjectionState this, float closePrice, float threshold) =>
    float devFromHigh = this.localHigh > 0 ? 100 * (this.localHigh - closePrice) / this.localHigh : 0
    devFromHigh > threshold and not this.isHighLast

method detectTentativeLow(ProjectionState this, float closePrice, float threshold) =>
    float devFromLow = this.localLow > 0 ? 100 * (closePrice - this.localLow) / this.localLow : 0
    devFromLow > threshold and this.isHighLast

method activate(ProjectionState this, bool isHigh, float currentExtreme) =>
    this.iMidPivot := isHigh ? this.localHighBar : this.localLowBar
    this.pMidPivot := isHigh ? this.localHigh : this.localLow
    this.iEndBase := bar_index
    this.pEndBase := currentExtreme
    this.active := true
    this

method deactivate(ProjectionState this) =>
    this.active := false
    this

method isActive(ProjectionState this) =>
    this.active

// Global projection state instance
var ProjectionState GLOBAL_projection = ProjectionState.new()

type FibLevel
    float level
    color col
    bool show
    string key = ''
    line ln = na
    label lb = na
    bool crossed = false

f_fibLevelKey(float level) =>
    string raw = str.tostring(level)
    string noDecimal = str.replace(raw, '.', '_')
    str.replace(noDecimal, '-', 'neg')

var array<FibLevel> BUF_fibLevels = array.new<FibLevel>()
if barstate.isfirst
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_0, INPUT_COL_0, INPUT_SHOW_0, f_fibLevelKey(INPUT_VAL_0)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_0_236, INPUT_COL_0_236, INPUT_SHOW_0_236, f_fibLevelKey(INPUT_VAL_0_236)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_0_382, INPUT_COL_0_382, INPUT_SHOW_0_382, f_fibLevelKey(INPUT_VAL_0_382)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_0_5, INPUT_COL_0_5, INPUT_SHOW_0_5, f_fibLevelKey(INPUT_VAL_0_5)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_0_618, INPUT_COL_0_618, INPUT_SHOW_0_618, f_fibLevelKey(INPUT_VAL_0_618)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_0_65, INPUT_COL_0_65, INPUT_SHOW_0_65, f_fibLevelKey(INPUT_VAL_0_65)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_0_786, INPUT_COL_0_786, INPUT_SHOW_0_786, f_fibLevelKey(INPUT_VAL_0_786)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_1, INPUT_COL_1, INPUT_SHOW_1, f_fibLevelKey(INPUT_VAL_1)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_1_272, INPUT_COL_1_272, INPUT_SHOW_1_272, f_fibLevelKey(INPUT_VAL_1_272)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_1_414, INPUT_COL_1_414, INPUT_SHOW_1_414, f_fibLevelKey(INPUT_VAL_1_414)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_1_618, INPUT_COL_1_618, INPUT_SHOW_1_618, f_fibLevelKey(INPUT_VAL_1_618)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_1_65, INPUT_COL_1_65, INPUT_SHOW_1_65, f_fibLevelKey(INPUT_VAL_1_65)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_2_618, INPUT_COL_2_618, INPUT_SHOW_2_618, f_fibLevelKey(INPUT_VAL_2_618)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_2_65, INPUT_COL_2_65, INPUT_SHOW_2_65, f_fibLevelKey(INPUT_VAL_2_65)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_3_618, INPUT_COL_3_618, INPUT_SHOW_3_618, f_fibLevelKey(INPUT_VAL_3_618)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_3_65, INPUT_COL_3_65, INPUT_SHOW_3_65, f_fibLevelKey(INPUT_VAL_3_65)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_4_236, INPUT_COL_4_236, INPUT_SHOW_4_236, f_fibLevelKey(INPUT_VAL_4_236)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_4_618, INPUT_COL_4_618, INPUT_SHOW_4_618, f_fibLevelKey(INPUT_VAL_4_618)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_236, INPUT_COL_NEG_0_236, INPUT_SHOW_NEG_0_236, f_fibLevelKey(INPUT_VAL_NEG_0_236)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_382, INPUT_COL_NEG_0_382, INPUT_SHOW_NEG_0_382, f_fibLevelKey(INPUT_VAL_NEG_0_382)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_618, INPUT_COL_NEG_0_618, INPUT_SHOW_NEG_0_618, f_fibLevelKey(INPUT_VAL_NEG_0_618)))
    BUF_fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_65, INPUT_COL_NEG_0_65, INPUT_SHOW_NEG_0_65, f_fibLevelKey(INPUT_VAL_NEG_0_65)))

// Doc: Uses array.join() to avoid repeated string concatenation in loop (TradingView Pine v6 best practice)
method toJson(LevelLog this) =>
    array<string> parts = array.new<string>(0)
    array.push(parts, '{')
    int levelCount = array.size(BUF_fibLevels)
    for i = 0 to levelCount - 1
        FibLevel lvl = array.get(BUF_fibLevels, i)
        float val = this.data.get(lvl.level)
        array.push(parts, '"')
        array.push(parts, lvl.key)  // Use pre-computed key instead of per-loop str.replace
        array.push(parts, '":')
        array.push(parts, na(val) ? 'null' : str.tostring(val))
        if i < levelCount - 1
            array.push(parts, ',')
    array.push(parts, '}')
    array.join(parts, '')

// Create LevelLog instances wrapping the raw maps
var LevelLog GLOBAL_pivotLevelsLogRetracements = LevelLog.new(GLOBAL_pivotLevelsLogRetracementsMap)
var LevelLog GLOBAL_pivotLevelsLogCrossed = LevelLog.new(GLOBAL_pivotLevelsLogCrossedMap)

int decimalsCount = math.round(math.abs(math.log(1 / syminfo.mintick) / math.log(10)))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTRABAR DATA REQUEST - Lower Timeframe Arrays for Chronological TP/SL Resolution
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// request.security_lower_tf MUST be at global scope (not inside conditionals)

array<float> REQ_ltfHighs = request.security_lower_tf(syminfo.tickerid, INPUT_INTRABAR_TF, high)
array<float> REQ_ltfLows  = request.security_lower_tf(syminfo.tickerid, INPUT_INTRABAR_TF, low)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEARNING ENGINE DATA STRUCTURES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Declared before CircularBufferSetupRecord (dependency)
type SetupRecord
    int    setup_bar
    int    state_mask = 0
    float  zone_top
    float  zone_bottom
    float  sl_level
    float  tp_level
    float  closest_approach
    int    bars_to_outcome
    float  max_adverse
    float  max_favorable
    float  entry_price
    float  atr_at_setup
    float  rsi_at_entry
    float  tp_conservative
    float  tp_aggressive
    float  vol_percentile
    int    entropy_regime = 0
    float  entropy_norm = 0.0
    int    hurst_regime = 1
    float  hurst_value = 0.5
    float  zscore_value = 0.0
    bool   strong_momentum = false
    float  log_return = 0.0

method hasFlag(SetupRecord this, int flag) =>
    math.floor(this.state_mask / flag) % 2 == 1

method setFlag(SetupRecord this, int flag) =>
    if not this.hasFlag(flag)
        this.state_mask += flag
    this

method clearFlag(SetupRecord this, int flag) =>
    if this.hasFlag(flag)
        this.state_mask -= flag
    this

method hasAny(SetupRecord this, int mask) =>
    bool result = false
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if this.hasFlag(testBit)
                result := true
                break
        testBit := testBit * 2
    result

method hasAll(SetupRecord this, int mask) =>
    bool result = true
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if not this.hasFlag(testBit)
                result := false
                break
        testBit := testBit * 2
    result

method setLifecycle(SetupRecord this, int phase) =>
    this.clearFlag(STATIC_FLAG_PENDING).clearFlag(STATIC_FLAG_ACTIVE).clearFlag(STATIC_FLAG_CLOSED).setFlag(phase)

method setOutcome(SetupRecord this, int outcome) =>
    this.clearFlag(STATIC_FLAG_SL_HIT).clearFlag(STATIC_FLAG_TP_HIT).setFlag(outcome)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CIRCULAR BUFFER - O(1) Fixed-Size Ring Buffer for Historical Data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//              Overwrites oldest entries when capacity is reached.
type CircularBufferSetupRecord
    array<SetupRecord> data
    int head = 0
    int count = 0
    int capacity = 50

method init(CircularBufferSetupRecord this, int _capacity) =>
    this.capacity := _capacity
    this.head := 0
    this.count := 0
    this.data := array.new<SetupRecord>(_capacity)
    this

method push(CircularBufferSetupRecord this, SetupRecord value) =>
    array.set(this.data, this.head, value)
    this.head := (this.head + 1) % this.capacity
    this.count := math.min(this.count + 1, this.capacity)
    this

method get(CircularBufferSetupRecord this, int lookback) =>
    if lookback < 0 or lookback >= this.count
        na
    else
        int physicalIndex = (this.head - 1 - lookback + this.capacity) % this.capacity
        array.get(this.data, physicalIndex)

method size(CircularBufferSetupRecord this) =>
    this.count

method isEmpty(CircularBufferSetupRecord this) =>
    this.count == 0

method isFull(CircularBufferSetupRecord this) =>
    this.count == this.capacity

var CircularBufferSetupRecord GLOBAL_setupHistory = CircularBufferSetupRecord.new()

if barstate.isfirst
    GLOBAL_setupHistory.init(INPUT_LEARNING_SAMPLES)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKTESTING ENGINE - Trade Mining System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//              outcome flags, and performance metrics (MAE/MFE).
//                   Must be initialized via BacktestTrade.new() with proper flags
type BacktestTrade
    int    id
    int    state_mask  // No default - must be initialized with proper flags
    float  entry_price
    float  entry_top
    float  entry_btm
    float  sl_price
    float  tp_price
    float  mae
    float  mfe
    int    entry_bar
    int    exit_bar

method hasFlag(BacktestTrade this, int flag) =>
    math.floor(this.state_mask / flag) % 2 == 1

method setFlag(BacktestTrade this, int flag) =>
    if not this.hasFlag(flag)
        this.state_mask += flag
    this

method clearFlag(BacktestTrade this, int flag) =>
    if this.hasFlag(flag)
        this.state_mask -= flag
    this

method hasAny(BacktestTrade this, int mask) =>
    bool result = false
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if this.hasFlag(testBit)
                result := true
                break
        testBit := testBit * 2
    result

method hasAll(BacktestTrade this, int mask) =>
    bool result = true
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if not this.hasFlag(testBit)
                result := false
                break
        testBit := testBit * 2
    result

method setLifecycle(BacktestTrade this, int phase) =>
    this.clearFlag(STATIC_FLAG_PENDING).clearFlag(STATIC_FLAG_ACTIVE).clearFlag(STATIC_FLAG_CLOSED).setFlag(phase)

method setOutcome(BacktestTrade this, int outcome) =>
    this.clearFlag(STATIC_FLAG_SL_HIT).clearFlag(STATIC_FLAG_TP_HIT).setFlag(outcome)

//              Provides Smart SL offset and confidence metrics for live trading.
type BacktestStats
    float avgWinningMae = 0.0
    float avgLosingMae = 0.0
    float winRate = 0.0
    int   totalTrades = 0
    int   winningTrades = 0
    float smartSlOffset = 0.0
    bool  lowConfidence = false
    bool  statsReady = false

method isReady(BacktestStats this) =>
    this.statsReady

method hasLowConfidence(BacktestStats this) =>
    this.lowConfidence

method getSmartSlOffset(BacktestStats this) =>
    this.smartSlOffset

//              Spawns trades on pivot changes, manages lifecycle, closes on SL/TP.
type BacktestEngine
    array<BacktestTrade> history = na
    BacktestTrade current = na
    BacktestStats stats = na

method init(BacktestEngine this) =>
    this.history := array.new<BacktestTrade>()
    this.stats := BacktestStats.new()
    this

method hasActiveTrade(BacktestEngine this) =>
    not na(this.current)

method getTradeCount(BacktestEngine this) =>
    na(this.history) ? 0 : this.history.size()

method archiveTrade(BacktestEngine this, BacktestTrade trade) =>
    if not na(this.history)
        this.history.push(trade)
    this

method calculateStats(BacktestEngine this) =>
    if na(this.history) or na(this.stats) or this.stats.statsReady
        this
    else
        int total = this.history.size()
        if total > 0
            int wins = 0
            float sumWinningMae = 0.0
            float sumLosingMae = 0.0
            int losingCount = 0
            
            for i = 0 to total - 1
                BacktestTrade trade = this.history.get(i)
                if trade.hasFlag(STATIC_FLAG_WON)
                    wins += 1
                    sumWinningMae += trade.mae
                else
                    losingCount += 1
                    sumLosingMae += trade.mae
            
            this.stats.totalTrades := total
            this.stats.winningTrades := wins
            this.stats.winRate := total > 0 ? float(wins) / float(total) : 0.0
            this.stats.avgWinningMae := wins > 0 ? sumWinningMae / float(wins) : 0.0
            this.stats.avgLosingMae := losingCount > 0 ? sumLosingMae / float(losingCount) : 0.0
            this.stats.smartSlOffset := this.stats.avgWinningMae * 1.1
            this.stats.lowConfidence := this.stats.winRate < 0.40
            this.stats.statsReady := true
        this

// Global BacktestEngine instance (replaces GLOBAL_backtest.history, GLOBAL_backtest.current, bt_* vars)
var BacktestEngine GLOBAL_backtest = BacktestEngine.new().init()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SetupState UDT: Tracks LIVE state of a Golden Pocket setup
// Used to separate CONFIRMED trade tracking (for learning) from PROJECTION preview (visual only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
type SetupState
    int    setup_bar
    int    creation_bar
    int    state_mask = 0
    float  zone_top
    float  zone_bottom
    float  sl_price
    float  tp_price
    float  tp_cons
    float  tp_aggr
    float  min_distance
    int    entry_bar
    float  entry_price
    float  max_adverse
    float  max_favorable
    float  atr_at_setup
    float  rsi_at_entry
    float  vol_percentile

method hasFlag(SetupState this, int flag) =>
    math.floor(this.state_mask / flag) % 2 == 1

method setFlag(SetupState this, int flag) =>
    if not this.hasFlag(flag)
        this.state_mask += flag
    this

method clearFlag(SetupState this, int flag) =>
    if this.hasFlag(flag)
        this.state_mask -= flag
    this

method hasAny(SetupState this, int mask) =>
    bool result = false
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if this.hasFlag(testBit)
                result := true
                break
        testBit := testBit * 2
    result

method hasAll(SetupState this, int mask) =>
    bool result = true
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if not this.hasFlag(testBit)
                result := false
                break
        testBit := testBit * 2
    result

method setLifecycle(SetupState this, int phase) =>
    this.clearFlag(STATIC_FLAG_PENDING).clearFlag(STATIC_FLAG_ACTIVE).clearFlag(STATIC_FLAG_CLOSED).setFlag(phase)

method setOutcome(SetupState this, int outcome) =>
    this.clearFlag(STATIC_FLAG_SL_HIT).clearFlag(STATIC_FLAG_TP_HIT).setFlag(outcome)

f_new_setup_state() =>
    SetupState.new(
        na,                    // setup_bar
        na,                    // creation_bar
        0,                     // state_mask (no flags)
        na,                    // zone_top
        na,                    // zone_bottom
        na,                    // sl_price
        na,                    // tp_price
        na,                    // tp_cons
        na,                    // tp_aggr
        DEFAULT_MIN_DISTANCE,  // min_distance
        na,                    // entry_bar
        na,                    // entry_price
        0.0,                   // max_adverse
        0.0,                   // max_favorable
        na,                    // atr_at_setup
        na,                    // rsi_at_entry
        DEFAULT_CONFIDENCE     // vol_percentile
    )

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERT STATE UDT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
type AlertState
    // Setup flags
    bool isProjection = false
    bool isLong = false
    bool zoneTouched = false
    bool stopLossHit = false
    bool takeProfitHit = false
    bool isInZone = false
    bool isZoneEntry = false
    bool useAggressiveTakeProfit = false
    bool isExpired = false
    // Zone/position values
    float rawZoneTop = na
    float rawZoneBottom = na
    float adjustedZoneTop = na
    float adjustedZoneBottom = na
    float bufferPercent = na
    float minimumDistance = na
    float stopLossPrice = na
    float takeProfitPrice = na
    float takeProfitConservative = na
    float takeProfitAggressive = na
    float stopLossMultiplier = na
    float averageTrueRange = na
    float smartStopLoss = na
    // Time decay
    int creationBar = na
    int barsSinceCreation = 0
    int timePhase = 0
    float decayRate = 0.85

method populate(AlertState this, bool isProjection, bool isLong, bool zoneTouched, bool stopLossHit, bool takeProfitHit, bool isInZone, bool isZoneEntry, bool useAggressiveTarget, bool isExpired, float rawZoneTop, float rawZoneBottom, float adjustedZoneTop, float adjustedZoneBottom, float bufferPercent, float minimumDistance, float stopLossPrice, float takeProfitPrice, float takeProfitConservative, float takeProfitAggressive, float stopLossMultiplier, float averageTrueRange, float smartStopLoss, int creationBarIndex, int barsSinceCreation, int decayPhase, float decayRateValue) =>
    this.isProjection := isProjection
    this.isLong := isLong
    this.zoneTouched := zoneTouched
    this.stopLossHit := stopLossHit
    this.takeProfitHit := takeProfitHit
    this.isInZone := isInZone
    this.isZoneEntry := isZoneEntry
    this.useAggressiveTakeProfit := useAggressiveTarget
    this.isExpired := isExpired
    this.rawZoneTop := rawZoneTop
    this.rawZoneBottom := rawZoneBottom
    this.adjustedZoneTop := adjustedZoneTop
    this.adjustedZoneBottom := adjustedZoneBottom
    this.bufferPercent := bufferPercent
    this.minimumDistance := minimumDistance
    this.stopLossPrice := stopLossPrice
    this.takeProfitPrice := takeProfitPrice
    this.takeProfitConservative := takeProfitConservative
    this.takeProfitAggressive := takeProfitAggressive
    this.stopLossMultiplier := stopLossMultiplier
    this.averageTrueRange := averageTrueRange
    this.smartStopLoss := smartStopLoss
    this.creationBar := creationBarIndex
    this.barsSinceCreation := barsSinceCreation
    this.timePhase := decayPhase
    this.decayRate := decayRateValue
    this

// Global alert state - populated in Statistical Position Engine, consumed in ALERTS
var AlertState GLOBAL_alertState = AlertState.new()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE SEPARATION: Active Trade vs Projection Preview
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL_activeTrade: Updated on confirmed ZigZag pivots (GLOBAL_zigzag.changed)
//                     Source of truth for learning engine and setup history
//                     Rendered with solid visual elements
var SetupState GLOBAL_activeTrade = f_new_setup_state()

// GLOBAL_projectionPreview: Recalculated each bar during projection mode
//                           Visual preview only - not recorded to history
//                           Rendered with dashed visual elements
SetupState GLOBAL_projectionPreview = f_new_setup_state()

// Learning engine state
var LearningMetrics GLOBAL_learning = LearningMetrics.new()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXECUTION FLOW COUNTERS - Debug Diagnostics (Pine v6 lazy evaluation tracking)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Counters track heavy function executions for performance analysis
//       Only displayed on barstate.islast when INPUT_DEBUG_FLOW enabled.
//       No per-bar overhead when disabled.
var int DBG_counterEntropyRuns = 0
var int DBG_counterHurstRuns = 0
var int DBG_counterZscoreRuns = 0
var int DBG_counterLearningRuns = 0
var int DBG_counterSpawnAttempts = 0
var int DBG_counterSpawnBlocked = 0

// AddOn Logic: Volatility & Volume
float i_weightedATR = ta.atr(INPUT_ATR_LENGTH) * INPUT_ATR_MULT
float i_vSMA = ta.sma(nz(volume), INPUT_VOL_SMA_LEN)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REGIME STATE - Global Instance
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RegimeState GLOBAL_regime = RegimeState.new()

// Symbolic entropy engine - global instance
var SymbolicEntropyState GLOBAL_symbolicEntropy = SymbolicEntropyState.new()

// Populate log-return volatility state
GLOBAL_regime.logReturn := f_logReturn(close, close[1])
GLOBAL_regime.logReturnStdev := ta.stdev(GLOBAL_regime.logReturn, LOG_VOL_WINDOW)
GLOBAL_regime.periodsPerYear := f_getPeriodsPerYear()
GLOBAL_regime.annualizedVol := f_annualizedVol(GLOBAL_regime.logReturnStdev, GLOBAL_regime.periodsPerYear)

// Populate entropy state (route based on mode)
// Legacy mode uses original binned log-return entropy
// Symbolic modes use O(1) incremental binary/k-gram entropy
// PerfController: Fast preset forces K-gram mode with reduced window
float _ent = na
float _entNorm = na
int _entReg = ENTROPY_REGIME_DISORDERED

// Apply PerfController adjustments for effective mode/window
string _effectiveEntropyMode = perf_getEntropyMode(INPUT_ENTROPY_MODE)
int _effectiveEntropyWindow = perf_getEntropyWindow(INPUT_ENTROPY_WINDOW)

if _effectiveEntropyMode == ENTROPY_MODE_LEGACY
    // Legacy path: O(window) binned entropy (default for backward compatibility)
    [__ent, __entNorm, __entReg] = f_rollingEntropy(GLOBAL_regime.logReturn, _effectiveEntropyWindow, INPUT_ENTROPY_BINS, INPUT_ENTROPY_THRESH, INPUT_ENTROPY_TRANSITION)
    _ent := __ent
    _entNorm := __entNorm
    _entReg := __entReg
else
    // Symbolic path: O(1) incremental entropy
    // Reinitialize if config changed
    if GLOBAL_symbolicEntropy.needsReinit(_effectiveEntropyMode, INPUT_ENTROPY_K, _effectiveEntropyWindow)
        GLOBAL_symbolicEntropy.init(_effectiveEntropyMode, INPUT_ENTROPY_K, _effectiveEntropyWindow)
    
    // Generate binary state (up=1, down/flat=0)
    int binaryState = f_binaryState(close, close[1])
    
    // Update engine with new state (O(1) operation)
    GLOBAL_symbolicEntropy.update(binaryState, INPUT_ENTROPY_THRESH, INPUT_ENTROPY_TRANSITION)
    
    // Get results
    [__ent, __entNorm, __entReg] = GLOBAL_symbolicEntropy.getResults()
    _ent := __ent
    _entNorm := __entNorm
    _entReg := __entReg

GLOBAL_regime.entropy := _ent
GLOBAL_regime.entropyNorm := _entNorm
GLOBAL_regime.entropyRegime := _entReg
GLOBAL_regime.entropyOk := not INPUT_ENTROPY_ENABLED or _entReg != ENTROPY_REGIME_DISORDERED
DBG_counterEntropyRuns += 1

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HURST EXPONENT - Mode routing with execution gating and regime integration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Routes between Legacy and Dyadic paths based on INPUT_HURST_MODE
//       Legacy mode is default for backward compatibility.
//       Dyadic modes eliminate per-bar allocations and use O(log N) scales.

var DyadicHurstState GLOBAL_dyadicHurst = DyadicHurstState.new()

float _hurst = 0.5
int _hurstReg = HURST_REGIME_RANDOM

// Apply PerfController adjustments for effective mode/window
string _effectiveHurstMode = perf_getHurstMode(INPUT_HURST_MODE)
int _effectiveHurstWindow = perf_getHurstWindow(INPUT_HURST_WINDOW)

if _effectiveHurstMode == STATIC_HURST_MODE_LEGACY
    // Legacy path: Original geometric scaling (O(N * scales) per bar)
    // Kept for backward compatibility and baseline parity checks
    [__hurst, __hurstReg] = f_rollingHurst(GLOBAL_regime.logReturn, _effectiveHurstWindow, HURST_MIN_WINDOW, INPUT_HURST_TREND, INPUT_HURST_MEANREV)
    _hurst := __hurst
    _hurstReg := __hurstReg
else
    // Dyadic path: Optimized O(log N) with precomputed regression constants
    // Check for config changes requiring reinit (includes effective mode/window)
    if GLOBAL_dyadicHurst.needsReinit(HURST_MIN_WINDOW, _effectiveHurstWindow, _effectiveHurstMode)
        GLOBAL_dyadicHurst.init(HURST_MIN_WINDOW, _effectiveHurstWindow, _effectiveHurstMode)
    
    // Determine fast mode (single chunk) vs stable (all chunks)
    // PerfController may force Fast mode even if user selected Stable
    bool isFastMode = _effectiveHurstMode == STATIC_HURST_MODE_DYADIC_FAST
    
    // Update with current log return
    GLOBAL_dyadicHurst.update(GLOBAL_regime.logReturn, isFastMode, INPUT_HURST_TREND, INPUT_HURST_MEANREV)
    
    // Get results
    [__hurst, __hurstReg] = GLOBAL_dyadicHurst.getResults()
    _hurst := __hurst
    _hurstReg := __hurstReg

GLOBAL_regime.hurst := _hurst
GLOBAL_regime.hurstRegime := _hurstReg
GLOBAL_regime.hurstOk := not INPUT_HURST_ENABLED or not INPUT_HURST_BLOCK_RANDOM or _hurstReg != HURST_REGIME_RANDOM
DBG_counterHurstRuns += 1

// Populate Z-score momentum state (always runs - internal ta.* functions need full history)
GLOBAL_regime.zscoreAtr := ta.atr(INPUT_ZSCORE_ATR_LEN)
GLOBAL_regime.linregSlope := f_linregSlope(close, INPUT_ZSCORE_LR_LEN)
GLOBAL_regime.normSlope := GLOBAL_regime.zscoreAtr > 0 ? GLOBAL_regime.linregSlope / GLOBAL_regime.zscoreAtr : 0.0
[_zscore, _strongMom] = f_rollingZScore(GLOBAL_regime.normSlope, INPUT_ZSCORE_Z_LEN, ZSCORE_MIN_SAMPLES, INPUT_ZSCORE_THRESH)
GLOBAL_regime.zscore := _zscore
GLOBAL_regime.strongMomentum := _strongMom
GLOBAL_regime.momentumOk := not INPUT_ZSCORE_ENABLED or _strongMom
DBG_counterZscoreRuns += 1

// Populate volatility state
GLOBAL_regime.rawAtr := i_weightedATR / INPUT_ATR_MULT
GLOBAL_regime.atrPercentile := ta.percentrank(GLOBAL_regime.rawAtr, 100)
GLOBAL_regime.rsi := ta.rsi(close, INPUT_POS_RSI_LEN)

float nzVolume = nz(volume)
bool bullCandle = close > open
bool bearCandle = close < open
float range_1 = math.abs(high - low)
bool exhaustVol = nzVolume > INPUT_VOL_SPIKE_THRESH * i_vSMA
bool crossover_exhaustion = ta.crossover(nzVolume, i_vSMA * INPUT_VOL_SPIKE_THRESH)
bool highVolatility = range_1 > i_weightedATR
bool crossover_volatility = ta.crossover(range_1, i_weightedATR)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXTERNAL CONTEXT ENGINE - Dynamic Requests with Budget Awareness
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pine v6 dynamic requests (series string contexts) in local scope
//       Gated execution prevents requests when feature disabled or gating condition false.
//       Budget capped at EXT_MAX_SYMBOLS_CAP to avoid unique request limit (40).
//       Intrabar requests (request.security_lower_tf) remain at global scope per Pine rules.

var ExternalContextState GLOBAL_extContext = ExternalContextState.new()

// Initialize persistent arrays once
if barstate.isfirst
    GLOBAL_extContext.symbols := array.new<string>(0)
    GLOBAL_extContext.closes := array.new<float>(0)
    GLOBAL_extContext.opens := array.new<float>(0)
    GLOBAL_extContext.highs := array.new<float>(0)
    GLOBAL_extContext.lows := array.new<float>(0)
    GLOBAL_extContext.volumes := array.new<float>(0)
    GLOBAL_extContext.enabled := INPUT_EXT_ENABLED

// Reset state for new bar
GLOBAL_extContext.reset()
GLOBAL_extContext.enabled := INPUT_EXT_ENABLED

// Compute gating condition
bool _extGated = INPUT_EXT_ENABLED and f_computeExtGate(INPUT_EXT_GATE_MODE, GLOBAL_regime.entropyRegime, GLOBAL_regime.hurst, INPUT_HURST_MEANREV)
GLOBAL_extContext.gated := _extGated

// Execute external requests only when enabled and gated
if _extGated and not GLOBAL_extContext.budgetExceeded
    // Parse symbols once per change (stable ordering reduces uniqueness churn)
    array<string> _parsedSymbols = f_parseSymbols(INPUT_EXT_SYMBOLS, INPUT_EXT_MAX_SYMBOLS)
    int _symCount = array.size(_parsedSymbols)
    
    // Copy symbols to state
    array.clear(GLOBAL_extContext.symbols)
    for i = 0 to _symCount - 1
        array.push(GLOBAL_extContext.symbols, array.get(_parsedSymbols, i))
    
    // Resolve effective timeframe
    string _extTf = f_getExtTimeframe(INPUT_EXT_TF_MODE, INPUT_EXT_TF_CUSTOM)
    
    // Budget check: existing LTF requests (2) + external symbols
    int _estimatedContexts = 2 + _symCount
    if _estimatedContexts > EXT_MAX_CONTEXTS
        GLOBAL_extContext.budgetExceeded := true
    else
        GLOBAL_extContext.usedContexts := _symCount
        
        // Request data for each symbol (bounded loop)
        for i = 0 to _symCount - 1
            string _sym = array.get(_parsedSymbols, i)
            
            if INPUT_EXT_FIELDS == EXT_FIELDS_OHLCV
                [_o, _h, _l, _c, _v] = f_reqExtOHLCV(_sym, _extTf)
                array.push(GLOBAL_extContext.opens, _o)
                array.push(GLOBAL_extContext.highs, _h)
                array.push(GLOBAL_extContext.lows, _l)
                array.push(GLOBAL_extContext.closes, _c)
                array.push(GLOBAL_extContext.volumes, _v)
                if not na(_c)
                    GLOBAL_extContext.validCount += 1
            else
                float _c = f_reqExtClose(_sym, _extTf)
                array.push(GLOBAL_extContext.closes, _c)
                if not na(_c)
                    GLOBAL_extContext.validCount += 1

// Compute aggregated extOk: true if disabled, or all valid when enabled
bool _extOk = true
if INPUT_EXT_ENABLED
    if GLOBAL_extContext.gated and array.size(GLOBAL_extContext.closes) > 0
        _extOk := GLOBAL_extContext.validCount > 0
GLOBAL_extContext.extOk := _extOk

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZIGZAG ENGINE - Manages ZigZag line drawing and pivot state
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var ZigZagEngine GLOBAL_zigzag = ZigZagEngine.new()
var ZigZagVisualBuffer GLOBAL_zigzagBuffer = ZigZagVisualBuffer.new()
var string GLOBAL_prevZzRender = INPUT_ZZ_RENDER_MODE

bool _zzRenderChanged = INPUT_ZZ_RENDER_MODE != GLOBAL_prevZzRender
GLOBAL_prevZzRender := INPUT_ZZ_RENDER_MODE
bool _zzUsePolyline = INPUT_ZZ_RENDER_MODE == 'POLYLINE_BUFFER'

GLOBAL_zigzagBuffer.configure(INPUT_ZZ_POLY_MAX_KEEP, INPUT_ZZ_POLY_MAX_POINTS, INPUT_ZZ_LIVE_SEGMENT)

// Mode switch cleanup: clear polylines when switching FROM polyline mode or when mode changes
if _zzRenderChanged
    GLOBAL_zigzagBuffer.clearAll()
    // Delete existing line when switching TO polyline mode
    if _zzUsePolyline and not na(GLOBAL_zigzag.ln)
        line.delete(GLOBAL_zigzag.ln)
        GLOBAL_zigzag.ln := na

//              Used to prevent flicker during intrabar updates by caching confirmed values.
type CachedPivots
    int iMidPivot = na
    float pMidPivot = na
    int iEndBase = na
    float pEndBase = na
    int GLOBAL_indexMidPivot2 = na
    float GLOBAL_priceMidPivot2 = na
    int GLOBAL_indexEndBase2 = na
    float GLOBAL_priceEndBase2 = na

method reset(CachedPivots this) =>
    this.iMidPivot := na
    this.pMidPivot := na
    this.iEndBase := na
    this.pEndBase := na
    this.GLOBAL_indexMidPivot2 := na
    this.GLOBAL_priceMidPivot2 := na
    this.iEndBase2 := na
    this.pEndBase2 := na
    this

method updatePrimary(CachedPivots this, int iMid, float pMid, int iEnd, float pEnd) =>
    this.iMidPivot := iMid
    this.pMidPivot := pMid
    this.iEndBase := iEnd
    this.pEndBase := pEnd
    this

method updateSecondary(CachedPivots this, int iMid, float pMid, int iEnd, float pEnd) =>
    this.GLOBAL_indexMidPivot2 := iMid
    this.GLOBAL_priceMidPivot2 := pMid
    this.iEndBase2 := iEnd
    this.pEndBase2 := pEnd
    this

// Global cached pivots instance
var CachedPivots GLOBAL_cachedPivots = CachedPivots.new()

// Timeframe-based deviation threshold (O(1) map lookup)
float GLOBAL_DEV_THRESHOLD = INPUT_CUSTOM_THRESHOLD and STATE_tfDevThresholds.contains(timeframe.period) ? STATE_tfDevThresholds.get(timeframe.period) : STATE_tfDevThresholds.get("DEFAULT")

// Timeframe-based depth (O(1) map lookup)
int i_depth = INPUT_CUSTOM_DEPTH and STATE_tfDepths.contains(timeframe.period) ? STATE_tfDepths.get(timeframe.period) : STATE_tfDepths.get("DEFAULT")

// Determine HTF
REQ_htfAuto = timeframe.period == '1'   ? '240' : 
           timeframe.period == '3'   ? '240' : 
           timeframe.period == '5'   ? '240' : 
           timeframe.period == '15'  ? 'D'   : 
           timeframe.period == '30'  ? 'D'   : 
           timeframe.period == '45'  ? 'D'   : 
           timeframe.period == '60'  ? 'W'   : 
           timeframe.period == '120' ? 'W'   : 
           timeframe.period == '180' ? 'W'   : 
           timeframe.period == '240' ? 'W'   : 
           timeframe.period == 'D'   ? 'M'   : 
           timeframe.period == 'W'   ? '3M'  : '12M'

REQ_htf = INPUT_HTF_MODE == 'Auto' ? REQ_htfAuto : REQ_htfUserParsed

// Time Calculations
REQ_timeX10 = ta.valuewhen(ta.change(time(REQ_htf)) != 0, time, 1)
REQ_timeX11 = ta.valuewhen(ta.change(time(REQ_htf)) != 0, time, 0)
REQ_timeX21 = 2 * REQ_timeX11 - REQ_timeX10

var array<line> UI_linesBuffer = array.new<line>()
var array<label> UI_labelsBuffer = array.new<label>()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GLOBAL_pivotLength = math.max(1, int(math.round(i_depth / 2)))
GLOBAL_priceHigh = ta.pivothigh(high, GLOBAL_pivotLength, GLOBAL_pivotLength)
GLOBAL_priceLow = ta.pivotlow(low, GLOBAL_pivotLength, GLOBAL_pivotLength)
GLOBAL_indexHigh = not na(GLOBAL_priceHigh) ? bar_index[GLOBAL_pivotLength] : int(na)
GLOBAL_indexLow = not na(GLOBAL_priceLow) ? bar_index[GLOBAL_pivotLength] : int(na)
int GLOBAL_timeHigh = not na(GLOBAL_priceHigh) ? time[GLOBAL_pivotLength] : int(na)
int GLOBAL_timeLow = not na(GLOBAL_priceLow) ? time[GLOBAL_pivotLength] : int(na)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROJECTION MODE: Tentative Pivot Detection (real-time, before depth confirmation)
// UDT: Uses GLOBAL_projection for state management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Reset or update local extreme tracking
if not na(GLOBAL_priceHigh) or not na(GLOBAL_priceLow)
    GLOBAL_projection.resetLocals(high, low, not na(GLOBAL_priceHigh))
else
    GLOBAL_projection.updateLocals(high, low)

// Scaled threshold for projection: INPUT_PROJ_SENSITIVITY < 1.0 reduces lag (earlier signals)
float proj_scaled_threshold = GLOBAL_DEV_THRESHOLD * INPUT_PROJ_SENSITIVITY

// Detect tentative pivots using UDT methods
bool proj_tentative_high = INPUT_PROJECTION_MODE and GLOBAL_projection.detectTentativeHigh(close, proj_scaled_threshold)
bool proj_tentative_low = INPUT_PROJECTION_MODE and GLOBAL_projection.detectTentativeLow(close, proj_scaled_threshold)

// Projection pivot values (use local extreme as tentative pivot)
float proj_pivot_price = proj_tentative_high ? GLOBAL_projection.localHigh : (proj_tentative_low ? GLOBAL_projection.localLow : na)
int   proj_pivot_bar = proj_tentative_high ? GLOBAL_projection.localHighBar : (proj_tentative_low ? GLOBAL_projection.localLowBar : int(na))
bool  proj_pivot_is_high = proj_tentative_high

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRE-CALCULATION OF HISTORICAL PIVOT VALUES (Pine v6 - call ta.valuewhen unconditionally)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pre-compute all ta.valuewhen calls unconditionally (Pine v6 best practice)
// These maintain internal state and must be called on every bar
// Using GLOBAL_zigzag for pivot tracking
bool _pivotChange_iPrev = ta.change(GLOBAL_zigzag.iPrevPivot != 0)
bool _pivotChange_pPrev = ta.change(GLOBAL_zigzag.pPrevPivot != 0)
bool _pivotChange_iLast = ta.change(GLOBAL_zigzag.iLastPivot != 0)
bool _pivotChange_pLast = ta.change(GLOBAL_zigzag.pLastPivot != 0)

// Historical pivot 1 - always compute, conditionally use
int _iMidPivot_hist_0 = ta.valuewhen(_pivotChange_iPrev, GLOBAL_zigzag.iPrevPivot, math.max(0, INPUT_HIST_PIVOT - 1))
float _pMidPivot_hist_0 = ta.valuewhen(_pivotChange_pPrev, GLOBAL_zigzag.pPrevPivot, math.max(0, INPUT_HIST_PIVOT - 1))
int _iEndBase_hist_0 = ta.valuewhen(_pivotChange_iLast, GLOBAL_zigzag.iLastPivot, math.max(0, INPUT_HIST_PIVOT - 1))
float _pEndBase_hist_0 = ta.valuewhen(_pivotChange_pLast, GLOBAL_zigzag.pLastPivot, math.max(0, INPUT_HIST_PIVOT - 1))

// Historical pivot 2 - always compute, conditionally use
int _iMidPivot_hist_1 = ta.valuewhen(_pivotChange_iPrev, GLOBAL_zigzag.iPrevPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))
float _pMidPivot_hist_1 = ta.valuewhen(_pivotChange_pPrev, GLOBAL_zigzag.pPrevPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))
int _iEndBase_hist_1 = ta.valuewhen(_pivotChange_iLast, GLOBAL_zigzag.iLastPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))
float _pEndBase_hist_1 = ta.valuewhen(_pivotChange_pLast, GLOBAL_zigzag.pLastPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))

// Apply conditional logic after function calls
TMP_iMidPivot_hist = INPUT_HIST_PIVOT > 0 ? _iMidPivot_hist_0 : int(na)
TMP_pMidPivot_hist = INPUT_HIST_PIVOT > 0 ? _pMidPivot_hist_0 : float(na)
TMP_iEndBase_hist = INPUT_HIST_PIVOT > 0 ? _iEndBase_hist_0 : int(na)
TMP_pEndBase_hist = INPUT_HIST_PIVOT > 0 ? _pEndBase_hist_0 : float(na)

TMP_GLOBAL_indexMidPivot2_hist = INPUT_HIST_PIVOT_2 > 0 ? _iMidPivot_hist_1 : int(na)
TMP_GLOBAL_priceMidPivot2_hist = INPUT_HIST_PIVOT_2 > 0 ? _pMidPivot_hist_1 : float(na)
TMP_iEndBase2_hist = INPUT_HIST_PIVOT_2 > 0 ? _iEndBase_hist_1 : int(na)
TMP_pEndBase2_hist = INPUT_HIST_PIVOT_2 > 0 ? _pEndBase_hist_1 : float(na)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN PIVOT DETECTION AND ZIGZAG CONSTRUCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GLOBAL_zigzag.resetChanged()

if not na(GLOBAL_indexHigh)
    if na(GLOBAL_zigzag.ln) and GLOBAL_zigzag.pLast == 0
        GLOBAL_zigzag.initFirst(GLOBAL_indexHigh, GLOBAL_timeHigh, GLOBAL_priceHigh, true)
    else
        float dev = f_calcDev(GLOBAL_zigzag.pLast, GLOBAL_priceHigh)
        bool newSegment = GLOBAL_zigzag.processPivot(dev, true, GLOBAL_indexHigh, GLOBAL_timeHigh, GLOBAL_priceHigh, GLOBAL_DEV_THRESHOLD, COLOR_ZZ, INPUT_SHOW_ZIGZAG, _zzUsePolyline)
        
        if newSegment
            // New line segment was created - update cached pivot values
            GLOBAL_cachedPivots.iMidPivot := INPUT_HIST_PIVOT > 0 ? TMP_iMidPivot_hist : GLOBAL_zigzag.iPrevPivot
            GLOBAL_cachedPivots.pMidPivot := INPUT_HIST_PIVOT > 0 ? TMP_pMidPivot_hist : GLOBAL_zigzag.pPrevPivot
            GLOBAL_cachedPivots.iEndBase := INPUT_HIST_PIVOT > 0 ? TMP_iEndBase_hist : GLOBAL_zigzag.iLastPivot
            GLOBAL_cachedPivots.pEndBase := INPUT_HIST_PIVOT > 0 ? TMP_pEndBase_hist : GLOBAL_zigzag.pLastPivot
            
            GLOBAL_cachedPivots.GLOBAL_indexMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? TMP_GLOBAL_indexMidPivot2_hist : GLOBAL_zigzag.iPrevPivot
            GLOBAL_cachedPivots.GLOBAL_priceMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? TMP_GLOBAL_priceMidPivot2_hist : GLOBAL_zigzag.pPrevPivot
            GLOBAL_cachedPivots.iEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? TMP_iEndBase2_hist : GLOBAL_zigzag.iLastPivot
            GLOBAL_cachedPivots.pEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? TMP_pEndBase2_hist : GLOBAL_zigzag.pLastPivot
            
            if _zzUsePolyline and INPUT_SHOW_ZIGZAG
                int tStart = GLOBAL_zigzag.tPrevPivot
                int tEnd = GLOBAL_zigzag.tLastPivot
                float pStart = GLOBAL_zigzag.pPrevPivot
                float pEnd = GLOBAL_zigzag.pLastPivot
                if tStart != 0 and tEnd != 0 and not na(pStart) and not na(pEnd)
                    GLOBAL_zigzagBuffer.addSegment(tStart, pStart, tEnd, pEnd, COLOR_ZZ)
        else if INPUT_HIST_PIVOT == 0
            // Line was extended (same direction) - update endpoint caches
            if GLOBAL_zigzag.isHighLast and GLOBAL_priceHigh > (GLOBAL_zigzag[1]).pLast
                GLOBAL_cachedPivots.iEndBase := GLOBAL_indexHigh
                GLOBAL_cachedPivots.pEndBase := GLOBAL_priceHigh
                GLOBAL_cachedPivots.iEndBase2 := GLOBAL_indexHigh
                GLOBAL_cachedPivots.pEndBase2 := GLOBAL_priceHigh
                GLOBAL_zigzag.changed := true
else
    if not na(GLOBAL_indexLow)
        if na(GLOBAL_zigzag.ln) and GLOBAL_zigzag.pLast == 0
            GLOBAL_zigzag.initFirst(GLOBAL_indexLow, GLOBAL_timeLow, GLOBAL_priceLow, false)
        else
            float dev = f_calcDev(GLOBAL_zigzag.pLast, GLOBAL_priceLow)
            bool newSegment = GLOBAL_zigzag.processPivot(dev, false, GLOBAL_indexLow, GLOBAL_timeLow, GLOBAL_priceLow, GLOBAL_DEV_THRESHOLD, COLOR_ZZ, INPUT_SHOW_ZIGZAG, _zzUsePolyline)
            
            if newSegment
                // New line segment was created - update cached pivot values
                GLOBAL_cachedPivots.iMidPivot := INPUT_HIST_PIVOT > 0 ? TMP_iMidPivot_hist : GLOBAL_zigzag.iPrevPivot
                GLOBAL_cachedPivots.pMidPivot := INPUT_HIST_PIVOT > 0 ? TMP_pMidPivot_hist : GLOBAL_zigzag.pPrevPivot
                GLOBAL_cachedPivots.iEndBase := INPUT_HIST_PIVOT > 0 ? TMP_iEndBase_hist : GLOBAL_zigzag.iLastPivot
                GLOBAL_cachedPivots.pEndBase := INPUT_HIST_PIVOT > 0 ? TMP_pEndBase_hist : GLOBAL_zigzag.pLastPivot
                
                GLOBAL_cachedPivots.GLOBAL_indexMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? TMP_GLOBAL_indexMidPivot2_hist : GLOBAL_zigzag.iPrevPivot
                GLOBAL_cachedPivots.GLOBAL_priceMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? TMP_GLOBAL_priceMidPivot2_hist : GLOBAL_zigzag.pPrevPivot
                GLOBAL_cachedPivots.iEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? TMP_iEndBase2_hist : GLOBAL_zigzag.iLastPivot
                GLOBAL_cachedPivots.pEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? TMP_pEndBase2_hist : GLOBAL_zigzag.pLastPivot
                
                if _zzUsePolyline and INPUT_SHOW_ZIGZAG
                    int tStart = GLOBAL_zigzag.tPrevPivot
                    int tEnd = GLOBAL_zigzag.tLastPivot
                    float pStart = GLOBAL_zigzag.pPrevPivot
                    float pEnd = GLOBAL_zigzag.pLastPivot
                    if tStart != 0 and tEnd != 0 and not na(pStart) and not na(pEnd)
                        GLOBAL_zigzagBuffer.addSegment(tStart, pStart, tEnd, pEnd, COLOR_ZZ)
            else if INPUT_HIST_PIVOT == 0
                // Line was extended (same direction) - update endpoint caches
                if not GLOBAL_zigzag.isHighLast and GLOBAL_priceLow < (GLOBAL_zigzag[1]).pLast
                    GLOBAL_cachedPivots.iEndBase := GLOBAL_indexLow
                    GLOBAL_cachedPivots.pEndBase := GLOBAL_priceLow
                    GLOBAL_cachedPivots.iEndBase2 := GLOBAL_indexLow
                    GLOBAL_cachedPivots.pEndBase2 := GLOBAL_priceLow
                    GLOBAL_zigzag.changed := true

if _zzUsePolyline and INPUT_SHOW_ZIGZAG
    // Live segment extends from last pivot to current high (if bullish) or low (if bearish)
    float livePrice = GLOBAL_zigzag.isHighLast ? low : high
    bool showLive = INPUT_ZZ_LIVE_SEGMENT and GLOBAL_zigzag.tLast != 0 and not na(GLOBAL_zigzag.pLast)
    GLOBAL_zigzagBuffer.updateLive(GLOBAL_zigzag.tLast, GLOBAL_zigzag.pLast, time, livePrice, COLOR_ZZ, showLive)
else if not _zzUsePolyline and not na(GLOBAL_zigzagBuffer.liveLine)
    // Ensure live line is cleaned up in LINES mode
    line.delete(GLOBAL_zigzagBuffer.liveLine)
    GLOBAL_zigzagBuffer.liveLine := na

f_htf_ohlc(string _htf) =>
    var htf_o  = 0.
    var htf_h  = 0.
    var htf_l  = 0.
    htf_c      = close
    
    var htf_ox = 0.
    var htf_hx = 0.
    var htf_lx = 0.
    var htf_cx = 0.

    if ta.change(time(_htf) !=0)
        htf_ox := htf_o
        htf_o  := open
        htf_hx := htf_h
        htf_h  := high
        htf_lx := htf_l
        htf_l  := low
        htf_cx := htf_c[1]
        htf_cx
    else
        htf_h := math.max(high, htf_h)
        htf_l := math.min(low , htf_l)
        htf_l

    [htf_ox, htf_hx, htf_lx, htf_cx, htf_o, htf_h, htf_l, htf_c]

[_, htf_h1, htf_l1, htf_c1, _, _, _, _] = f_htf_ohlc(htf)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PIVOT COORDINATE REFERENCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GLOBAL_indexMidPivot  = GLOBAL_cachedPivots.iMidPivot
GLOBAL_priceMidPivot  = GLOBAL_cachedPivots.pMidPivot
GLOBAL_indexEndBase   = GLOBAL_cachedPivots.iEndBase
GLOBAL_priceEndBase   = GLOBAL_cachedPivots.pEndBase
GLOBAL_indexMidPivot2 = GLOBAL_cachedPivots.GLOBAL_indexMidPivot2
GLOBAL_priceMidPivot2 = GLOBAL_cachedPivots.GLOBAL_priceMidPivot2
GLOBAL_indexEndBase2  = GLOBAL_cachedPivots.iEndBase2
GLOBAL_priceEndBase2  = GLOBAL_cachedPivots.pEndBase2

// PivotContext for confirmed pivots (uses cached values)
PivotContext GLOBAL_confirmedPivot = PivotContext.new(GLOBAL_cachedPivots.pMidPivot, GLOBAL_cachedPivots.pEndBase, INPUT_REVERSE)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROJECTION PIVOT INTEGRATION (for Statistical Position Engine)
// UDT: Uses GLOBAL_projection for state management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// When projection mode is active and we have a tentative pivot, use it for earlier Golden Pocket display
// The projection creates a "lookahead" pivot using the current bar as the new EndBase

// Update projection state when tentative pivot detected
if proj_tentative_high or proj_tentative_low
    GLOBAL_projection.activate(proj_tentative_high, proj_tentative_high ? low : high)
else if GLOBAL_zigzag.changed
    GLOBAL_projection.deactivate()

// Effective pivot values: use projection if active, otherwise confirmed
int   effIMidPivot = GLOBAL_projection.isActive() ? GLOBAL_projection.iMidPivot : GLOBAL_cachedPivots.iMidPivot
float effPMidPivot = GLOBAL_projection.isActive() ? GLOBAL_projection.pMidPivot : GLOBAL_cachedPivots.pMidPivot
int   effIEndBase = GLOBAL_projection.isActive() ? GLOBAL_projection.iEndBase : GLOBAL_cachedPivots.iEndBase
float effPEndBase = GLOBAL_projection.isActive() ? GLOBAL_projection.pEndBase : GLOBAL_cachedPivots.pEndBase

// PivotContext for effective pivots (includes projection if active)
PivotContext GLOBAL_effectivePivot = PivotContext.new(effPMidPivot, effPEndBase, INPUT_REVERSE)

f_crossingLevel(float _current, float _prev, float _level) =>
    (_level > _current and _level < _prev) or (_level < _current and _level > _prev)

if ta.change(time) != 0 and array.size(UI_linesBuffer) > 0
    for i = 1 to array.size(UI_linesBuffer) by 1
        line.delete(array.shift(UI_linesBuffer))

if ta.change(time) != 0 and array.size(UI_labelsBuffer) > 0
    for i = 1 to array.size(UI_labelsBuffer) by 1
        label.delete(array.shift(UI_labelsBuffer))

f_drawLineTZ(int _x1, float _y1, int _x2, float _y2, string _xloc, string _extend, color _c, string _s, int _w) =>
    if _x1 - bar_index < 500
        array.push(UI_linesBuffer, line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w))

f_drawLabelTZ(int _x, float _y, string _text, string _xloc, string _yloc, color _color, string _style, color _textcolor, string _size, string _textalign, string _tooltip) =>
    if _x - bar_index < 500
        array.push(UI_labelsBuffer, label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip))

f_drawLinePVT(int _x1, float _y1, int _x2, float _y2, string _xloc, string _extend, color _c, string _s, int _w) =>
    if _y1 > 0
        array.push(UI_linesBuffer, line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w))

f_drawLabelPVT(int _x, float _y, string _text, string _xloc, string _yloc, color _color, string _style, color _textcolor, string _size, string _textalign, string _tooltip) =>
    if _y > 0
        array.push(UI_labelsBuffer, label.new(_x, _y, INPUT_EXTEND_PVT or INPUT_LEVELS_PVT_POS == "Last Bar" ? _text + '\n\n' : _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip))

method draw(FibLevel this, int x1, float pMid, int x2, float pEnd, bool forceRedraw) =>
    if this.show and not na(x1) and not na(pMid) and not na(pEnd)
        pPivotDiff = math.abs(pMid - pEnd)
        price = 0.
        price := pEnd < pMid ? (INPUT_REVERSE ? pEnd : pMid) - (INPUT_REVERSE ? -1 : 1) * pPivotDiff * this.level : (INPUT_REVERSE ? pEnd : pMid) + (INPUT_REVERSE ? -1 : 1) * pPivotDiff * this.level
        price := math.round_to_mintick(price)
        
        if forceRedraw
            if not na(this.ln)
                line.delete(this.ln)
                this.ln := na
            if not na(this.lb)
                label.delete(this.lb)
                this.lb := na
            if price > 0
                this.ln := line.new(x1, price, x2, price, xloc.bar_index, INPUT_EXTEND_ER ? extend.both : extend.right, this.col, line.style_solid, this.level != 1 ? 1 : 2)
            if INPUT_LEVELS_LABEL != 'None' and price > 0
                bar_pos = INPUT_LEVELS_POS == "Last Bar" ? x2 : x1
                style_lbl = INPUT_LEVELS_POS == "Last Bar" ? label.style_label_left : label.style_label_right
                size_lbl = INPUT_LEVELS_SIZE == 'Small' ? size.small : size.normal
                // Build label text using array.join for >3 parts
                string lvlPart = INPUT_LEVELS_LABEL == 'Prices' ? '' : 'RET ' + str.tostring(this.level)
                string pricePart = (INPUT_LEVELS_LABEL == 'Levels + Prices' or INPUT_LEVELS_LABEL == 'Prices') ? ' (' + str.tostring(price, format.mintick) + ')' : ''
                text_str = lvlPart + pricePart
                tooltip_str = str.tostring(price, format.mintick)
                this.lb := label.new(bar_pos, price, INPUT_EXTEND_PVT or INPUT_EXTEND_ER or INPUT_LEVELS_POS == 'Last Bar' ? text_str + '\n\n' : text_str, xloc.bar_index, yloc.price, color.new(COLOR_FG_MAIN, 100), style_lbl, color.new(COLOR_FG_MAIN, 0), size_lbl, text.align_right, tooltip_str)
        else
            if not na(this.ln) and price > 0
                line.set_x2(this.ln, x2)
            if INPUT_LEVELS_POS == "Last Bar" and not na(this.lb) and price > 0
                label.set_x(this.lb, x2)
        
        GLOBAL_pivotLevelsLogRetracements.put(this.level, price)
        // Use pre-computed crossing result (computed globally for Pine v6 consistency)
        if this.crossed
            GLOBAL_pivotLevelsLogCrossed.put(this.level, price)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JSON SERIALIZATION HELPERS - Alert Event Payload Construction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_jsonFloat(float v) =>
    na(v) ? 'null' : str.tostring(v)

f_jsonInt(int v) =>
    na(v) ? 'null' : str.tostring(v)

f_jsonBool(bool v) =>
    v ? 'true' : 'false'

f_jsonStr(string v) =>
    na(v) ? 'null' : '"' + v + '"'

// Doc: Uses array.join() for efficient string assembly (TradingView Pine v6 best practice)
f_jsonEnvelope(string id, string eventType) =>
    // Pre-compute values to avoid multiple str.tostring calls
    string barIdx = str.tostring(bar_index)
    string lastBarIdx = str.tostring(last_bar_index)
    string timeStr = str.tostring(time)
    string timeCloseStr = str.tostring(time_close)
    string timeTradingdayStr = str.tostring(time_tradingday)
    
    // Build barstate JSON using array.from + join for many parts
    string barstate_json = array.join(array.from(
        '{"is_new":', f_jsonBool(barstate.isnew),
        ',"is_first":', f_jsonBool(barstate.isfirst),
        ',"is_last":', f_jsonBool(barstate.islast),
        ',"is_confirmed":', f_jsonBool(barstate.isconfirmed),
        ',"is_history":', f_jsonBool(barstate.ishistory), '}'), '')
    
    // Build ohlcv JSON
    string ohlcv_json = array.join(array.from(
        '{"open":', f_jsonFloat(open),
        ',"high":', f_jsonFloat(high),
        ',"low":', f_jsonFloat(low),
        ',"close":', f_jsonFloat(close),
        ',"volume":', f_jsonFloat(volume), '}'), '')
    
    // Build envelope using array.from + join
    array.join(array.from(
        '"schema_version":"', STATIC_ALERT_SCHEMA_VERSION,
        '","event_id":"', id,
        '","event_type":"', eventType,
        '","symbol":"', syminfo.tickerid,
        '","timeframe":"', timeframe.period,
        '","bar_index":', barIdx,
        ',"last_bar_index":', lastBarIdx,
        ',"time":', timeStr,
        ',"time_close":', timeCloseStr,
        ',"time_tradingday":', timeTradingdayStr,
        ',"barstate":', barstate_json,
        ',"ohlcv":', ohlcv_json), '')

f_jsonPivots(int confirmedMidBar, float confirmedMidPrice, int confirmedEndBar, float confirmedEndPrice, int effMidBar, float effMidPrice, int effEndBar, float effEndPrice, bool projActive) =>
    string result = '{"confirmed":{"mid_bar":' + f_jsonInt(confirmedMidBar) + ',"mid_price":' + f_jsonFloat(confirmedMidPrice) + ',"end_bar":' + f_jsonInt(confirmedEndBar) + ',"end_price":' + f_jsonFloat(confirmedEndPrice) + '},"effective":{"mid_bar":' + f_jsonInt(effMidBar) + ',"mid_price":' + f_jsonFloat(effMidPrice) + ',"end_bar":' + f_jsonInt(effEndBar) + ',"end_price":' + f_jsonFloat(effEndPrice) + ',"projection_active":' + f_jsonBool(projActive) + '}}'
    result

f_jsonSetup(bool isProjection, bool isLong, bool zoneTouched, bool stopLossHit, bool takeProfitHit) =>
    string state = isProjection ? 'projection' : 'confirmed'
    string labelPrefix = isProjection ? 'âš¡PROJ' : 'âœ“ACTIVE'
    bool isRecordable = not isProjection and zoneTouched
    string result = '{"state":"' + state + '","is_long":' + f_jsonBool(isLong) + ',"label_prefix":"' + labelPrefix + '","is_recordable":' + f_jsonBool(isRecordable) + ',"zone_touched":' + f_jsonBool(zoneTouched) + ',"sl_hit":' + f_jsonBool(stopLossHit) + ',"tp_hit":' + f_jsonBool(takeProfitHit) + '}'
    result

f_jsonZone(float rawTop, float rawBottom, float adjustedTop, float adjustedBottom, float bufferPercent, bool isInZone, bool isZoneEntry, float minimumDistancePercent) =>
    float rawMid = (rawTop + rawBottom) / 2
    float adjustedMid = (adjustedTop + adjustedBottom) / 2
    string result = '{"raw":{"top":' + f_jsonFloat(rawTop) + ',"bottom":' + f_jsonFloat(rawBottom) + ',"mid":' + f_jsonFloat(rawMid) + '},"adjusted":{"top":' + f_jsonFloat(adjustedTop) + ',"bottom":' + f_jsonFloat(adjustedBottom) + ',"mid":' + f_jsonFloat(adjustedMid) + ',"buffer_pct":' + f_jsonFloat(bufferPercent) + '},"status":{"in_zone":' + f_jsonBool(isInZone) + ',"zone_entry":' + f_jsonBool(isZoneEntry) + ',"min_distance_pct":' + f_jsonFloat(minimumDistancePercent) + '}}'
    result

f_jsonPosition(float entryMidPrice, float stopLossPrice, float takeProfitPrice, float takeProfitConservative, float takeProfitAggressive, bool useAggressiveTarget, float stopLossMultiplier, float averageTrueRange, float smartStopLossPrice) =>
    string takeProfitMode = useAggressiveTarget ? 'aggressive' : 'conservative'
    float risk = math.abs(entryMidPrice - stopLossPrice)
    float reward = math.abs(takeProfitPrice - entryMidPrice)
    float riskRewardRatio = risk > 0 ? reward / risk : 0.0
    string result = '{"entry_mid":' + f_jsonFloat(entryMidPrice) + ',"sl_price":' + f_jsonFloat(stopLossPrice) + ',"tp_price":' + f_jsonFloat(takeProfitPrice) + ',"tp_mode":"' + takeProfitMode + '","tp_cons":' + f_jsonFloat(takeProfitConservative) + ',"tp_aggr":' + f_jsonFloat(takeProfitAggressive) + ',"sl_mult":' + f_jsonFloat(stopLossMultiplier) + ',"atr":' + f_jsonFloat(averageTrueRange) + ',"risk_abs":' + f_jsonFloat(risk) + ',"reward_abs":' + f_jsonFloat(reward) + ',"rr":' + f_jsonFloat(riskRewardRatio) + ',"smart_sl":' + f_jsonFloat(smartStopLossPrice) + '}'
    result

f_jsonTimeDecay(bool enabled, int creationBar, int barsSince, int phase, float decayRate, bool expired) =>
    string status = phase >= 5 ? 'expired' : (phase >= 3 ? 'stale' : 'fresh')
    string result = '{"enabled":' + f_jsonBool(enabled) + ',"creation_bar":' + f_jsonInt(creationBar) + ',"bars_since":' + f_jsonInt(barsSince) + ',"phase":' + f_jsonInt(phase) + ',"decay_rate":' + f_jsonFloat(decayRate) + ',"status":"' + status + '","expired":' + f_jsonBool(expired) + '}'
    result

f_jsonRegime(RegimeState rs) =>
    string entropyStr = rs.entropyRegime == 0 ? 'ordered' : (rs.entropyRegime == 1 ? 'transition' : 'disordered')
    string hurstStr = rs.hurstRegime == 0 ? 'trend' : (rs.hurstRegime == 1 ? 'random' : 'mean_revert')
    string result = '{"entropy":{"value":' + f_jsonFloat(rs.entropyNorm) + ',"regime":"' + entropyStr + '"},"hurst":{"value":' + f_jsonFloat(rs.hurst) + ',"regime":"' + hurstStr + '"},"momentum":{"zscore":' + f_jsonFloat(rs.zscore) + ',"strong":' + f_jsonBool(rs.strongMomentum) + '}}'
    result

f_jsonLearning(LearningMetrics lm, int samples) =>
    string result = '{"enabled":true,"samples":' + f_jsonInt(samples) + ',"needs_recalc":' + f_jsonBool(lm.needsRecalculation) + ',"near_miss_count":' + f_jsonInt(lm.nearMissCount) + ',"total_setups":' + f_jsonInt(lm.totalSetups) + ',"win_rate":' + f_jsonFloat(lm.winRate) + ',"zone_buffer_pct":' + f_jsonFloat(lm.zoneBuffer) + ',"avg_mae":' + f_jsonFloat(lm.averageMaxAdverseExcursion) + ',"avg_mfe":' + f_jsonFloat(lm.averageMaxFavorableExcursion) + ',"avg_bars":' + f_jsonInt(lm.averageBarsHeld) + ',"sl_mult":' + f_jsonFloat(lm.stopLossMultiplier) + ',"confidence":' + f_jsonFloat(lm.confidence) + ',"profit_factor":' + f_jsonFloat(lm.profitFactor) + ',"expectancy":' + f_jsonFloat(lm.expectancy) + ',"wr_long":' + f_jsonFloat(lm.winRateLong) + ',"wr_short":' + f_jsonFloat(lm.winRateShort) + ',"wr_high_vol":' + f_jsonFloat(lm.winRateHighVolatility) + ',"wr_low_vol":' + f_jsonFloat(lm.winRateLowVolatility) + ',"div_edge":' + f_jsonFloat(lm.divergenceEdge) + ',"rsi_weight":' + f_jsonFloat(lm.rsiWeight) + ',"decay_rate":' + f_jsonFloat(lm.decayRate) + ',"bayes_mean":' + f_jsonFloat(lm.bayesianMean) + ',"bayes_lower":' + f_jsonFloat(lm.bayesianLowerBound) + ',"sortino":' + f_jsonFloat(lm.sortinoRatio) + ',"is_healthy":' + f_jsonBool(lm.isHealthy) + ',"win_streak":' + f_jsonInt(lm.winStreak) + ',"loss_streak":' + f_jsonInt(lm.lossStreak) + '}'
    result

f_jsonBacktest(BacktestStats bs) =>
    string result = '{"ready":' + f_jsonBool(bs.statsReady) + ',"total_trades":' + f_jsonInt(bs.totalTrades) + ',"win_rate":' + f_jsonFloat(bs.winRate) + ',"winning_trades":' + f_jsonInt(bs.winningTrades) + ',"avg_winning_mae":' + f_jsonFloat(bs.avgWinningMae) + ',"avg_losing_mae":' + f_jsonFloat(bs.avgLosingMae) + ',"smart_sl_offset":' + f_jsonFloat(bs.smartSlOffset) + ',"low_confidence":' + f_jsonBool(bs.lowConfidence) + '}'
    result

f_jsonMonteCarlo(LearningMetrics lm) =>
    string result = '{"original_dd":' + f_jsonFloat(lm.monteCarloOriginalDrawdown) + ',"mean_shuffled_dd":' + f_jsonFloat(lm.monteCarloMeanShuffledDrawdown) + ',"p_value":' + f_jsonFloat(lm.monteCarloPValue) + ',"sims_run":' + f_jsonInt(lm.monteCarloSimulationsRun) + ',"significant":' + f_jsonBool(lm.isMonteCarloSignificant) + '}'
    result

f_getAlertMessageFull(string alertId, string eventType, bool isProjection, bool isLong, bool zoneTouched, bool stopLossHit, bool takeProfitHit, float rawZoneTop, float rawZoneBottom, float adjustedZoneTop, float adjustedZoneBottom, float bufferPercent, bool isInZone, bool isZoneEntry, float minimumDistance, float stopLossPrice, float takeProfitPrice, float takeProfitConservative, float takeProfitAggressive, bool useAggressiveTarget, float stopLossMultiplier, float averageTrueRange, float smartStopLoss, int creationBar, int barsSinceCreation, int timePhase, float decayRate, bool isExpired) =>
    // PerfController: Fast preset can skip full JSON serialization for performance
    if perf_skipAlertJson()
        // Minimal JSON payload - just ID and event type for alert routing
        '{"id":"' + alertId + '","event":"' + eventType + '","minimal":true}'
    else
        float entryMidPrice = (adjustedZoneTop + adjustedZoneBottom) / 2
        
        // Build envelope
        string envelope = f_jsonEnvelope(alertId, eventType)
        
        // Build component JSONs
        string pivots_json = f_jsonPivots(
            GLOBAL_cachedPivots.iMidPivot, GLOBAL_cachedPivots.pMidPivot,
            GLOBAL_cachedPivots.iEndBase, GLOBAL_cachedPivots.pEndBase,
            GLOBAL_projection.isActive() ? GLOBAL_projection.iMidPivot : GLOBAL_cachedPivots.iMidPivot,
            GLOBAL_projection.isActive() ? GLOBAL_projection.pMidPivot : GLOBAL_cachedPivots.pMidPivot,
            GLOBAL_projection.isActive() ? bar_index : GLOBAL_cachedPivots.iEndBase,
            GLOBAL_projection.isActive() ? GLOBAL_projection.pEndBase : GLOBAL_cachedPivots.pEndBase,
            GLOBAL_projection.isActive())
        string setup_json = f_jsonSetup(isProjection, isLong, zoneTouched, stopLossHit, takeProfitHit)
        string zone_json = f_jsonZone(rawZoneTop, rawZoneBottom, adjustedZoneTop, adjustedZoneBottom, bufferPercent, isInZone, isZoneEntry, minimumDistance)
        string position_json = f_jsonPosition(entryMidPrice, stopLossPrice, takeProfitPrice, takeProfitConservative, takeProfitAggressive, useAggressiveTarget, stopLossMultiplier, averageTrueRange, smartStopLoss)
        string time_decay_json = f_jsonTimeDecay(INPUT_POS_TIME_DECAY, creationBar, barsSinceCreation, timePhase, decayRate, isExpired)
        string regime_json = f_jsonRegime(GLOBAL_regime)
        string learning_json = f_jsonLearning(GLOBAL_learning, GLOBAL_setupHistory.size())
        string backtest_json = f_jsonBacktest(GLOBAL_backtest.stats)
        string mc_json = f_jsonMonteCarlo(GLOBAL_learning)
        string retracements_json = GLOBAL_pivotLevelsLogRetracements.toJson()
        string crossed_json = GLOBAL_pivotLevelsLogCrossed.toJson()
        
        // Assemble full JSON using array.join for efficient concatenation
        array.join(array.from(
            '{', envelope,
            ',"pivots":', pivots_json,
            ',"setup":', setup_json,
            ',"zone":', zone_json,
            ',"position":', position_json,
            ',"time_decay":', time_decay_json,
            ',"regime":', regime_json,
            ',"learning":', learning_json,
            ',"backtest":', backtest_json,
            ',"monte_carlo":', mc_json,
            ',"retracements":', retracements_json,
            ',"crossed_retracements":', crossed_json,
            ',"confluence":{"exhaust_vol":', f_jsonBool(exhaustVol),
            ',"high_volatility":', f_jsonBool(highVolatility), '}}'), '')

// Doc: Uses array.join for efficient string assembly (TradingView Pine v6 best practice)
f_getAlertMessage(string id) =>
    // Pre-compute numeric conversions once
    string barIdxStr = str.tostring(bar_index)
    string lastBarIdxStr = str.tostring(last_bar_index)
    string timeTradingdayStr = str.tostring(time_tradingday)
    string timeCloseStr = str.tostring(time_close)
    string openStr = str.tostring(open)
    string highStr = str.tostring(high)
    string lowStr = str.tostring(low)
    string closeStr = str.tostring(close)
    string hl2Str = str.tostring(hl2)
    string hlc3Str = str.tostring(hlc3)
    string hlcc4Str = str.tostring(hlcc4)
    string ohlc4Str = str.tostring(ohlc4)
    string volumeStr = str.tostring(volume)
    
    // Build barstate JSON using array.join
    string barstate_json = array.join(array.from(
        '{"is_new":', f_jsonBool(barstate.isnew),
        ',"is_first":', f_jsonBool(barstate.isfirst),
        ',"is_last":', f_jsonBool(barstate.islast),
        ',"is_confirmed":', f_jsonBool(barstate.isconfirmed),
        ',"is_history":', f_jsonBool(barstate.ishistory), '}'), '')
    
    // Build ohlcv JSON using array.join
    string ohlcv_json = array.join(array.from(
        '{"open":', openStr,
        ',"high":', highStr,
        ',"low":', lowStr,
        ',"close":', closeStr,
        ',"hl2":', hl2Str,
        ',"hlc3":', hlc3Str,
        ',"hlcc4":', hlcc4Str,
        ',"ohlc4":', ohlc4Str,
        ',"volume":', volumeStr, '}'), '')
    
    // Build base JSON using array.join
    string base_json = array.join(array.from(
        '"schema_version":"', STATIC_ALERT_SCHEMA_VERSION,
        '","event_id":"', id,
        '","symbol":"', syminfo.tickerid,
        '","timeframe":"', timeframe.period,
        '","bar_index":', barIdxStr,
        ',"last_bar_index":', lastBarIdxStr,
        ',"time_tradingday":', timeTradingdayStr,
        ',"time_close":', timeCloseStr,
        ',"session_is_first_bar":', f_jsonBool(session.isfirstbar),
        ',"barstate":', barstate_json,
        ',"ohlcv":', ohlcv_json), '')
    
    string log = ''
    if id == STATIC_ALERT_ID_UPDATE
        log := array.join(array.from('{', base_json, ',"retracements":', GLOBAL_pivotLevelsLogRetracements.toJson(), ',"crossed_retracements":', GLOBAL_pivotLevelsLogCrossed.toJson(), '}'), '')
    if id == STATIC_ALERT_ID_EXHAUSTION
        log := array.join(array.from('{', base_json, ',"bull_candle":', f_jsonBool(bullCandle), ',"bear_candle":', f_jsonBool(bearCandle), ',"exhaust_vol":', f_jsonBool(exhaustVol), '}'), '')
    if id == STATIC_ALERT_ID_VOLATILITY
        log := array.join(array.from('{', base_json, ',"bull_candle":', f_jsonBool(bullCandle), ',"bear_candle":', f_jsonBool(bearCandle), ',"high_volatility":', f_jsonBool(highVolatility), '}'), '')
    if id == STATIC_ALERT_ID_CROSSING
        log := array.join(array.from('{', base_json, ',"crossed_retracements":', GLOBAL_pivotLevelsLogCrossed.toJson(), '}'), '')
    log

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOT EXECUTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if INPUT_SHOW_FIB_TIME
    t_lineTZ_style = line.style_dotted
    t_lineTZ_width = 1
    t_lineTZ_color = color.new(COLOR_FG_MAIN, 50)
    reference = math.round(GLOBAL_indexEndBase2 - GLOBAL_indexMidPivot2)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 - reference        , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 - reference       , _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2                    , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2                   , _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=t_lineTZ_color, _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference        , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference       , _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=t_lineTZ_color, _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference * 2    , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference * 2 , _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference * 3    , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference * 3 , _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference * 5    , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference * 5 , _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference * 8    , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference * 8 , _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference * 13   , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference * 13, _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference * 21   , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference * 21, _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference * 34   , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference * 34, _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference * 55   , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference * 55, _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=GLOBAL_indexMidPivot2 + reference * 89   , _y1=GLOBAL_priceEndBase2, _x2=GLOBAL_indexMidPivot2 + reference * 89, _y2=GLOBAL_priceMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)

    if INPUT_FIB_TZ_LABEL
        t_labelTZ_background = color.new(COLOR_FG_MAIN, 100)
        t_labelTZ_text_align = text.align_center
        t_labelTZ_size = size.small
        t_labelTZ_color = color.new(COLOR_FG_MAIN, 0)
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * -1, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='-1', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 0 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='0' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=t_labelTZ_color, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 1 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='1' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=t_labelTZ_color, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 2 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='2' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 3 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='3' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 5 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='5' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 8 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='8' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 13, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='13', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 21, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='21', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 34, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='34', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 55, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='55', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=GLOBAL_indexMidPivot2 + reference * 89, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2) : math.max(GLOBAL_priceEndBase2, GLOBAL_priceMidPivot2), _text='89', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=UI_fibTzLabelPos, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CACHED COORDINATE INITIALIZATION AND UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if not na(GLOBAL_zigzag.ln)
    currentX1 = line.get_x1(GLOBAL_zigzag.ln)
    currentY1 = line.get_y1(GLOBAL_zigzag.ln)
    currentX2 = line.get_x2(GLOBAL_zigzag.ln)
    currentY2 = line.get_y2(GLOBAL_zigzag.ln)
    
    if na(GLOBAL_cachedPivots.iMidPivot) or GLOBAL_zigzag.changed
        GLOBAL_cachedPivots.iMidPivot := GLOBAL_zigzag.iPrevPivot != 0 ? GLOBAL_zigzag.iPrevPivot : currentX1
        GLOBAL_cachedPivots.pMidPivot := GLOBAL_zigzag.pPrevPivot != 0 ? GLOBAL_zigzag.pPrevPivot : currentY1
        GLOBAL_cachedPivots.iEndBase := GLOBAL_zigzag.iLastPivot != 0 ? GLOBAL_zigzag.iLastPivot : currentX2
        GLOBAL_cachedPivots.pEndBase := GLOBAL_zigzag.pLastPivot != 0 ? GLOBAL_zigzag.pLastPivot : currentY2
        GLOBAL_cachedPivots.GLOBAL_indexMidPivot2 := GLOBAL_zigzag.iPrevPivot != 0 ? GLOBAL_zigzag.iPrevPivot : currentX1
        GLOBAL_cachedPivots.GLOBAL_priceMidPivot2 := GLOBAL_zigzag.pPrevPivot != 0 ? GLOBAL_zigzag.pPrevPivot : currentY1
        GLOBAL_cachedPivots.iEndBase2 := GLOBAL_zigzag.iLastPivot != 0 ? GLOBAL_zigzag.iLastPivot : currentX2
        GLOBAL_cachedPivots.pEndBase2 := GLOBAL_zigzag.pLastPivot != 0 ? GLOBAL_zigzag.pLastPivot : currentY2

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRE-COMPUTED RSI DIVERGENCE VALUES (Pine v6 - must be called on every bar)
// These ta.valuewhen calls capture RSI and price at pivot changes for divergence detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float GLOBAL_rsi_at_pivot = ta.valuewhen(GLOBAL_zigzag.changed, GLOBAL_regime.rsi, 0)
float GLOBAL_priceAtPivot = ta.valuewhen(GLOBAL_zigzag.changed, close, 0)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIBONACCI LEVEL DRAWING (Pine v6 - all functions called unconditionally)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pre-compute crossing detection for all fib levels (Pine v6 - must call on every bar)
// Compute previous close ONCE outside loop to avoid history reference inside loop
float prev_close = close[1]
for lvl in BUF_fibLevels
    // Always compute the price for this level (even if not shown)
    float pPivotDiff = math.abs(nz(GLOBAL_cachedPivots.pMidPivot) - nz(GLOBAL_cachedPivots.pEndBase))
    float lvl_price = nz(GLOBAL_cachedPivots.pEndBase) < nz(GLOBAL_cachedPivots.pMidPivot) ? 
         (INPUT_REVERSE ? nz(GLOBAL_cachedPivots.pEndBase) : nz(GLOBAL_cachedPivots.pMidPivot)) - (INPUT_REVERSE ? -1 : 1) * pPivotDiff * lvl.level : 
         (INPUT_REVERSE ? nz(GLOBAL_cachedPivots.pEndBase) : nz(GLOBAL_cachedPivots.pMidPivot)) + (INPUT_REVERSE ? -1 : 1) * pPivotDiff * lvl.level
    lvl_price := math.round_to_mintick(lvl_price)
    // Call f_crossingLevel with pre-computed prev_close (no history reference in loop)
    lvl.crossed := f_crossingLevel(close, prev_close, lvl_price)

// Determine redraw need unconditionally
bool needsFullRedraw = GLOBAL_zigzag.changed or (BUF_fibLevels.size() > 0 ? na(array.get(BUF_fibLevels, 0).ln) : false)
bool canDrawFibs = not na(GLOBAL_cachedPivots.iMidPivot) and not na(GLOBAL_cachedPivots.pEndBase)

// Always call draw method on every bar (Pine v6 - methods must be called consistently)
for lvl in BUF_fibLevels
    lvl.draw(GLOBAL_cachedPivots.iMidPivot, GLOBAL_cachedPivots.pMidPivot, bar_index, GLOBAL_cachedPivots.pEndBase, needsFullRedraw and canDrawFibs)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKTESTING ENGINE - Historical Trade Simulation Loop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This logic runs on EVERY bar to:
// 1. Manage the current simulation (GLOBAL_backtest.current) through its lifecycle
// 2. Spawn new trades when ZigZag pivots are confirmed
// 3. Build GLOBAL_backtest.history with completed trades for learning analysis
// Uses RAW Fib levels (GLOBAL_cachedPivots.pMidPivot, GLOBAL_cachedPivots.pEndBase) - no learned adjustments

// Calculate RAW Golden Pocket levels using confirmed pivots only
float raw_price_618 = GLOBAL_confirmedPivot.getLevel(FIB_GOLDEN_RATIO)
float raw_price_65  = GLOBAL_confirmedPivot.getLevel(FIB_GOLDEN_POCKET_H)
float raw_zone_top = math.max(raw_price_618, raw_price_65)
float raw_zone_btm = math.min(raw_price_618, raw_price_65)
float raw_entry_mid = (raw_zone_top + raw_zone_btm) / 2

// Determine direction from RAW confirmed pivots (not projections)
// EndBase < MidPivot = downswing completed = LONG expected
bool raw_is_long = GLOBAL_cachedPivots.pEndBase < GLOBAL_cachedPivots.pMidPivot
int raw_direction = raw_is_long ? 1 : -1

// Calculate RAW SL/TP using default multipliers (pure data, no learning)
float raw_atr = nz(ta.atr(INPUT_ATR_LENGTH), 1.0)
float raw_sl_buffer = raw_atr * INPUT_POS_SL_MULT
float raw_tp_target = GLOBAL_cachedPivots.pMidPivot  // Conservative TP = back to MidPivot (swing start)

float raw_sl_price = raw_is_long ? GLOBAL_cachedPivots.pEndBase - raw_sl_buffer : GLOBAL_cachedPivots.pEndBase + raw_sl_buffer
float raw_tp_price = raw_tp_target

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PART A: Spawning New Trades (FIRST - before management)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Spawn BEFORE management (new trades skip processing on spawn bar)
// Only spawn when:
// 1. GLOBAL_zigzag.changed is true (ZigZag confirmed)
// 2. GLOBAL_backtest.current is na (not already in a simulation)
// 3. We have valid cached pivot data
// 4. Entropy regime allows trading (ORDERED or TRANSITION)
// 5. Hurst regime allows trading (if blocking random is enabled)
// 6. Momentum is statistically significant (if Z-score filter enabled)
// 7. External context valid (if enabled) - non-breaking: extOk=true when disabled
// Condition ordering: lazy evaluation (cheap â†’ expensive)
//       1. GLOBAL_zigzag.changed (cheap bool)
//       2. na(GLOBAL_backtest.current) (cheap na check)
//       3. not na(pivots) (cheap na checks)
//       4. Regime gates (pre-computed bools, no function calls)
bool _spawnGatesPassed = GLOBAL_zigzag.changed and na(GLOBAL_backtest.current) and not na(GLOBAL_cachedPivots.iMidPivot) and not na(GLOBAL_cachedPivots.pEndBase)
bool _regimeGatesPassed = GLOBAL_regime.entropyOk and GLOBAL_regime.hurstOk and GLOBAL_regime.momentumOk and GLOBAL_extContext.extOk
if GLOBAL_zigzag.changed
    DBG_counterSpawnAttempts += 1
if _spawnGatesPassed and _regimeGatesPassed
    // Build initial state_mask: PENDING + direction flag (using arithmetic for raw int)
    int init_state = STATIC_FLAG_PENDING + (raw_is_long ? STATIC_FLAG_IS_LONG : 0)
    
    // Create a new BacktestTrade with RAW levels
    GLOBAL_backtest.current := BacktestTrade.new(
        GLOBAL_cachedPivots.iMidPivot,       // id: Pivot bar index
        init_state,            // state_mask: STATIC_FLAG_PENDING + STATIC_FLAG_IS_LONG if long
        raw_entry_mid,         // entry_price: mid of Golden Pocket (updated on activation)
        raw_zone_top,          // entry_top: zone upper boundary
        raw_zone_btm,          // entry_btm: zone lower boundary
        raw_sl_price,          // sl_price: initial SL
        raw_tp_price,          // tp_price: initial TP
        0.0,                   // mae: starts at 0
        0.0,                   // mfe: starts at 0
        na,                    // entry_bar: not yet entered
        na                     // exit_bar: not yet exited
    )
else if GLOBAL_zigzag.changed and not _regimeGatesPassed
    DBG_counterSpawnBlocked += 1
    
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PART B: Managing the Current Simulation (runs every bar AFTER spawn)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Skip processing on spawn bar (GLOBAL_zigzag.changed)
// This prevents the trade from being immediately killed or activated on spawn bar
bool skip_this_bar = GLOBAL_zigzag.changed  // Don't process newly spawned trades on their creation bar

if not na(GLOBAL_backtest.current) and not skip_this_bar
    bool sim_is_long = GLOBAL_backtest.current.hasFlag(STATIC_FLAG_IS_LONG)
    
    // PENDING: Waiting for price to touch the Golden Pocket zone
    if GLOBAL_backtest.current.hasFlag(STATIC_FLAG_PENDING)
        bool zone_touched = false
        bool sl_breached_before_entry = false
        
        if sim_is_long  // LONG: waiting for price to dip INTO zone
            zone_touched := low <= GLOBAL_backtest.current.entry_top and high >= GLOBAL_backtest.current.entry_btm
            sl_breached_before_entry := low <= GLOBAL_backtest.current.sl_price and not zone_touched
        else  // SHORT: waiting for price to rise INTO zone
            zone_touched := high >= GLOBAL_backtest.current.entry_btm and low <= GLOBAL_backtest.current.entry_top
            sl_breached_before_entry := high >= GLOBAL_backtest.current.sl_price and not zone_touched
        
        // Handle SL breach before entry (trade invalidated)
        if sl_breached_before_entry
            GLOBAL_backtest.current := na
        // If zone touched, activate the trade (transition: PENDING -> ACTIVE)
        else if zone_touched
            GLOBAL_backtest.current.setLifecycle(STATIC_FLAG_ACTIVE).setFlag(STATIC_FLAG_ZONE_TOUCHED)
            GLOBAL_backtest.current.entry_bar := bar_index
            GLOBAL_backtest.current.entry_price := sim_is_long ? GLOBAL_backtest.current.entry_top : GLOBAL_backtest.current.entry_btm
            GLOBAL_backtest.current.mae := 0.0
            GLOBAL_backtest.current.mfe := 0.0
    
    // ACTIVE: In trade, tracking MAE/MFE and checking for exit
    else if GLOBAL_backtest.current.hasFlag(STATIC_FLAG_ACTIVE)
        // Update MAE (Max Adverse Excursion) - worst price against us
        if sim_is_long  // LONG: adverse = price going DOWN
            float adverse = GLOBAL_backtest.current.entry_price - low
            GLOBAL_backtest.current.mae := math.max(GLOBAL_backtest.current.mae, adverse)
        else  // SHORT: adverse = price going UP
            float adverse = high - GLOBAL_backtest.current.entry_price
            GLOBAL_backtest.current.mae := math.max(GLOBAL_backtest.current.mae, adverse)
        
        // Update MFE (Max Favorable Excursion) - best price in our favor
        if sim_is_long  // LONG: favorable = price going UP
            float favorable = high - GLOBAL_backtest.current.entry_price
            GLOBAL_backtest.current.mfe := math.max(GLOBAL_backtest.current.mfe, favorable)
        else  // SHORT: favorable = price going DOWN
            float favorable = GLOBAL_backtest.current.entry_price - low
            GLOBAL_backtest.current.mfe := math.max(GLOBAL_backtest.current.mfe, favorable)
        
        // Check for exit conditions (HTF level - used for initial screening)
        bool sl_hit = sim_is_long ? (low <= GLOBAL_backtest.current.sl_price) : (high >= GLOBAL_backtest.current.sl_price)
        bool tp_hit = sim_is_long ? (high >= GLOBAL_backtest.current.tp_price) : (low <= GLOBAL_backtest.current.tp_price)
        
        // Handle exits (transition: ACTIVE -> CLOSED)
        if sl_hit or tp_hit
            GLOBAL_backtest.current.setLifecycle(STATIC_FLAG_CLOSED)
            GLOBAL_backtest.current.exit_bar := bar_index
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // INTRABAR PRECISION: Resolve TP/SL order chronologically using LTF data
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            bool trade_won = false
            bool used_ltf_resolution = false
            int ltf_hit_idx = -1
            
            if sl_hit and tp_hit
                // Both TP and SL hit in same HTF bar - need to determine which came first
                if INPUT_INTRABAR_ENABLED and array.size(REQ_ltfHighs) > 0
                    // Use intrabar resolution for chronological determination
                    bool conservative = INPUT_INTRABAR_TIEBREAK == "Conservative"
                    [ltf_outcome, ltf_resolved, hit_idx] = f_resolveIntrabar(REQ_ltfHighs, REQ_ltfLows, sim_is_long, GLOBAL_backtest.current.sl_price, GLOBAL_backtest.current.tp_price, conservative)
                    
                    if ltf_resolved
                        trade_won := ltf_outcome == 1  // 1 = TP first, -1 = SL first
                        used_ltf_resolution := true
                        ltf_hit_idx := hit_idx
                        GLOBAL_backtest.current.setFlag(STATIC_FLAG_LTF_RESOLVED)
                    else
                        // LTF data available but no decisive outcome - use HTF fallback
                        float dist_to_sl = math.abs(open - GLOBAL_backtest.current.sl_price)
                        float dist_to_tp = math.abs(open - GLOBAL_backtest.current.tp_price)
                        trade_won := dist_to_tp < dist_to_sl * 0.5
                else
                    // Intrabar disabled or no LTF data - use HTF heuristic (fallback per FR-7)
                    float dist_to_sl = math.abs(open - GLOBAL_backtest.current.sl_price)
                    float dist_to_tp = math.abs(open - GLOBAL_backtest.current.tp_price)
                    trade_won := dist_to_tp < dist_to_sl * 0.5
            else
                // Only one level hit - straightforward resolution
                trade_won := tp_hit
            
            // Set outcome flags using setOutcome method for mutual exclusion (SL_HIT xor TP_HIT)
            if trade_won
                GLOBAL_backtest.current.setOutcome(STATIC_FLAG_TP_HIT).setFlag(STATIC_FLAG_WON)
            else
                GLOBAL_backtest.current.setOutcome(STATIC_FLAG_SL_HIT)
            
            // Push completed trade to GLOBAL_backtest.history
            array.push(GLOBAL_backtest.history, GLOBAL_backtest.current)
            
            
            // Clear current simulation
            GLOBAL_backtest.current := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTIMIZATION ENGINE - Calculate Stats from Backtest History
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if barstate.islast and array.size(GLOBAL_backtest.history) > 0 and not GLOBAL_backtest.stats.statsReady
    int total = array.size(GLOBAL_backtest.history)
    int wins = 0
    float sum_winning_mae = 0.0
    float sum_losing_mae = 0.0
    int losing_count = 0
    
    // Loop through all completed trades
    for i = 0 to total - 1
        BacktestTrade trade = array.get(GLOBAL_backtest.history, i)
        if trade.hasFlag(STATIC_FLAG_WON)
            wins += 1
            sum_winning_mae += trade.mae
        else
            losing_count += 1
            sum_losing_mae += trade.mae
    
    // Calculate statistics
    GLOBAL_backtest.stats.totalTrades := total
    GLOBAL_backtest.stats.winningTrades := wins
    GLOBAL_backtest.stats.winRate := total > 0 ? float(wins) / float(total) : 0.0
    GLOBAL_backtest.stats.avgWinningMae := wins > 0 ? sum_winning_mae / float(wins) : 0.0
    GLOBAL_backtest.stats.avgLosingMae := losing_count > 0 ? sum_losing_mae / float(losing_count) : 0.0
    
    // Smart SL offset: Avg Winning MAE * 1.1 (give 10% buffer beyond typical drawdown)
    GLOBAL_backtest.stats.smartSlOffset := GLOBAL_backtest.stats.avgWinningMae * 1.1
    
    // Confidence flag: Low confidence if win rate < 40%
    GLOBAL_backtest.stats.lowConfidence := GLOBAL_backtest.stats.winRate < 0.40
    
    // Mark stats as ready
    GLOBAL_backtest.stats.statsReady := true
    
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATISTICAL POSITION ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// UDT: All position visual elements consolidated (see PositionVisual type definition above)
var PositionVisual GLOBAL_posVisual = PositionVisual.new()

// Use effective pivots (projection if active, otherwise confirmed)
if INPUT_SHOW_POS and not na(effIMidPivot) and not na(effPEndBase)
    // Determine if this is a projection update (for visual feedback)
    bool isProjection = GLOBAL_projection.isActive()
    
    // When EndBase > MidPivot, the last swing was UP (upswing completed), so we expect a retracement DOWN into the pocket â†’ SHORT
    // When EndBase < MidPivot, the last swing was DOWN (downswing completed), so we expect a retracement UP into the pocket â†’ LONG
    // GLOBAL_effectivePivot uses effective pivots (projection or confirmed)
    bool is_long_setup = effPEndBase < effPMidPivot  // EndBase < MidPivot = downswing completed = LONG retracement expected
    float price_618 = GLOBAL_effectivePivot.getLevel(FIB_GOLDEN_RATIO)
    float price_65  = GLOBAL_effectivePivot.getLevel(FIB_GOLDEN_POCKET_H)
    
    // Reuse global ATR calculation (i_weightedATR = ta.atr(INPUT_ATR_LENGTH) * INPUT_ATR_MULT)
    float current_atr = GLOBAL_regime.rawAtr
    
    // Dynamic SL: Use ATR percentile to scale SL buffer based on volatility regime
    // Use global pre-computed atr_percentile (C-optimized, called on every bar)
    float atr_percentile = GLOBAL_regime.atrPercentile  // 0 = lowest vol, 100 = highest vol
    // Scale multiplier: at 50th percentile = base mult, at 0 = -50%, at 100 = +50%
    float dynamic_scale = INPUT_POS_SL_DYNAMIC ? (1 + (atr_percentile - 50) / 100) : 1.0
    
    // Use learned SL multiplier if enabled and sufficient data
    // GLOBAL_learning.stopLossMultiplier is computed from: avg MAE of winning trades + STATIC_SL_BUFFER_ATR buffer
    float base_sl_mult = INPUT_POS_SL_MULT
    bool use_learned = INPUT_USE_LEARNED_SL and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_SL and GLOBAL_learning.stopLossMultiplier > 0
    if use_learned
        base_sl_mult := GLOBAL_learning.stopLossMultiplier
        // Validation: if losing trades had larger MAE, consider widening SL
        // Only if losing MAE is significantly larger than winning MAE (indicating stops too tight)
        if GLOBAL_learning.losingMaxAdverseExcursion > 0 and GLOBAL_learning.losingMaxAdverseExcursion > GLOBAL_learning.averageMaxAdverseExcursion * STATIC_SL_LOSING_MAE_FACTOR
            // Blend: use midpoint between learned SL and losing MAE to reduce premature stops
            base_sl_mult := (GLOBAL_learning.stopLossMultiplier + GLOBAL_learning.losingMaxAdverseExcursion) / 2
    float effective_sl_mult = base_sl_mult * dynamic_scale
    
    // SL is placed beyond the swing extreme (EndBase) + ATR buffer
    // LONG: EndBase is swing LOW, SL goes below it
    // SHORT: EndBase is swing HIGH, SL goes above it
    float sl_price = is_long_setup ? effPEndBase - (current_atr * effective_sl_mult) : effPEndBase + (current_atr * effective_sl_mult)
    
    // Calculate both TP prices for comparison learning
    // TP targets: Conservative = back to MidPivot (start of swing), Aggressive = 1.272 extension beyond MidPivot
    // LONG: TP is ABOVE entry (toward and beyond MidPivot which is the HIGH)
    // SHORT: TP is BELOW entry (toward and beyond MidPivot which is the LOW)
    float tp_conservative = effPMidPivot
    // Extension goes BEYOND MidPivot (not calculated by f_get_level_eff which only does retracements)
    float swing_range = math.abs(effPMidPivot - effPEndBase)
    float extension_amount = swing_range * (FIB_EXTENSION_1272 - 1.0)  // The amount beyond 100%
    float tp_aggressive = is_long_setup ? effPMidPivot + extension_amount : effPMidPivot - extension_amount
    
    // Calculate distances for MFE comparison
    float conservativeDistance = math.abs(tp_conservative - (price_618 + price_65) / 2)
    float aggressiveDistance = math.abs(tp_aggressive - (price_618 + price_65) / 2)
    float mfeDistance = GLOBAL_learning.averageMaxFavorableExcursion * current_atr  // MFE converted to price distance
    
    // Determine which TP mode to use (can be learned)
    bool use_aggressive_tp = INPUT_POS_TP_MODE == 'Aggressive'
    bool has_learned_tp = INPUT_LEARN_TP and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_learned_tp
        // Prefer learned EV-based decision if available
        if GLOBAL_learning.aggressiveExpectedValue != 0 or GLOBAL_learning.conservativeExpectedValue != 0
            use_aggressive_tp := GLOBAL_learning.useTakeProfitAggressive
        // Fallback: if avg MFE exceeds conservative TP distance, use aggressive
        else if GLOBAL_learning.averageMaxFavorableExcursion > 0 and mfeDistance > conservativeDistance * 1.2
            use_aggressive_tp := true
    float tp_price = use_aggressive_tp ? tp_aggressive : tp_conservative
    
    // Zone boundaries
    float box_top = math.max(price_618, price_65)
    float box_bottom = math.min(price_618, price_65)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LEARNING ENGINE: Near-miss detection and adaptive zone buffer
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Calculate adaptive zone buffer based on historical near-misses
    float zone_width = box_top - box_bottom
    // Start with previously learned buffer if available, otherwise base
    float adaptive_buffer = GLOBAL_learning.zoneBuffer > 0 ? GLOBAL_learning.zoneBuffer : INPUT_ZONE_BUFFER_BASE
    
    if INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_BUFFER
        // Count near-misses in recent history
        int near_misses = 0
        int total_valid = 0
        int max_check = math.min(INPUT_LEARNING_SAMPLES - 1, GLOBAL_setupHistory.size() - 1)
        for i = 0 to max_check
            SetupRecord rec = GLOBAL_setupHistory.get(i)
            if na(rec)
                continue
            if rec.closest_approach > 0 and rec.closest_approach < INPUT_NEAR_MISS_THRESH and not rec.hasFlag(STATIC_FLAG_ZONE_TOUCHED)
                near_misses += 1
            total_valid += 1
        
        // If >STATIC_NEAR_MISS_RATE_THRESH are near-misses, expand zone proportionally
        float miss_rate = total_valid > 0 ? float(near_misses) / float(total_valid) : 0.0
        // Scale buffer: miss_rate * multiplier, capped at max
        float learned_buffer = 0.0
        if miss_rate > STATIC_NEAR_MISS_RATE_THRESH
            learned_buffer := math.min(miss_rate * STATIC_NEAR_MISS_BUFFER_MULT, STATIC_NEAR_MISS_BUFFER_MAX)
        // Also consider average near-miss distance to determine buffer size
        // If near-misses are very close, expand more aggressively
        if near_misses > 0
            float avg_approach = 0.0
            int approach_count = 0
            for j = 0 to max_check
                SetupRecord rec2 = GLOBAL_setupHistory.get(j)
                if not na(rec2) and rec2.closest_approach > 0 and rec2.closest_approach < INPUT_NEAR_MISS_THRESH and not rec2.hasFlag(STATIC_FLAG_ZONE_TOUCHED)
                    avg_approach += rec2.closest_approach
                    approach_count += 1
            if approach_count > 0
                avg_approach := avg_approach / float(approach_count)
                // If avg near-miss is < STATIC_NEAR_MISS_CLOSE_THRESH, add extra buffer
                if avg_approach < STATIC_NEAR_MISS_CLOSE_THRESH
                    learned_buffer += (STATIC_NEAR_MISS_CLOSE_THRESH - avg_approach) * 10  // Up to +3% extra
        adaptive_buffer := math.max(INPUT_ZONE_BUFFER_BASE, learned_buffer)
        GLOBAL_learning.zoneBuffer := adaptive_buffer
        GLOBAL_learning.nearMissCount := near_misses
        GLOBAL_learning.totalSetups := total_valid
    
    // Apply adaptive buffer to zone boundaries
    float buffer_amount = zone_width * (adaptive_buffer / 100)
    float adjusted_box_top = box_top + buffer_amount
    float adjusted_box_bottom = box_bottom - buffer_amount
    
    // DEBUG: Log learning engine values on bar confirmation
    // Near-miss detection: how close did price get to the zone?
    // Distance is positive when price is OUTSIDE the zone, 0 or negative when INSIDE
    float dist_to_zone_pct = 0.0
    bool price_outside_zone = not (low <= adjusted_box_top and high >= adjusted_box_bottom)
    
    if price_outside_zone
        if is_long_setup
            // For longs (after downswing), zone is above current price. Measure how close high got to zone bottom.
            if high < adjusted_box_bottom
                dist_to_zone_pct := ((adjusted_box_bottom - high) / adjusted_box_bottom) * 100
        else
            // For shorts (after upswing), zone is below current price. Measure how close low got to zone top.
            if low > adjusted_box_top
                dist_to_zone_pct := ((low - adjusted_box_top) / adjusted_box_top) * 100
    // else: price is inside zone, distance = 0 (not a near-miss, it's a touch)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIRMED TRADE TRACKING (Learning Engine - NOT for projections)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Track minimum distance for CONFIRMED setup only (not projections)
    if not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        GLOBAL_activeTrade.min_distance := math.min(GLOBAL_activeTrade.min_distance, dist_to_zone_pct)
    
    // Zone activation: price is inside the (adjusted) Golden Pocket
    // For CONFIRMED trades: use stored zone boundaries for consistent tracking
    // For DISPLAY: use current calculated boundaries
    bool in_zone = false
    bool zone_entry = false
    
    // Check against CONFIRMED trade boundaries (for learning)
    bool confirmed_in_zone = false
    bool confirmed_zone_entry = false
    if not na(GLOBAL_activeTrade.setup_bar)
        confirmed_in_zone := low <= GLOBAL_activeTrade.zone_top and high >= GLOBAL_activeTrade.zone_bottom
        confirmed_zone_entry := confirmed_in_zone and not GLOBAL_activeTrade.hasFlag(STATIC_FLAG_ZONE_TOUCHED)
    
    // Check against CURRENT boundaries (for display)
    in_zone := low <= adjusted_box_top and high >= adjusted_box_bottom
    zone_entry := in_zone and (na(GLOBAL_activeTrade.setup_bar) or not GLOBAL_activeTrade.hasFlag(STATIC_FLAG_ZONE_TOUCHED))
    
    // Track if zone was touched for CONFIRMED setup only (not projections)
    if confirmed_in_zone and not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        GLOBAL_activeTrade.setFlag(STATIC_FLAG_ZONE_TOUCHED)
    
    // Track SL/TP hits for CONFIRMED setup only (not projections)
    // Track SL/TP only after zone is touched (entry occurred)
    // Use STORED sl/tp prices from setup formation for consistent tracking
    // CONSERVATIVE EXECUTION: If bar covers both SL and TP, assume SL hit UNLESS
    //   Open is at least 2x closer to TP than SL (dist_to_tp < dist_to_sl * 0.5)
    if not na(GLOBAL_activeTrade.setup_bar) and GLOBAL_activeTrade.hasFlag(STATIC_FLAG_ZONE_TOUCHED) and not isProjection
        if GLOBAL_activeTrade.hasFlag(STATIC_FLAG_IS_LONG)
            bool sl_touched = low <= GLOBAL_activeTrade.sl_price
            bool tp_touched = high >= GLOBAL_activeTrade.tp_price
            
            // Outcome detection with mutual exclusion (first outcome wins, per FR-4 invariant)
            // Skip if outcome already determined
            if not GLOBAL_activeTrade.hasAny(STATIC_MASK_OUTCOME)
                if sl_touched and tp_touched
                    // Conservative execution: when both hit in same bar, prioritize capital preservation
                    // Check if Open was closer to TP - only then assume TP hit first
                    float dist_to_sl = math.abs(open - GLOBAL_activeTrade.sl_price)
                    float dist_to_tp = math.abs(open - GLOBAL_activeTrade.tp_price)
                    // TP only wins if Open is significantly closer (50%+ closer) to TP
                    if dist_to_tp < dist_to_sl * 0.5
                        GLOBAL_activeTrade.setOutcome(STATIC_FLAG_TP_HIT).setFlag(STATIC_FLAG_WON)
                    else
                        GLOBAL_activeTrade.setOutcome(STATIC_FLAG_SL_HIT)
                else if sl_touched
                    GLOBAL_activeTrade.setOutcome(STATIC_FLAG_SL_HIT)
                else if tp_touched
                    GLOBAL_activeTrade.setOutcome(STATIC_FLAG_TP_HIT).setFlag(STATIC_FLAG_WON)
            
            // Track both TP modes independently (for learning comparison)
            // These are analytics flags, not mutually exclusive with SL/TP outcome
            if high >= GLOBAL_activeTrade.tp_cons
                GLOBAL_activeTrade.setFlag(STATIC_FLAG_CONS_TP_HIT)
            if high >= GLOBAL_activeTrade.tp_aggr
                GLOBAL_activeTrade.setFlag(STATIC_FLAG_AGGR_TP_HIT)
        else
            bool sl_touched = high >= GLOBAL_activeTrade.sl_price
            bool tp_touched = low <= GLOBAL_activeTrade.tp_price
            
            // Outcome detection with mutual exclusion (first outcome wins, per FR-4 invariant)
            // Skip if outcome already determined
            if not GLOBAL_activeTrade.hasAny(STATIC_MASK_OUTCOME)
                if sl_touched and tp_touched
                    // Conservative execution: when both hit in same bar, prioritize capital preservation
                    float dist_to_sl = math.abs(open - GLOBAL_activeTrade.sl_price)
                    float dist_to_tp = math.abs(open - GLOBAL_activeTrade.tp_price)
                    if dist_to_tp < dist_to_sl * 0.5
                        GLOBAL_activeTrade.setOutcome(STATIC_FLAG_TP_HIT).setFlag(STATIC_FLAG_WON)
                    else
                        GLOBAL_activeTrade.setOutcome(STATIC_FLAG_SL_HIT)
                else if sl_touched
                    GLOBAL_activeTrade.setOutcome(STATIC_FLAG_SL_HIT)
                else if tp_touched
                    GLOBAL_activeTrade.setOutcome(STATIC_FLAG_TP_HIT).setFlag(STATIC_FLAG_WON)
            
            // Track both TP modes independently (for learning comparison)
            // These are analytics flags, not mutually exclusive with SL/TP outcome
            if low <= GLOBAL_activeTrade.tp_cons
                GLOBAL_activeTrade.setFlag(STATIC_FLAG_CONS_TP_HIT)
            if low <= GLOBAL_activeTrade.tp_aggr
                GLOBAL_activeTrade.setFlag(STATIC_FLAG_AGGR_TP_HIT)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAE/MFE tracking (confirmed trades only)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Track entry when zone is first touched (CONFIRMED trades only, not projections)
    if confirmed_zone_entry and not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        if na(GLOBAL_activeTrade.entry_bar)
            GLOBAL_activeTrade.entry_bar := bar_index
            GLOBAL_activeTrade.entry_price := close
            GLOBAL_activeTrade.rsi_at_entry := GLOBAL_regime.rsi
    
    // Track MAE/MFE from entry (only after zone touched, CONFIRMED trades only)
    if not na(GLOBAL_activeTrade.entry_bar) and not na(GLOBAL_activeTrade.entry_price) and not na(GLOBAL_activeTrade.atr_at_setup) and not isProjection
        if not GLOBAL_activeTrade.hasAny(STATIC_MASK_OUTCOME)
            if GLOBAL_activeTrade.hasFlag(STATIC_FLAG_IS_LONG)
                // MAE: How much price moved against us (low - entry, negative is adverse)
                float adverse = (GLOBAL_activeTrade.entry_price - low) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_adverse := math.max(GLOBAL_activeTrade.max_adverse, adverse)
                // MFE: How much price moved in our favor (high - entry)
                float favorable = (high - GLOBAL_activeTrade.entry_price) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_favorable := math.max(GLOBAL_activeTrade.max_favorable, favorable)
            else
                // Short: adverse is when price goes up, favorable is when price goes down
                float adverse = (high - GLOBAL_activeTrade.entry_price) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_adverse := math.max(GLOBAL_activeTrade.max_adverse, adverse)
                float favorable = (GLOBAL_activeTrade.entry_price - low) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_favorable := math.max(GLOBAL_activeTrade.max_favorable, favorable)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Time decay calculation
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PROBLEM: Previously used effIMidPivot which causes decay to "jump" when projection becomes confirmed.
    //          When projection mode: pivot is "now" (bar_index), decay = 0 (Fresh)
    //          When confirmed: pivot bar jumps back by GLOBAL_pivotLength, decay jumps to Stale instantly
    //
    // SOLUTION: Use creation_bar for confirmed trades (tracks when WE created the setup)
    //           For projections: decay = 0 (always Fresh since we're projecting in real-time)
    //           For confirmed: decay = bar_index - creation_bar (smooth progression)
    //
    // creation_bar = bar_index when GLOBAL_zigzag.changed fires (first bar after)
    //       confirmation starts at 0 bars since creation, then increments smoothly.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    int bars_since_creation = 0
    if isProjection
        // Projection mode: decay is always 0 (Fresh) since we're projecting in real-time
        bars_since_creation := 0
    else if not na(GLOBAL_activeTrade.creation_bar)
        // Confirmed mode: use stored creation_bar for smooth decay progression
        bars_since_creation := bar_index - GLOBAL_activeTrade.creation_bar
    else
        // Fallback: use effIMidPivot if no active trade (shouldn't happen often)
        bars_since_creation := bar_index - effIMidPivot
    
    // Dynamic time thresholds: scale Fib sequence by learned avg_bars if available
    float time_scale = 1.0
    bool has_learned_time = INPUT_LEARN_DECAY and INPUT_LEARNING_ENABLED and GLOBAL_learning.averageBarsHeld > 0
    if has_learned_time
        // Reference: default assumes TIME_DECAY_REFERENCE_BARS is "mid" point (Fib threshold 2)
        time_scale := math.max(STATIC_TIME_DECAY_SCALE_MIN, math.min(STATIC_TIME_DECAY_SCALE_MAX, float(GLOBAL_learning.averageBarsHeld) / TIME_DECAY_REFERENCE_BARS))
    
    // Fibonacci time thresholds and decay calculation (scaled by learned timing)
    // Each threshold passed reduces confidence by decay rate
    int t1 = int(TIME_DECAY_T1 * time_scale)
    int t2 = int(TIME_DECAY_T2 * time_scale)
    int t3 = int(TIME_DECAY_T3 * time_scale)
    int t4 = int(TIME_DECAY_T4 * time_scale)
    int t5 = int(TIME_DECAY_T5 * time_scale)
    int t6 = int(89 * time_scale)
    
    int time_phase = bars_since_creation >= t6 ? 6 : 
                     bars_since_creation >= t5 ? 5 : 
                     bars_since_creation >= t4 ? 4 : 
                     bars_since_creation >= t3 ? 3 : 
                     bars_since_creation >= t2 ? 2 : 
                     bars_since_creation >= t1 ? 1 : 0
    
    // Use learned decay rate if enabled and sufficient data
    float decay_rate = TIME_DECAY_DEFAULT_RATE
    bool has_learned_decay = INPUT_LEARN_DECAY and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_learned_decay and GLOBAL_learning.decayRate > 0
        decay_rate := GLOBAL_learning.decayRate
    float time_decay = INPUT_POS_TIME_DECAY ? math.pow(decay_rate, time_phase) : 1.0
    bool zone_expired = INPUT_POS_TIME_DECAY and time_phase >= 5  // Expired after t5+ bars
    
    // Time decay indicator for display (show learned rate if different)
    string decay_indicator = has_learned_decay ? UI_ICON_HOURGLASS + "*" : UI_ICON_HOURGLASS
    string time_status = not INPUT_POS_TIME_DECAY ? "" : 
                         time_phase == 0 ? " " + decay_indicator + TEXT_FRESH : 
                         time_phase <= 2 ? " " + decay_indicator + str.tostring(int(time_decay * 100)) + "%" : 
                         time_phase <= 4 ? " " + decay_indicator + TEXT_STALE : " " + decay_indicator + "EXPIRED"
    
    // SL breach invalidation (also invalidate on zone expiration)
    // Use CONFIRMED trade direction and SL for consistency (not projection)
    bool sl_check_long = not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.hasFlag(STATIC_FLAG_IS_LONG) : is_long_setup
    float sl_check_price = not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.sl_price : sl_price
    bool sl_breached = sl_check_long ? close < sl_check_price : close > sl_check_price
    bool is_invalid = sl_breached or zone_expired
    
    // Volume confluence
    bool vol_confirm = exhaustVol or crossover_exhaustion
    
    // RSI Divergence Confluence - Use global pre-computed values (Pine v6 best practice)
    float rsi = GLOBAL_regime.rsi
    float rsi_at_pivot = GLOBAL_rsi_at_pivot
    float price_at_pivot = GLOBAL_priceAtPivot
    
    // Use CONFIRMED trade direction for divergence check (for learning consistency)
    bool check_long = not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.hasFlag(STATIC_FLAG_IS_LONG) : is_long_setup
    // Bullish divergence: price made lower low but RSI made higher low (momentum building)
    bool bullish_div = check_long and close < price_at_pivot and rsi > rsi_at_pivot
    // Bearish divergence: price made higher high but RSI made lower high (momentum fading)
    bool bearish_div = not check_long and close > price_at_pivot and rsi < rsi_at_pivot
    bool rsi_confirm = INPUT_POS_RSI_DIV ? ((check_long and bullish_div) or (not check_long and bearish_div)) : false
    
    // Capture RSI divergence flag for learning (CONFIRMED trades only, not projections)
    if confirmed_zone_entry and not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        if bullish_div or bearish_div
            GLOBAL_activeTrade.setFlag(STATIC_FLAG_HAD_RSI_DIV)
    
    // Combined confluence: volume OR RSI divergence
    bool full_confirm = vol_confirm or rsi_confirm
    
    // Determine box color based on state (apply time decay to transparency)
    // Use current calculation for display (projection or confirmed)
    bool active_is_long = isProjection ? is_long_setup : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.hasFlag(STATIC_FLAG_IS_LONG) : is_long_setup)
    color base_color = active_is_long ? COLOR_BLUE : COLOR_RED
    int decay_trans_add = int((1 - time_decay) * 20)  // Add 0-20 transparency based on decay
    int bg_trans = is_invalid ? 90 : (in_zone ? (full_confirm ? 45 : (vol_confirm or rsi_confirm ? 55 : 65)) : 75) + decay_trans_add
    int border_trans = is_invalid ? 80 : (rsi_confirm ? 10 : 25) + decay_trans_add
    color bg_col = is_invalid ? color.new(COLOR_GRAY, math.min(bg_trans, 95)) : color.new(base_color, math.min(bg_trans, 95))
    color border_col = is_invalid ? color.new(COLOR_GRAY, math.min(border_trans, 90)) : color.new(base_color, math.min(border_trans, 90))
    
    // R:R calculation - use current calculated values (with learning adjustments)
    float mid_entry = (price_618 + price_65) / 2
    float risk = math.abs(mid_entry - sl_price)
    float reward = math.abs(tp_price - mid_entry)
    float rr_ratio = risk > 0 ? reward / risk : 0
    
    // Kelly Criterion: f* = (p * b - q) / b where p = win rate, q = 1-p, b = R:R ratio
    // This gives optimal fraction of bankroll to risk for geometric growth maximization
    // Apply time decay to win rate (stale setups have lower probability)
    float p_base = INPUT_POS_WIN_RATE / 100  // Convert percentage to decimal
    
    // Calculate empirical win rate from learning history
    // Recalculate only when new trade was recorded (lazy evaluation: toggle, size, flag)
    float p_empirical = p_base
    if INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_SL and GLOBAL_learning.needsRecalc
        // Reset flag - we're about to recalculate
        GLOBAL_learning.needsRecalc := false
        DBG_counterLearningRuns += 1
        
        // Basic counters
        int wins = 0
        int losses = 0
        float total_mae = 0.0
        float total_mfe = 0.0
        int total_bars = 0
        int outcome_count = 0
        // RSI divergence effectiveness
        int wins_with_div = 0
        int losses_with_div = 0
        int wins_without_div = 0
        int losses_without_div = 0
        // Direction-specific win rates
        int wins_long = 0
        int losses_long = 0
        int wins_short = 0
        int losses_short = 0
        // Losing trade MAE (for SL calibration)
        float losing_mae_total = 0.0
        int losing_count = 0
        // TP mode comparison counters
        int conservativeTpWins = 0       // Setups where Conservative TP was hit (without SL hit)
        int conservativeTpTotal = 0      // Total setups with valid Conservative TP tracking
        int aggressiveTpWins = 0       // Setups where Aggressive TP was hit (without SL hit)
        int aggressiveTpTotal = 0      // Total setups with valid Aggressive TP tracking
        // Time decay learning (bars_to_outcome distribution)
        int early_wins = 0         // Wins within first TIME_DECAY_T2 bars
        int late_wins = 0          // Wins after TIME_DECAY_T3 bars
        // Regime detection and performance metrics
        int wins_high_vol = 0      // Wins in high volatility regime (>VOL_REGIME_HIGH_THRESH percentile)
        int losses_high_vol = 0    // Losses in high volatility regime
        int wins_low_vol = 0       // Wins in low volatility regime (<40 percentile)
        int losses_low_vol = 0     // Losses in low volatility regime
        float total_r_won = 0.0    // Total R won (1R per win = TP hit)
        float total_r_lost = 0.0   // Total R lost (1R per loss = SL hit)
        int consecutive_wins = 0   // Consecutive wins from most recent
        int consecutive_losses = 0 // Consecutive losses from most recent
        int max_win_streak = 0     // Maximum winning streak found
        int max_loss_streak = 0    // Maximum losing streak found
        int streak_state = 0       // 0=unknown, 1=in_win_streak, -1=in_loss_streak
        bool streak_frozen = false // Once streak is broken, stop updating current streak
        // Entropy regime counters
        int wins_ordered = 0       // Wins in ordered (low entropy) regime
        int losses_ordered = 0     // Losses in ordered regime
        int wins_disordered = 0    // Wins in disordered (high entropy) regime
        int losses_disordered = 0  // Losses in disordered regime
        // Hurst regime counters
        int wins_trend = 0         // Wins in trending (persistent) regime
        int losses_trend = 0       // Losses in trending regime
        int wins_meanrev = 0       // Wins in mean-reverting regime
        int losses_meanrev = 0     // Losses in mean-reverting regime
        int wins_random = 0        // Wins in random walk regime
        int losses_random = 0      // Losses in random walk regime
        // Z-score momentum counters
        int wins_strong_mom = 0    // Wins with strong momentum
        int losses_strong_mom = 0  // Losses with strong momentum
        int wins_weak_mom = 0      // Wins with weak momentum
        int losses_weak_mom = 0    // Losses with weak momentum
        
        // Iterate from NEWEST to OLDEST using CircularBuffer (get(0) = newest)
        int history_size = GLOBAL_setupHistory.size()
        int samples_to_check = math.min(INPUT_LEARNING_SAMPLES, history_size)
        for idx = 0 to samples_to_check - 1
            // CircularBuffer: idx=0 is newest, idx=samples_to_check-1 is oldest in window
            SetupRecord rec = GLOBAL_setupHistory.get(idx)
            // Skip if na (buffer not yet full at this index)
            if na(rec)
                continue
            // Setups where zone was never touched are "no trade" - don't affect win rate
            if not rec.hasFlag(STATIC_FLAG_ZONE_TOUCHED)
                continue  // Skip - no entry, no trade
            
            if rec.hasFlag(STATIC_FLAG_TP_HIT) and not rec.hasFlag(STATIC_FLAG_SL_HIT)
                wins += 1
                // Aggregate winning trade metrics
                total_mae += rec.max_adverse
                total_mfe += rec.max_favorable
                total_bars += rec.bars_to_outcome
                outcome_count += 1
                // RSI divergence stratification
                if rec.hasFlag(STATIC_FLAG_HAD_RSI_DIV)
                    wins_with_div += 1
                else
                    wins_without_div += 1
                // Direction stratification
                if rec.hasFlag(STATIC_FLAG_IS_LONG)
                    wins_long += 1
                else
                    wins_short += 1
                // Time decay learning
                if rec.bars_to_outcome <= TIME_DECAY_T2
                    early_wins += 1
                else if rec.bars_to_outcome > TIME_DECAY_T3
                    late_wins += 1
                // Volatility regime stratification
                if rec.vol_percentile >= VOL_REGIME_HIGH_THRESH
                    wins_high_vol += 1
                else if rec.vol_percentile <= VOL_REGIME_LOW_THRESH
                    wins_low_vol += 1
                // Entropy regime stratification
                if rec.entropy_regime == ENTROPY_REGIME_ORDERED
                    wins_ordered += 1
                else if rec.entropy_regime == ENTROPY_REGIME_DISORDERED
                    wins_disordered += 1
                // Hurst regime stratification
                if rec.hurst_regime == HURST_REGIME_TREND
                    wins_trend += 1
                else if rec.hurst_regime == HURST_REGIME_MEANREV
                    wins_meanrev += 1
                else if rec.hurst_regime == HURST_REGIME_RANDOM
                    wins_random += 1
                // Z-score momentum stratification
                if rec.strong_momentum
                    wins_strong_mom += 1
                else
                    wins_weak_mom += 1
                // Profit factor tracking (1R per win)
                total_r_won += 1.0
                // Streak tracking (newest to oldest, freeze after break)
                if not streak_frozen
                    if streak_state == 0
                        streak_state := 1  // Start win streak
                        consecutive_wins := 1
                    else if streak_state == 1
                        consecutive_wins += 1  // Continue win streak
                    else
                        // Was in loss streak, this win breaks it
                        streak_frozen := true
            else if rec.hasFlag(STATIC_FLAG_SL_HIT)
                losses += 1
                // Track losing trade MAE
                losing_mae_total += rec.max_adverse
                losing_count += 1
                // RSI divergence stratification
                if rec.hasFlag(STATIC_FLAG_HAD_RSI_DIV)
                    losses_with_div += 1
                else
                    losses_without_div += 1
                // Direction stratification
                if rec.hasFlag(STATIC_FLAG_IS_LONG)
                    losses_long += 1
                else
                    losses_short += 1
                // Volatility regime stratification
                if rec.vol_percentile >= VOL_REGIME_HIGH_THRESH
                    losses_high_vol += 1
                else if rec.vol_percentile <= VOL_REGIME_LOW_THRESH
                    losses_low_vol += 1
                // Entropy regime stratification
                if rec.entropy_regime == ENTROPY_REGIME_ORDERED
                    losses_ordered += 1
                else if rec.entropy_regime == ENTROPY_REGIME_DISORDERED
                    losses_disordered += 1
                // Hurst regime stratification
                if rec.hurst_regime == HURST_REGIME_TREND
                    losses_trend += 1
                else if rec.hurst_regime == HURST_REGIME_MEANREV
                    losses_meanrev += 1
                else if rec.hurst_regime == HURST_REGIME_RANDOM
                    losses_random += 1
                // Z-score momentum stratification
                if rec.strong_momentum
                    losses_strong_mom += 1
                else
                    losses_weak_mom += 1
                // Profit factor tracking (1R per loss)
                total_r_lost += 1.0
                // Streak tracking (newest to oldest, freeze after break)
                if not streak_frozen
                    if streak_state == 0
                        streak_state := -1  // Start loss streak
                        consecutive_losses := 1
                    else if streak_state == -1
                        consecutive_losses += 1  // Continue loss streak
                    else
                        // Was in win streak, this loss breaks it
                        streak_frozen := true
            
            // TP mode comparison (track both modes)
            // Only count if SL wasn't hit first
            if not rec.hasFlag(STATIC_FLAG_SL_HIT)
                conservativeTpTotal += 1
                aggressiveTpTotal += 1
                if rec.hasFlag(STATIC_FLAG_CONS_TP_HIT)
                    conservativeTpWins += 1
                if rec.hasFlag(STATIC_FLAG_AGGR_TP_HIT)
                    aggressiveTpWins += 1
        
        int total_outcomes = wins + losses
        if total_outcomes >= LEARN_MIN_SAMPLES_WR and total_outcomes > 0
            p_empirical := float(wins) / float(total_outcomes)
            // Clamp win rate to prevent Kelly from returning wild values during streaks
            GLOBAL_learning.winRate := math.max(0.30, math.min(0.70, p_empirical))
        
        // Extended learning: compute averages from winning trades
        if outcome_count >= LEARN_MIN_SAMPLES_MAE
            GLOBAL_learning.averageMaxAdverseExcursion := total_mae / float(outcome_count)
            GLOBAL_learning.averageMaxFavorableExcursion := total_mfe / float(outcome_count)
            GLOBAL_learning.averageBarsHeld := int(float(total_bars) / float(outcome_count))
            // Optimal SL = average MAE of winners + STATIC_SL_BUFFER_ATR ATR buffer
            // This allows for typical drawdowns while avoiding premature stopouts
            GLOBAL_learning.stopLossMultiplier := math.max(1.0, GLOBAL_learning.averageMaxAdverseExcursion + STATIC_SL_BUFFER_ATR)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â”€â”€ Advanced learning analytics
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // RSI Divergence Effectiveness: Compare win rates with/without divergence
        int total_with_div = wins_with_div + losses_with_div
        int total_without_div = wins_without_div + losses_without_div
        if total_with_div >= LEARN_MIN_SAMPLES_DIV
            GLOBAL_learning.winRateWithDivergence := float(wins_with_div) / float(total_with_div)
        if total_without_div >= LEARN_MIN_SAMPLES_DIV
            GLOBAL_learning.winRateWithoutDivergence := float(wins_without_div) / float(total_without_div)
        // Edge from divergence = difference in win rates
        if total_with_div >= LEARN_MIN_SAMPLES_DIV and total_without_div >= LEARN_MIN_SAMPLES_DIV
            GLOBAL_learning.divergenceEdge := GLOBAL_learning.winRateWithDivergence - GLOBAL_learning.winRateWithoutDivergence
        
        // Direction-Specific Win Rates
        int total_long = wins_long + losses_long
        int total_short = wins_short + losses_short
        if total_long >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateLong := float(wins_long) / float(total_long)
        if total_short >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateShort := float(wins_short) / float(total_short)
        
        // Losing Trade MAE Analysis: Where should SL have been?
        if losing_count >= LEARN_MIN_SAMPLES_LOSING
            GLOBAL_learning.losingMaxAdverseExcursion := losing_mae_total / float(losing_count)
        
        // Optimal Holding Period: Use average bars to outcome
        if outcome_count >= LEARN_MIN_SAMPLES_MAE
            GLOBAL_learning.optimalHoldBars := GLOBAL_learning.averageBarsHeld
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â”€â”€ TP mode, decay rate, RSI weight learning
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // TP Mode Comparison: Which mode has better expected value?
        if conservativeTpTotal >= LEARN_MIN_SAMPLES_TP_COMP and aggressiveTpTotal >= LEARN_MIN_SAMPLES_TP_COMP
            GLOBAL_learning.conservativeWinRate := float(conservativeTpWins) / float(conservativeTpTotal)
            GLOBAL_learning.aggressiveWinRate := float(aggressiveTpWins) / float(aggressiveTpTotal)
            // Calculate R:R for each mode (approximate using zone mid as entry)
            float conservativeReward = math.abs(tp_conservative - mid_entry)
            float aggressiveReward = math.abs(tp_aggressive - mid_entry)
            float conservativeRiskReward = risk > 0 ? conservativeReward / risk : 0
            float aggressiveRiskReward = risk > 0 ? aggressiveReward / risk : 0
            // Expected Value = (WinRate * Reward) - ((1-WinRate) * Risk) per unit risk
            GLOBAL_learning.conservativeExpectedValue := GLOBAL_learning.conservativeWinRate * conservativeRiskReward - (1 - GLOBAL_learning.conservativeWinRate)
            GLOBAL_learning.aggressiveExpectedValue := GLOBAL_learning.aggressiveWinRate * aggressiveRiskReward - (1 - GLOBAL_learning.aggressiveWinRate)
            // Choose mode with higher EV
            GLOBAL_learning.useTakeProfitAggressive := GLOBAL_learning.aggressiveExpectedValue > GLOBAL_learning.conservativeExpectedValue
        
        // Time Decay Rate Learning: Based on when wins happen
        // If most wins are early, accelerate decay. If wins persist late, slow decay.
        int total_timed_wins = early_wins + late_wins
        if total_timed_wins >= LEARN_MIN_SAMPLES_TIME
            float early_ratio = float(early_wins) / float(total_timed_wins)
            // early_ratio > 0.6 means most wins are early â†’ accelerate decay (lower rate)
            // early_ratio < 0.4 means wins persist late â†’ slow decay (higher rate)
            // Map: early_ratio 0.3-0.7 â†’ decay_rate STATIC_DECAY_RATE_MAX-STATIC_DECAY_RATE_MIN
            GLOBAL_learning.decayRate := DEFAULT_DECAY_RATE + (0.5 - early_ratio) * STATIC_DECAY_RATE_ADJUST
            // Clamp to reasonable range [STATIC_DECAY_RATE_MIN, STATIC_DECAY_RATE_MAX]
            GLOBAL_learning.decayRate := math.max(STATIC_DECAY_RATE_MIN, math.min(STATIC_DECAY_RATE_MAX, GLOBAL_learning.decayRate))
        
        // RSI Weight Learning: How much edge does divergence provide?
        // Weight = normalized edge (0 if no edge, 1 if huge edge)
        if total_with_div >= LEARN_MIN_SAMPLES_DIV and total_without_div >= LEARN_MIN_SAMPLES_DIV
            // GLOBAL_learning.divergenceEdge is already computed above
            // Convert edge to weight: +20% edge â†’ weight 1.0, 0% edge â†’ weight 0.0
            GLOBAL_learning.rsiWeight := math.max(0, math.min(1.0, GLOBAL_learning.divergenceEdge * 5))
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Already cleaned up above
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // 4.1 Volatility Regime Win Rates
        int total_high_vol = wins_high_vol + losses_high_vol
        int total_low_vol = wins_low_vol + losses_low_vol
        if total_high_vol >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateHighVolatility := float(wins_high_vol) / float(total_high_vol)
        if total_low_vol >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateLowVolatility := float(wins_low_vol) / float(total_low_vol)
        
        // Entropy regime win rates
        int total_ordered = wins_ordered + losses_ordered
        int total_disordered = wins_disordered + losses_disordered
        if total_ordered >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateOrdered := float(wins_ordered) / float(total_ordered)
        if total_disordered >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateDisordered := float(wins_disordered) / float(total_disordered)
        // Entropy edge: ordered WR - disordered WR
        if total_ordered >= LEARN_MIN_SAMPLES_DIR and total_disordered >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.entropyEdge := GLOBAL_learning.winRateOrdered - GLOBAL_learning.winRateDisordered
        
        // Hurst regime win rates
        int total_trend = wins_trend + losses_trend
        int total_meanrev = wins_meanrev + losses_meanrev
        int total_random = wins_random + losses_random
        if total_trend >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateTrend := float(wins_trend) / float(total_trend)
        if total_meanrev >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateMeanRevert := float(wins_meanrev) / float(total_meanrev)
        if total_random >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateRandom := float(wins_random) / float(total_random)
        // Hurst edge: trend WR - meanrev WR
        if total_trend >= LEARN_MIN_SAMPLES_DIR and total_meanrev >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.hurstEdge := GLOBAL_learning.winRateTrend - GLOBAL_learning.winRateMeanRevert
        
        // Z-Score momentum win rates
        int total_strong_mom = wins_strong_mom + losses_strong_mom
        int total_weak_mom = wins_weak_mom + losses_weak_mom
        if total_strong_mom >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateStrongMomentum := float(wins_strong_mom) / float(total_strong_mom)
        if total_weak_mom >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.winRateWeakMomentum := float(wins_weak_mom) / float(total_weak_mom)
        // Momentum edge: strong WR - weak WR
        if total_strong_mom >= LEARN_MIN_SAMPLES_DIR and total_weak_mom >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.momentumEdge := GLOBAL_learning.winRateStrongMomentum - GLOBAL_learning.winRateWeakMomentum
        
        // Profit factor: Total R won / R lost
        if total_r_lost > 0
            GLOBAL_learning.profitFactor := total_r_won / total_r_lost
        else if total_r_won > 0
            GLOBAL_learning.profitFactor := 10.0  // Cap at 10 if no losses
        
        // Expectancy: (WR Ã— avg win) - ((1-WR) Ã— avg loss)
        if total_outcomes >= LEARN_MIN_SAMPLES_WR
            float avg_win_r = wins > 0 ? total_r_won / float(wins) : 0
            float avg_loss_r = losses > 0 ? total_r_lost / float(losses) : 0
            GLOBAL_learning.expectancy := (p_empirical * avg_win_r) - ((1 - p_empirical) * avg_loss_r)
        
        // Streak recording (consecutive from most recent + max historical)
        max_win_streak := math.max(max_win_streak, consecutive_wins)
        max_loss_streak := math.max(max_loss_streak, consecutive_losses)
        GLOBAL_learning.winStreak := consecutive_wins
        GLOBAL_learning.lossStreak := consecutive_losses
        
        // Log-return performance metrics
        if total_outcomes >= LEARN_MIN_SAMPLES_WR
            float avg_win_r = wins > 0 ? total_r_won / float(wins) : 0
            float avg_loss_r = losses > 0 ? total_r_lost / float(losses) : 0
            float sum_log_returns = 0.0
            float sum_log_sq = 0.0
            for i = 0 to samples_to_check - 1
                SetupRecord rec = GLOBAL_setupHistory.get(i)
                if not na(rec) and rec.hasFlag(STATIC_MASK_CLOSED)
                    float trade_r = rec.hasFlag(STATIC_FLAG_WON) ? avg_win_r : -avg_loss_r
                    float log_r = f_logReturn(1.0 + trade_r, 1.0)
                    sum_log_returns += log_r
                    sum_log_sq += log_r * log_r
            GLOBAL_learning.cumulativeLogReturn := sum_log_returns
            GLOBAL_learning.averageLogReturn := sum_log_returns / float(total_outcomes)
            float variance = (sum_log_sq / float(total_outcomes)) - (GLOBAL_learning.averageLogReturn * GLOBAL_learning.averageLogReturn)
            GLOBAL_learning.logReturnStandardDeviation := math.sqrt(math.max(0, variance))
            if GLOBAL_learning.logReturnStandardDeviation > 0
                GLOBAL_learning.sharpeRatio := GLOBAL_learning.averageLogReturn / GLOBAL_learning.logReturnStandardDeviation
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Already cleaned up above
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // 5.1 Bayesian Win-Rate (Beta-Binomial Model)
        if INPUT_BAYES_ENABLED
            // Update posterior: Î± = prior + wins, Î² = prior + losses
            GLOBAL_learning.bayesianAlpha := INPUT_STATIC_BAYES_ALPHA_PRIOR + float(wins)
            GLOBAL_learning.bayesianBeta := INPUT_STATIC_BAYES_BETA_PRIOR + float(losses)
            // Posterior mean: E[Î¸] = Î± / (Î± + Î²)
            GLOBAL_learning.bayesianMean := f_betaMean(GLOBAL_learning.bayesianAlpha, GLOBAL_learning.bayesianBeta)
            // Lower credible bound (sample-size penalized)
            float percentile = 1.0 - INPUT_BAYES_CONFIDENCE
            GLOBAL_learning.bayesianLowerBound := f_betaLowerBound(GLOBAL_learning.bayesianAlpha, GLOBAL_learning.bayesianBeta, percentile)
        
        // 5.2 Sortino Ratio (Downside-Risk Adjusted)
        if INPUT_SORTINO_ENABLED and total_outcomes >= LEARN_MIN_SAMPLES_WR
            // Build return array from SetupRecord log_return field
            array<float> trade_returns = array.new_float(0)
            float sum_returns = 0.0
            float sum_sq_downside = 0.0
            int downside_count = 0
            
            for i = 0 to samples_to_check - 1
                SetupRecord rec = GLOBAL_setupHistory.get(i)
                if not na(rec) and rec.hasFlag(STATIC_FLAG_ZONE_TOUCHED)
                    float ret = rec.log_return
                    array.push(trade_returns, ret)
                    sum_returns += ret
                    // Track downside deviation (returns below MAR)
                    if ret < INPUT_STATIC_SORTINO_MAR
                        float diff = ret - INPUT_STATIC_SORTINO_MAR
                        sum_sq_downside += diff * diff
                        downside_count += 1
            
            int n_returns = array.size(trade_returns)
            if n_returns >= 2
                GLOBAL_learning.meanTradeReturn := sum_returns / float(n_returns)
                // Downside deviation = sqrt(mean of squared downside deviations over ALL trades)
                GLOBAL_learning.downsideDeviation := math.sqrt(sum_sq_downside / float(n_returns))
                // Sortino = (mean - rf) / downside_dev
                if GLOBAL_learning.downsideDeviation > 1e-10
                    GLOBAL_learning.sortinoRatio := GLOBAL_learning.meanTradeReturn / GLOBAL_learning.downsideDeviation
                else
                    // No downside: cap at max if profitable, 0 otherwise
                    GLOBAL_learning.sortinoRatio := GLOBAL_learning.meanTradeReturn > 0 ? STATIC_SORTINO_MAX_CAP : 0.0
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â”€â”€ Monte Carlo permutation test
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // 6.1 Monte Carlo Permutation Test for Timing Edge Validation
        if INPUT_MC_ENABLED and total_outcomes >= MC_MIN_TRADES
            array<float> mc_returns = array.new_float(0)
            for i = 0 to samples_to_check - 1
                SetupRecord rec = GLOBAL_setupHistory.get(i)
                if not na(rec) and rec.hasFlag(STATIC_FLAG_ZONE_TOUCHED)
                    array.push(mc_returns, rec.log_return)
            
            if array.size(mc_returns) >= MC_MIN_TRADES
                [orig_dd, mean_shuf_dd, p_val, sims] = f_monteCarloDD(mc_returns, INPUT_MC_SIMS, MC_SEED_BASE)
                GLOBAL_learning.monteCarloOriginalDrawdown := orig_dd
                GLOBAL_learning.monteCarloMeanShuffledDrawdown := mean_shuf_dd
                GLOBAL_learning.monteCarloPValue := p_val
                GLOBAL_learning.monteCarloSimulationsRun := sims
                GLOBAL_learning.isMonteCarloSignificant := p_val < INPUT_MC_PVALUE
        
        // 4.6 Learning Health Check
        int bars_since_outcome = bar_index - GLOBAL_learning.lastOutcomeBar
        bool is_stale = bars_since_outcome > HEALTH_STALE_BARS and GLOBAL_learning.lastOutcomeBar > 0
        // Sanity check: WR should be STATIC_HEALTH_WR_MIN-STATIC_HEALTH_WR_MAX, profit factor > STATIC_HEALTH_PF_MIN
        bool sane_wr = GLOBAL_learning.winRate >= STATIC_HEALTH_WR_MIN and GLOBAL_learning.winRate <= STATIC_HEALTH_WR_MAX
        bool sane_pf = GLOBAL_learning.profitFactor >= STATIC_HEALTH_PF_MIN or GLOBAL_learning.profitFactor == 0.0
        GLOBAL_learning.isHealthy := not is_stale and sane_wr and sane_pf
        
        // 4.6 Unified Confidence Score (0-100) - Computed at analysis time
        // Direction alignment and time decay will be recalculated in display section
        //       using current bar context. Here we compute the "base" confidence from learning data.
        // Components: WR (35%), RSI Edge (20%), Profit Factor (15%), Streak Status (15%), Health (15%)
        float conf_base = 0.0
        // WR Component: CONF_WR_WEIGHT% weight - map STATIC_CONF_WR_MIN_MAP-STATIC_CONF_WR_MAX_MAP â†’ 0-35
        conf_base += math.max(0, math.min(CONF_WR_WEIGHT, (GLOBAL_learning.winRate - STATIC_CONF_WR_MIN_MAP) * 70))
        // RSI Edge: CONF_RSI_WEIGHT% weight - map 0-0.2 edge â†’ 0-20
        conf_base += math.max(0, math.min(CONF_RSI_WEIGHT, GLOBAL_learning.divEdge * 100))
        // Profit Factor: CONF_PF_WEIGHT% weight - map STATIC_CONF_PF_MIN_MAP-STATIC_CONF_PF_MAX_MAP â†’ 0-15
        float pf_norm = math.max(0, math.min(CONF_PF_WEIGHT, (GLOBAL_learning.profitFactor - STATIC_CONF_PF_MIN_MAP) * 10))
        conf_base += pf_norm
        // Streak Penalty: -15% if on losing streak of STREAK_LOSS_PENALTY_THRESH+, bonus for win streak
        float streak_adj = 0.0
        if consecutive_losses >= STREAK_LOSS_PENALTY_THRESH
            streak_adj := -math.min(STREAK_PENALTY_MAX, (consecutive_losses - STREAK_LOSS_PENALTY_BASE) * STATIC_STREAK_PENALTY_RATE)
        else if consecutive_wins >= STREAK_WIN_BONUS_THRESH
            streak_adj := math.min(STREAK_BONUS_MAX, (consecutive_wins - STREAK_WIN_BONUS_BASE) * STATIC_STREAK_BONUS_RATE)  // Smaller bonus than penalty
        conf_base += streak_adj
        // Health Component: CONF_HEALTH_WEIGHT% - full points if healthy, 0 if not
        bool is_healthy = not is_stale and sane_wr and sane_pf
        conf_base += is_healthy ? CONF_HEALTH_WEIGHT : 0
        // Final base confidence clamped to 0-100 (direction/decay adjustments done per-bar)
        GLOBAL_learning.confidence := math.max(0, math.min(100, conf_base))
    
    // Use empirical win rate if learning enabled and sufficient data
    // Use direction-specific win rate for more accurate Kelly sizing
    float p_effective = p_base
    if INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_SL
        // Use direction-specific win rate if we have enough samples per direction
        bool has_dir_data = (is_long_setup and GLOBAL_learning.wrLong != DEFAULT_WIN_RATE) or (not is_long_setup and GLOBAL_learning.wrShort != DEFAULT_WIN_RATE)
        if has_dir_data
            float raw_dir_wr = is_long_setup ? GLOBAL_learning.wrLong : GLOBAL_learning.wrShort
            p_effective := math.max(0.30, math.min(0.70, raw_dir_wr))
        else
            // Use clamped GLOBAL_learning.winRate (already clamped during calculation)
            p_effective := na(GLOBAL_learning.winRate) ? p_base : GLOBAL_learning.winRate
    
    // Apply regime-specific win rate adjustment based on current volatility
    float p_regime_adjusted = p_effective
    float current_regime_percentile = GLOBAL_regime.atrPercentile
    bool is_high_vol_regime = current_regime_percentile >= VOL_REGIME_HIGH_THRESH
    bool is_low_vol_regime = current_regime_percentile <= VOL_REGIME_LOW_THRESH
    bool has_regime_data = INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_regime_data
        if is_high_vol_regime and GLOBAL_learning.wrHighVol != DEFAULT_WIN_RATE
            // Blend: 70% direction WR + 30% regime WR for stability
            p_regime_adjusted := p_effective * 0.7 + GLOBAL_learning.wrHighVol * 0.3
        else if is_low_vol_regime and GLOBAL_learning.wrLowVol != DEFAULT_WIN_RATE
            p_regime_adjusted := p_effective * 0.7 + GLOBAL_learning.wrLowVol * 0.3
    
    // Apply learned RSI weight to boost probability when divergence is present
    float p_rsi_adjusted = p_regime_adjusted
    bool has_learned_rsi_weight = INPUT_LEARN_RSI_WEIGHT and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_learned_rsi_weight and rsi_confirm and GLOBAL_learning.rsiWeight > 0
        // Boost win rate by learned edge: p + (edge * weight * (1-p))
        float boost = GLOBAL_learning.divEdge * GLOBAL_learning.rsiWeight * (1 - p_regime_adjusted)
        p_rsi_adjusted := math.min(0.95, p_regime_adjusted + boost)
    
    float p = p_rsi_adjusted * time_decay
    float q = 1 - p
    float b = rr_ratio
    float kelly_full = b > 0 ? (p * b - q) / b : 0
    
    // Apply confidence-based Kelly scaling
    float conf_scale = 1.0
    bool has_conf_data = INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_conf_data
        // Map confidence 30-80 â†’ scale 0.5-1.0
        conf_scale := math.max(0.5, math.min(1.0, (GLOBAL_learning.confidence - 30) / 50))
    
    float kelly_adj = math.max(0, kelly_full) * INPUT_POS_KELLY_FRAC * conf_scale  // Apply fractional Kelly + confidence
    float kelly_pct = math.min(kelly_adj * 100, 25)  // Cap at 25% max risk per trade
    
    // Expected Value (EV) Calculation
    // EV = (P_win Ã— Reward) - (P_loss Ã— Risk) per unit risked
    float ev_absolute = (p * reward) - (q * risk)  // Absolute EV in price units (time-decay adjusted)
    float ev_per_risk = risk > 0 ? ev_absolute / risk : 0  // EV per unit of risk (normalized)
    float ev_percent = ev_per_risk * 100  // As percentage
    
    // Confidence interval using standard error approximation
    // Standard deviation of Bernoulli outcome scaled by payoff
    float variance = p * math.pow(reward, 2) + q * math.pow(risk, 2) - math.pow(ev_absolute, 2)
    float std_dev = math.sqrt(math.max(0, variance))
    // 95% confidence interval (1.96 standard errors) assuming ~20 trade sample
    float margin_of_error = 1.96 * std_dev / math.sqrt(20)
    float ev_lower_95 = ev_absolute - margin_of_error
    bool ev_significant = ev_lower_95 > 0  // True if 95% confident EV is positive
    
    // EV quality indicator
    string ev_grade = ev_percent <= 0 ? UI_TEXT_EV_NEG : ev_percent < 10 ? UI_TEXT_EV_MARGINAL : ev_percent < 25 ? UI_TEXT_EV_DECENT : ev_percent < 50 ? UI_TEXT_EV_STRONG : UI_TEXT_EV_EXCEPT
    string ev_conf = ev_significant ? UI_TEXT_EV_CONF_YES : UI_TEXT_EV_CONF_NO
    
    // Kelly edge quality indicator
    string kelly_grade = kelly_pct <= 0 ? "NO EDGE" : kelly_pct < 5 ? "weak" : kelly_pct < 10 ? "decent" : kelly_pct < 15 ? "strong" : "excellent"
    
    // Confluence indicators for display
    string div_icon = rsi_confirm ? " âœ“DIV" : ""
    string vol_icon = vol_confirm ? " âœ“VOL" : ""
    
    // Status text (include time decay status)
    string invalid_reason = sl_breached ? TEXT_SL_HIT : (zone_expired ? TEXT_EXPIRED : "")
    string status = is_invalid ? invalid_reason : (in_zone ? TEXT_ACTIVE + div_icon + vol_icon + time_status : time_status)
    string kelly_text = kelly_pct > 0 ? "\nKelly: " + str.tostring(kelly_pct, "#.#") + "% (" + kelly_grade + ")" : "\nKelly: " + kelly_grade
    string ev_text = "\nEV: " + str.tostring(ev_percent, "#.#") + "% " + ev_conf + " (" + ev_grade + ")"
    
    // Learning stats for display
    string learn_text = ""
    if INPUT_LEARNING_ENABLED
        int sample_count = GLOBAL_setupHistory.size()
        if sample_count >= 10
            learn_text := "\n" + UI_ICON_CHART + " " + str.tostring(sample_count) + TEXT_SAMPLES
            if GLOBAL_learning.zoneBuffer > 0
                learn_text += TEXT_L_BUF + str.tostring(GLOBAL_learning.zoneBuffer, "#.##") + "%"
            if sample_count >= 20
                learn_text += TEXT_L_WR + str.tostring(GLOBAL_learning.winRate * 100, "#.#") + "%"
                // Extended metrics display
                if GLOBAL_learning.avgMae > 0
                    learn_text += TEXT_L_MAE + str.tostring(GLOBAL_learning.avgMae, "#.#") + "R"
                    learn_text += TEXT_L_MFE + str.tostring(GLOBAL_learning.avgMfe, "#.#") + "R"
                    learn_text += TEXT_L_SL_MULT + str.tostring(GLOBAL_learning.slMult, "#.#") + "x"
                if GLOBAL_learning.avgBars > 0
                    learn_text += TEXT_L_TAU + str.tostring(GLOBAL_learning.avgBars) + TEXT_BARS
                // Advanced analytics display (RSI divergence edge)
                if GLOBAL_learning.divEdge != 0
                    string div_sign = GLOBAL_learning.divEdge > 0 ? "+" : ""
                    learn_text += TEXT_L_DIV + div_sign + str.tostring(GLOBAL_learning.divEdge * 100, "#.#") + TEXT_L_EDGE
                // Direction-specific win rates (show if significant difference)
                float dir_diff = math.abs(GLOBAL_learning.wrLong - GLOBAL_learning.wrShort)
                if dir_diff > 0.05  // >5% difference
                    learn_text += TEXT_L_LONG + str.tostring(GLOBAL_learning.wrLong * 100, "#") + "%" + TEXT_L_SHORT + str.tostring(GLOBAL_learning.wrShort * 100, "#") + "%"
                // Losing MAE (informative: where trades went wrong)
                if GLOBAL_learning.losingMae > 0
                    learn_text += TEXT_L_XMAE + str.tostring(GLOBAL_learning.losingMae, "#.#") + TEXT_R_SUFFIX
                // Show learned parameters
                if sample_count >= INPUT_LEARN_MIN_SAMPLES
                    string p3_text = ""
                    // Show learned TP mode recommendation
                    if INPUT_LEARN_TP and (GLOBAL_learning.consEv != 0 or GLOBAL_learning.aggrEv != 0)
                        string tp_rec = GLOBAL_learning.tpAggressive ? TEXT_TP_AGGR : TEXT_TP_CONS
                        p3_text += TEXT_L_TP + tp_rec + UI_ICON_CHECK
                    // Show learned decay rate if different from default
                    if INPUT_LEARN_DECAY and math.abs(GLOBAL_learning.decayRate - DEFAULT_DECAY_RATE) > 0.02
                        p3_text += TEXT_L_DECAY + str.tostring(GLOBAL_learning.decayRate, "#.##")
                    // Show learned RSI weight if significant
                    if INPUT_LEARN_RSI_WEIGHT and GLOBAL_learning.rsiWeight > 0.1
                        p3_text += TEXT_L_RSIWT + str.tostring(GLOBAL_learning.rsiWeight, "#.#")
                    if str.length(p3_text) > 0
                        learn_text += p3_text
                    // Confidence scoring and regime analytics
                    string p4_text = ""
                    // Calculate per-bar adjusted confidence (add direction alignment + time decay + regime)
                    float adjusted_conf = GLOBAL_learning.confidence
                    // Direction Alignment Adjustment: Â±10% based on current direction's relative WR
                    float dir_wr = is_long_setup ? GLOBAL_learning.wrLong : GLOBAL_learning.wrShort
                    float opp_wr = is_long_setup ? GLOBAL_learning.wrShort : GLOBAL_learning.wrLong
                    float dir_edge = dir_wr - opp_wr
                    adjusted_conf += dir_edge * 50  // Â±10% edge â†’ Â±5 points
                    // Time Decay Adjustment: Â±10% (fresh setup = +10, expired = -10)
                    adjusted_conf += (time_decay - 0.5) * 20  // 1.0â†’+10, 0.5â†’0, 0â†’-10
                    // Regime Adjustment: Â±5% based on current vol regime performance
                    float regime_wr = current_regime_percentile >= VOL_REGIME_HIGH_THRESH ? GLOBAL_learning.wrHighVol : 
                                      current_regime_percentile <= VOL_REGIME_LOW_THRESH ? GLOBAL_learning.wrLowVol : GLOBAL_learning.winRate
                    if regime_wr != DEFAULT_WIN_RATE  // Only if we have regime data
                        float regime_edge = regime_wr - GLOBAL_learning.winRate
                        adjusted_conf += regime_edge * 50  // Â±10% edge â†’ Â±5 points
                    adjusted_conf := math.max(0, math.min(100, adjusted_conf))
                    // Unified Confidence Score with grade
                    string conf_grade = adjusted_conf < CONF_UI_GRADE_D_THRESH ? UI_GRADE_D : adjusted_conf < CONF_UI_GRADE_C_THRESH ? UI_GRADE_C : adjusted_conf < CONF_UI_GRADE_B_THRESH ? UI_GRADE_B : adjusted_conf < CONF_UI_GRADE_A_THRESH ? UI_GRADE_A : UI_UI_GRADE_APLUS
                    string health_icon = GLOBAL_learning.isHealthy ? UI_ICON_CHECK : UI_ICON_WARNING
                    p4_text += TEXT_L_CONF + str.tostring(adjusted_conf, "#") + TEXT_PCT_SUFFIX + TEXT_SPACE + conf_grade + TEXT_SPACE + health_icon
                    // Profit Factor (only show if meaningful)
                    if GLOBAL_learning.profitFactor > 0
                        string pf_rating = GLOBAL_learning.profitFactor < 1.0 ? UI_SYM_MINUS : GLOBAL_learning.profitFactor < 1.5 ? UI_SYM_CIRCLE : GLOBAL_learning.profitFactor < 2.0 ? UI_SYM_PLUS : UI_UI_SYM_PLUSPLUS
                        p4_text += TEXT_L_PF + str.tostring(GLOBAL_learning.profitFactor, "#.##") + pf_rating
                    // Expectancy per trade
                    if GLOBAL_learning.expectancy != 0
                        string exp_sign = GLOBAL_learning.expectancy > 0 ? UI_SYM_PLUS : ""
                        p4_text += TEXT_L_EXP + exp_sign + str.tostring(GLOBAL_learning.expectancy, "#.##") + TEXT_R_SUFFIX
                    // Regime indicator: Show if we're in favorable/unfavorable vol regime (use real-time percentile)
                    if current_regime_percentile >= VOL_REGIME_HIGH_THRESH and GLOBAL_learning.wrHighVol != DEFAULT_WIN_RATE
                        string vol_edge = GLOBAL_learning.wrHighVol > GLOBAL_learning.winRate ? UI_SYM_UP : GLOBAL_learning.wrHighVol < GLOBAL_learning.winRate ? UI_SYM_DOWN : UI_SYM_EQUAL
                        p4_text += TEXT_L_HIGHVOL + vol_edge + TEXT_SPACE + str.tostring(GLOBAL_learning.wrHighVol * 100, "#") + TEXT_PCT_SUFFIX
                    else if current_regime_percentile <= VOL_REGIME_LOW_THRESH and GLOBAL_learning.wrLowVol != DEFAULT_WIN_RATE
                        string vol_edge = GLOBAL_learning.wrLowVol > GLOBAL_learning.winRate ? UI_SYM_UP : GLOBAL_learning.wrLowVol < GLOBAL_learning.winRate ? UI_SYM_DOWN : UI_SYM_EQUAL
                        p4_text += TEXT_L_LOWVOL + vol_edge + TEXT_SPACE + str.tostring(GLOBAL_learning.wrLowVol * 100, "#") + TEXT_PCT_SUFFIX
                    // Sharpe Ratio (risk-adjusted return)
                    if GLOBAL_learning.sharpeRatio != 0
                        string sr_rating = GLOBAL_learning.sharpeRatio < 0 ? UI_SYM_MINUS : GLOBAL_learning.sharpeRatio < 1 ? UI_SYM_CIRCLE : GLOBAL_learning.sharpeRatio < 2 ? UI_SYM_PLUS : UI_UI_SYM_PLUSPLUS
                        p4_text += TEXT_L_SR + str.tostring(GLOBAL_learning.sharpeRatio, "#.##") + sr_rating
                    // Streak warning (show win streak as positive indicator too)
                    if GLOBAL_learning.lossStreak >= STREAK_LOSS_PENALTY_THRESH
                        p4_text += TEXT_L_WARN + str.tostring(GLOBAL_learning.lossStreak) + TEXT_L_STREAK_L
                    else if GLOBAL_learning.winStreak >= STREAK_WIN_BONUS_THRESH
                        p4_text += TEXT_L_FIRE + str.tostring(GLOBAL_learning.winStreak) + TEXT_L_STREAK_W
                    if str.length(p4_text) > 0
                        learn_text += p4_text
        else
            learn_text := "\n" + TEXT_LEARNING + " (" + str.tostring(sample_count) + "/" + str.tostring(INPUT_LEARNING_SAMPLES) + ")"
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Status label: distinguish confirmed vs projected
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Use stored values when setup is active for display consistency with tracking
    // BUT show current calculated values (with learning) so user sees adjusted prices
    float display_tp_text = tp_price  // Always show current calculation with learning
    float display_sl_text = sl_price  // Always show current calculation with learning
    // Use current calculation for display (projection shows current direction)
    bool display_is_long = isProjection ? is_long_setup : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.hasFlag(STATIC_FLAG_IS_LONG) : is_long_setup)
    
    // Status prefix: clearly distinguish between Confirmed Active and Projected trades
    // âš¡PROJ = Projection (tentative, not recorded to learning)
    // âœ“ACTIVE = Confirmed Active (tracked, will be recorded)
    string trade_state_indicator = isProjection ? TEXT_PROJ_TAG : (not na(GLOBAL_activeTrade.setup_bar) ? TEXT_ACTIVE_TAG : "")
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BACKTEST STATS DISPLAY - Show optimization results on the dashboard
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    string backtest_text = ""
    if GLOBAL_backtest.stats.statsReady and GLOBAL_backtest.stats.totalTrades > 0
        // Low confidence warning
        string conf_warning = GLOBAL_backtest.stats.lowConfidence ? TEXT_BT_LOW : ""
        backtest_text := TEXT_BT_PREFIX + str.tostring(GLOBAL_backtest.stats.totalTrades) + TEXT_BT_TRADES + str.tostring(math.round(GLOBAL_backtest.stats.winRate * 100)) + TEXT_BT_WR + conf_warning
        // Show Smart SL if available
        if GLOBAL_backtest.stats.smartSlOffset > 0
            float smart_sl_price = display_is_long ? mid_entry - GLOBAL_backtest.stats.smartSlOffset : mid_entry + GLOBAL_backtest.stats.smartSlOffset
            backtest_text += TEXT_SMART_SL + str.tostring(smart_sl_price, format.mintick)
    else if GLOBAL_backtest.stats.totalTrades == 0
        backtest_text := TEXT_BT_EMPTY
    
    string pos_text = (display_is_long ? TEXT_LONG : TEXT_SHORT) + TEXT_SETUP + trade_state_indicator + status + TEXT_TP_PREFIX + str.tostring(display_tp_text, format.mintick) + TEXT_SL_PREFIX + str.tostring(display_sl_text, format.mintick) + TEXT_RR_PREFIX + str.tostring(rr_ratio, "#.##") + ev_text + kelly_text + learn_text + backtest_text
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LEARNING ENGINE: Record CONFIRMED setup outcome on pivot change (NEVER projections)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Record previous CONFIRMED setup BEFORE resetting state (order matters!)
    // Only record from GLOBAL_activeTrade (never from projection data)
    bool should_record = INPUT_LEARNING_ENABLED and GLOBAL_zigzag.changed and not na(GLOBAL_activeTrade.setup_bar)
    if should_record
        // Calculate bars to outcome (0 if neither SL nor TP hit)
        int bars_to_out = GLOBAL_activeTrade.hasAny(STATIC_MASK_OUTCOME) and not na(GLOBAL_activeTrade.entry_bar) ? 
                          (bar_index - GLOBAL_activeTrade.entry_bar) : 0
        
        // Compute trade log return for Sortino calculation
        // Win: positive R (TP hit), Loss: negative R (SL hit)
        float trade_entry = nz(GLOBAL_activeTrade.entry_price, (GLOBAL_activeTrade.zone_top + GLOBAL_activeTrade.zone_bottom) / 2)
        float trade_log_ret = 0.0
        if GLOBAL_activeTrade.hasFlag(STATIC_FLAG_TP_HIT) and not GLOBAL_activeTrade.hasFlag(STATIC_FLAG_SL_HIT)
            // Win: log return from entry to TP
            trade_log_ret := f_logReturn(GLOBAL_activeTrade.tp_price, trade_entry)
            // Ensure sign matches direction (longs profit when price rises, shorts when price falls)
            if not GLOBAL_activeTrade.hasFlag(STATIC_FLAG_IS_LONG)
                trade_log_ret := -trade_log_ret
        else if GLOBAL_activeTrade.hasFlag(STATIC_FLAG_SL_HIT)
            // Loss: log return from entry to SL (negative)
            trade_log_ret := f_logReturn(GLOBAL_activeTrade.sl_price, trade_entry)
            if not GLOBAL_activeTrade.hasFlag(STATIC_FLAG_IS_LONG)
                trade_log_ret := -trade_log_ret
        
        // Record the previous CONFIRMED setup's outcome before it changes
        SetupRecord completed_setup = SetupRecord.new(
            GLOBAL_activeTrade.setup_bar,           // setup_bar
            GLOBAL_activeTrade.state_mask,          // state_mask (copy all flags directly)
            GLOBAL_activeTrade.zone_top,            // zone_top
            GLOBAL_activeTrade.zone_bottom,         // zone_bottom
            GLOBAL_activeTrade.sl_price,            // sl_level
            GLOBAL_activeTrade.tp_price,            // tp_level
            GLOBAL_activeTrade.min_distance,        // closest_approach
            bars_to_out,                            // bars_to_outcome
            GLOBAL_activeTrade.max_adverse,         // max_adverse (ATR units)
            GLOBAL_activeTrade.max_favorable,       // max_favorable (ATR units)
            trade_entry,                            // entry_price
            nz(GLOBAL_activeTrade.atr_at_setup, 1.0),        // atr_at_setup
            nz(GLOBAL_activeTrade.rsi_at_entry, 50.0),       // rsi_at_entry
            GLOBAL_activeTrade.tp_cons,             // tp_conservative
            GLOBAL_activeTrade.tp_aggr,             // tp_aggressive
            GLOBAL_activeTrade.vol_percentile,      // vol_percentile
            GLOBAL_regime.entropyRegime,            // entropy_regime
            GLOBAL_regime.entropyNorm,              // entropy_norm
            GLOBAL_regime.hurstRegime,              // hurst_regime
            GLOBAL_regime.hurst,                    // hurst_value
            GLOBAL_regime.zscore,                   // zscore_value
            GLOBAL_regime.strongMomentum,           // strong_momentum
            trade_log_ret                           // log_return
        )
        
        // Record last outcome bar for staleness detection
        GLOBAL_learning.lastOutcomeBar := bar_index
        
        // Add to circular buffer (O(1) operation, auto-overwrites oldest when full)
        GLOBAL_setupHistory.push(completed_setup)
        
        // Set flag to trigger learning recalculation
        GLOBAL_learning.needsRecalc := true
    
    // Initialize CONFIRMED trade tracking - ONLY reset on GLOBAL_zigzag.changed (never for projections)
    // This ensures Learning Engine data is ONLY from confirmed ZigZag pivots
    if GLOBAL_zigzag.changed
        // Use CONFIRMED pivot (GLOBAL_cachedPivots.iMidPivot), NOT effective pivot (which includes projections)
        GLOBAL_activeTrade.setup_bar := GLOBAL_cachedPivots.iMidPivot
        // Store creation_bar for proper time decay
        // Confirmed pivots are detected GLOBAL_pivotLength bars AFTER they occur
        // So GLOBAL_cachedPivots.iMidPivot is typically bar_index - GLOBAL_pivotLength
        // creation_bar tracks when WE created the setup, not when the pivot occurred
        GLOBAL_activeTrade.creation_bar := bar_index
        // Build initial state_mask: direction + TP mode (using arithmetic for raw int)
        int new_state = (is_long_setup ? STATIC_FLAG_IS_LONG : 0) + (use_aggressive_tp ? STATIC_FLAG_TP_AGGRESSIVE : 0)
        GLOBAL_activeTrade.state_mask := new_state
        GLOBAL_activeTrade.zone_top := adjusted_box_top
        GLOBAL_activeTrade.zone_bottom := adjusted_box_bottom
        GLOBAL_activeTrade.sl_price := sl_price
        GLOBAL_activeTrade.tp_price := tp_price
        GLOBAL_activeTrade.tp_cons := tp_conservative
        GLOBAL_activeTrade.tp_aggr := tp_aggressive
        GLOBAL_activeTrade.min_distance := DEFAULT_MIN_DISTANCE
        // Extended tracking reset
        GLOBAL_activeTrade.entry_bar := na
        GLOBAL_activeTrade.entry_price := na
        GLOBAL_activeTrade.max_adverse := 0.0
        GLOBAL_activeTrade.max_favorable := 0.0
        GLOBAL_activeTrade.atr_at_setup := nz(GLOBAL_regime.rawAtr, 1.0)
        GLOBAL_activeTrade.rsi_at_entry := na
        // Regime tracking reset
        GLOBAL_activeTrade.vol_percentile := atr_percentile  // Capture current volatility regime

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Visual styling: confirmed vs projection
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIRMED (GLOBAL_activeTrade valid): Solid/dotted lines with full opacity
    // PROJECTION (tentative preview):    Dashed lines with higher transparency
    // This provides clear visual distinction between actionable vs tentative setups
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Determine which state we're displaying
    bool hasConfirmedTrade = not na(GLOBAL_activeTrade.setup_bar)
    bool showingProjection = isProjection
    
    // Visual style settings based on state
    // Confirmed: dotted (standard), Projection: dashed (tentative)
    var string box_style = line.style_dotted
    box_style := showingProjection ? line.style_dotted : line.style_solid
    
    // Transparency: Scale by INPUT_PROJ_SENSITIVITY for projections
    // Lower sensitivity (more stable) = more opaque. Higher sensitivity (more volatile) = more transparent.
    // Formula: 80 - (sensitivity * 40) â†’ at 0.5 sens = 60 trans, at 1.0 sens = 40 trans, at 0.1 sens = 76 trans
    int sl_tp_transparency = showingProjection ? int(80 - INPUT_PROJ_SENSITIVITY * 40) : 5
    color sl_line_col = is_invalid ? color.new(COLOR_GRAY, 60) : color.new(COLOR_RED, sl_tp_transparency)
    color tp_line_col = is_invalid ? color.new(COLOR_GRAY, 60) : color.new(COLOR_GREEN, sl_tp_transparency)
    
    // Display current calculated values (with learning) for SL/TP lines
    // Zone boundaries: for projection mode, use current calculated; otherwise use confirmed trade values
    float display_sl = sl_price  // Show learning-adjusted SL
    float display_tp = tp_price  // Show learning-adjusted TP
    float display_zone_top = isProjection ? adjusted_box_top : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.zone_top : adjusted_box_top)
    float display_zone_bottom = isProjection ? adjusted_box_bottom : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.zone_bottom : adjusted_box_bottom)
    
    // Calculate Smart SL price based on backtest optimization
    float smart_sl_price = na
    bool show_smart_sl = GLOBAL_backtest.stats.statsReady and GLOBAL_backtest.stats.smartSlOffset > 0
    if show_smart_sl
        smart_sl_price := is_long_setup ? mid_entry - GLOBAL_backtest.stats.smartSlOffset : mid_entry + GLOBAL_backtest.stats.smartSlOffset
    color smart_sl_col = color.new(color.orange, 20)  // Orange for Smart SL (distinct from red structural SL)
    
    // Track projection state changes for object recreation
    var bool wasProjection = false
    bool projectionStateChanged = isProjection != wasProjection
    wasProjection := isProjection
    
    // Determine line style: solid for confirmed, dotted for projection
    string lineStyleStr = showingProjection ? "dotted" : "solid"
    
    // Calculate Smart SL for method calls
    float smartSlForMethod = show_smart_sl ? smart_sl_price : na
    
    // On pivot change OR projection state change, delete old objects and create fresh ones
    bool needsRecreate = GLOBAL_zigzag.changed or projectionStateChanged or (isProjection and (proj_tentative_high or proj_tentative_low))
    if needsRecreate
        GLOBAL_posVisual.deleteAll()
        GLOBAL_posVisual.create(display_zone_top, display_zone_bottom, display_sl, display_tp, mid_entry, pos_text, bg_col, border_col, sl_line_col, tp_line_col, lineStyleStr, smartSlForMethod, smart_sl_col, COLOR_FG_MAIN)
    else if not GLOBAL_posVisual.exists()
        // First time creation (no pivot change yet) - always dotted
        GLOBAL_posVisual.create(display_zone_top, display_zone_bottom, display_sl, display_tp, mid_entry, pos_text, bg_col, border_col, sl_line_col, tp_line_col, "dotted", smartSlForMethod, smart_sl_col, COLOR_FG_MAIN)
    else
        // Update existing objects with current values (dynamic learning adjustments)
        GLOBAL_posVisual.update(display_zone_top, display_zone_bottom, display_sl, display_tp, mid_entry, pos_text, bg_col, border_col, sl_line_col, tp_line_col, smartSlForMethod, smart_sl_col)
    
    // Populate global alert state for use in ALERTS section
    bool as_zone_touched = not na(GLOBAL_activeTrade.setup_bar) and GLOBAL_activeTrade.hasFlag(STATIC_FLAG_ZONE_TOUCHED)
    bool as_sl_hit = not na(GLOBAL_activeTrade.setup_bar) and GLOBAL_activeTrade.hasFlag(STATIC_FLAG_SL_HIT)
    bool as_tp_hit = not na(GLOBAL_activeTrade.setup_bar) and GLOBAL_activeTrade.hasFlag(STATIC_FLAG_TP_HIT)
    int as_creation_bar = isProjection ? bar_index : nz(GLOBAL_activeTrade.creation_bar, bar_index)
    GLOBAL_alertState.populate(
        isProjection, is_long_setup, as_zone_touched, as_sl_hit, as_tp_hit,
        in_zone, zone_entry, use_aggressive_tp, zone_expired,
        box_top, box_bottom, adjusted_box_top, adjusted_box_bottom, adaptive_buffer,
        nz(GLOBAL_activeTrade.min_distance, DEFAULT_MIN_DISTANCE),
        sl_price, tp_price, tp_conservative, tp_aggressive, effective_sl_mult, current_atr,
        smart_sl_price, as_creation_bar, bars_since_creation, time_phase, decay_rate)
    
    // Alert on zone entry with full JSON context
    if zone_entry and INPUT_ALERT_ENABLED
        string entry_msg = f_getAlertMessageFull(STATIC_ALERT_ID_ENTRY, "zone_entry",
            GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
            GLOBAL_alertState.stopLossHit, GLOBAL_alertState.takeProfitHit, GLOBAL_alertState.rawZoneTop,
            GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
            GLOBAL_alertState.bufferPercent, GLOBAL_alertState.isInZone, GLOBAL_alertState.isZoneEntry,
            GLOBAL_alertState.minimumDistance, GLOBAL_alertState.stopLossPrice, GLOBAL_alertState.takeProfitPrice,
            GLOBAL_alertState.takeProfitConservative, GLOBAL_alertState.takeProfitAggressive, GLOBAL_alertState.useAggressiveTakeProfit,
            GLOBAL_alertState.stopLossMultiplier, GLOBAL_alertState.averageTrueRange, GLOBAL_alertState.smartStopLoss,
            GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
            GLOBAL_alertState.decayRate, GLOBAL_alertState.isExpired)
        alert(entry_msg, alert.freq_once_per_bar)

// AddOns
plotchar(INPUT_SHOW_VOL_SPIKE and nzVolume != 0 ? exhaustVol : false, UI_LABEL_EXHAUST, UI_ICON_TRAFFIC, location.abovebar, size=size.tiny, display = display.pane)
plotchar(INPUT_SHOW_HIGH_ATR ? highVolatility : false, UI_LABEL_HIGH_VOL, UI_ICON_LIGHTNING, location.belowbar, size=size.tiny, display = display.pane)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATUS LINE VALUES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GLOBAL_priceStart = GLOBAL_cachedPivots.pMidPivot
UI_priceEnd   = GLOBAL_cachedPivots.pEndBase
UI_fibLevel50    = GLOBAL_confirmedPivot.getLevel(0.5)
UI_fibLevel618   = GLOBAL_confirmedPivot.getLevel(FIB_GOLDEN_RATIO)

plot(GLOBAL_priceStart, "Pivot Start", color = color.new(color.gray, 0), display = display.data_window + display.status_line)
plot(UI_priceEnd,   "Pivot End",   color = color.new(color.white, 0), display = display.data_window + display.status_line)
plot(UI_fibLevel50,    "Fib 0.50",    color = color.new(color.yellow, 0), display = display.data_window + display.status_line)
plot(UI_fibLevel618,   "Fib 0.618",   color = color.new(color.orange, 0), display = display.data_window + display.status_line)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if INPUT_ALERT_ENABLED
    // Event-based alert routing
    if INPUT_ALERT_MODE == 'calculateAlertUpdates'
        // FBU: Full state snapshot on bar confirmation
        if barstate.isconfirmed
            string fbu_msg = f_getAlertMessageFull(STATIC_ALERT_ID_UPDATE, "fib_update",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(fbu_msg, alert.freq_once_per_bar)
        
        // SCT: Setup created on pivot change
        if GLOBAL_zigzag.changed and barstate.isconfirmed
            string sct_msg = f_getAlertMessageFull(STATIC_ALERT_ID_SETUP, "setup_created",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(sct_msg, alert.freq_once_per_bar)
        
        // EXH: Volume exhaustion signal
        if exhaustVol and barstate.isconfirmed
            string exh_msg = f_getAlertMessageFull(STATIC_ALERT_ID_EXHAUSTION, "vol_exhaustion",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(exh_msg, alert.freq_once_per_bar)
        
        // HVO: High volatility signal
        if highVolatility and barstate.isconfirmed
            string hvo_msg = f_getAlertMessageFull(STATIC_ALERT_ID_VOLATILITY, "high_volatility",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(hvo_msg, alert.freq_once_per_bar)
        
        // LRN: Learning recalculated
        if GLOBAL_learning.needsRecalc and barstate.isconfirmed
            string lrn_msg = f_getAlertMessageFull(STATIC_ALERT_ID_LEARNING, "learning_recalc",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(lrn_msg, alert.freq_once_per_bar)
    
    else if INPUT_ALERT_MODE == 'calculateAlertData'
        // Full snapshot on every confirmed bar
        if barstate.isconfirmed
            string full_msg = f_getAlertMessageFull(STATIC_ALERT_ID_UPDATE, "fib_update",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(full_msg, alert.freq_once_per_bar)
    
    // Clear logs on history for performance
    if barstate.ishistory
        GLOBAL_pivotLevelsLogRetracements.clear()
        GLOBAL_pivotLevelsLogCrossed.clear()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENTROPY DEBUG OVERLAY - Last bar only
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Displays entropy engine diagnostics
//       Only renders on barstate.islast to avoid per-bar label spam.
//       Triggered by explicit toggle OR Debug preset (via perf_shouldShowDebugOverlay).
if perf_shouldShowDebugOverlay(INPUT_ENTROPY_DEBUG)
    var table entropyDebugTable = table.new(position.bottom_right, 2, 11, bgcolor = color.new(color.black, 80), border_width = 1)
    
    table.cell(entropyDebugTable, 0, 0, UI_TBL_ENTROPY, text_color = color.white, text_size = size.small)
    table.cell(entropyDebugTable, 1, 0, "", text_color = color.white, text_size = size.small)
    
    table.cell(entropyDebugTable, 0, 1, UI_FLD_MODE, text_color = color.gray, text_size = size.tiny)
    table.cell(entropyDebugTable, 1, 1, INPUT_ENTROPY_MODE, text_color = color.yellow, text_size = size.tiny)
    
    string _modeDetail = INPUT_ENTROPY_MODE == ENTROPY_MODE_LEGACY ? "O(N) bins" : "O(1) symbolic"
    table.cell(entropyDebugTable, 0, 2, UI_FLD_COMPLEXITY, text_color = color.gray, text_size = size.tiny)
    table.cell(entropyDebugTable, 1, 2, _modeDetail, text_color = INPUT_ENTROPY_MODE == ENTROPY_MODE_LEGACY ? color.orange : color.green, text_size = size.tiny)
    
    int _states = INPUT_ENTROPY_MODE == ENTROPY_MODE_LEGACY ? INPUT_ENTROPY_BINS : INPUT_ENTROPY_MODE == ENTROPY_MODE_BINARY ? 2 : int(math.pow(2, INPUT_ENTROPY_K))
    table.cell(entropyDebugTable, 0, 3, UI_FLD_STATES, text_color = color.gray, text_size = size.tiny)
    table.cell(entropyDebugTable, 1, 3, str.tostring(_states), text_color = color.white, text_size = size.tiny)
    
    table.cell(entropyDebugTable, 0, 4, UI_FLD_K_GRAM, text_color = color.gray, text_size = size.tiny)
    table.cell(entropyDebugTable, 1, 4, INPUT_ENTROPY_MODE == ENTROPY_MODE_KGRAM ? str.tostring(INPUT_ENTROPY_K) : TEXT_DASH, text_color = color.white, text_size = size.tiny)
    
    table.cell(entropyDebugTable, 0, 5, UI_FLD_WINDOW, text_color = color.gray, text_size = size.tiny)
    table.cell(entropyDebugTable, 1, 5, str.tostring(INPUT_ENTROPY_WINDOW), text_color = color.white, text_size = size.tiny)
    
    table.cell(entropyDebugTable, 0, 6, UI_FLD_H_RAW, text_color = color.gray, text_size = size.tiny)
    table.cell(entropyDebugTable, 1, 6, str.tostring(GLOBAL_regime.entropy, "#.####"), text_color = color.white, text_size = size.tiny)
    
    table.cell(entropyDebugTable, 0, 7, UI_FLD_H_NORM, text_color = color.gray, text_size = size.tiny)
    table.cell(entropyDebugTable, 1, 7, str.tostring(GLOBAL_regime.entropyNorm, "#.####"), text_color = color.yellow, text_size = size.tiny)
    
    string _regimeStr = GLOBAL_regime.entropyRegime == ENTROPY_REGIME_ORDERED ? "ORDERED" : GLOBAL_regime.entropyRegime == ENTROPY_REGIME_TRANSITION ? "TRANSITION" : "DISORDERED"
    color _regimeColor = GLOBAL_regime.entropyRegime == ENTROPY_REGIME_ORDERED ? color.green : GLOBAL_regime.entropyRegime == ENTROPY_REGIME_TRANSITION ? color.yellow : color.red
    table.cell(entropyDebugTable, 0, 8, UI_FLD_REGIME, text_color = color.gray, text_size = size.tiny)
    table.cell(entropyDebugTable, 1, 8, _regimeStr, text_color = _regimeColor, text_size = size.tiny)
    
    table.cell(entropyDebugTable, 0, 9, UI_FLD_ENTROPY_OK, text_color = color.gray, text_size = size.tiny)
    table.cell(entropyDebugTable, 1, 9, GLOBAL_regime.entropyOk ? UI_ICON_CHECK : UI_SYM_CROSS, text_color = GLOBAL_regime.entropyOk ? color.green : color.red, text_size = size.tiny)
    
    // Show buffer validation for symbolic modes
    if INPUT_ENTROPY_MODE != ENTROPY_MODE_LEGACY and GLOBAL_symbolicEntropy.initialized
        int _bufSize = GLOBAL_symbolicEntropy.patternBuf.size()
        int _countsSum = 0
        for i = 0 to GLOBAL_symbolicEntropy.counts.size() - 1
            _countsSum += GLOBAL_symbolicEntropy.counts.get(i)
        bool _valid = _bufSize == _countsSum
        table.cell(entropyDebugTable, 0, 10, UI_FLD_BUFFER_OK, text_color = color.gray, text_size = size.tiny)
        table.cell(entropyDebugTable, 1, 10, str.tostring(_bufSize) + "=" + str.tostring(_countsSum) + TEXT_SPACE + (_valid ? UI_ICON_CHECK : UI_ICON_WARNING), text_color = _valid ? color.green : color.red, text_size = size.tiny)
    else
        table.cell(entropyDebugTable, 0, 10, UI_FLD_BUFFER, text_color = color.gray, text_size = size.tiny)
        table.cell(entropyDebugTable, 1, 10, TEXT_DASH, text_color = color.gray, text_size = size.tiny)

// â”€â”€ HURST DEBUG OVERLAY - Hurst engine diagnostics
if perf_shouldShowDebugOverlay(INPUT_HURST_DEBUG)
    var table hurstDebugTable = table.new(position.middle_right, 2, 10, bgcolor = color.new(color.black, 80), border_width = 1)
    
    table.cell(hurstDebugTable, 0, 0, UI_TBL_HURST, text_color = color.white, text_size = size.small)
    table.cell(hurstDebugTable, 1, 0, "", text_color = color.white, text_size = size.small)
    
    table.cell(hurstDebugTable, 0, 1, UI_FLD_MODE, text_color = color.gray, text_size = size.tiny)
    table.cell(hurstDebugTable, 1, 1, INPUT_HURST_MODE, text_color = color.yellow, text_size = size.tiny)
    
    string _hurstComplexity = INPUT_HURST_MODE == STATIC_HURST_MODE_LEGACY ? "O(NÃ—scales)" : "O(log N)"
    table.cell(hurstDebugTable, 0, 2, UI_FLD_COMPLEXITY, text_color = color.gray, text_size = size.tiny)
    table.cell(hurstDebugTable, 1, 2, _hurstComplexity, text_color = INPUT_HURST_MODE == STATIC_HURST_MODE_LEGACY ? color.orange : color.green, text_size = size.tiny)
    
    // Show dyadic scales info if in dyadic mode
    string _scalesStr = "â€”"
    int _scaleCount = 0
    if INPUT_HURST_MODE != STATIC_HURST_MODE_LEGACY and GLOBAL_dyadicHurst.initialized
        _scaleCount := GLOBAL_dyadicHurst.numScales
        if _scaleCount > 0
            _scalesStr := str.tostring(GLOBAL_dyadicHurst.scales.get(0))
            if _scaleCount > 1
                _scalesStr += "â†’" + str.tostring(GLOBAL_dyadicHurst.scales.get(_scaleCount - 1))
    table.cell(hurstDebugTable, 0, 3, UI_FLD_SCALES, text_color = color.gray, text_size = size.tiny)
    table.cell(hurstDebugTable, 1, 3, str.tostring(_scaleCount) + " (" + _scalesStr + ")", text_color = color.white, text_size = size.tiny)
    
    table.cell(hurstDebugTable, 0, 4, UI_FLD_WINDOW, text_color = color.gray, text_size = size.tiny)
    table.cell(hurstDebugTable, 1, 4, str.tostring(INPUT_HURST_WINDOW), text_color = color.white, text_size = size.tiny)
    
    int _hurstBufSize = INPUT_HURST_MODE != STATIC_HURST_MODE_LEGACY and GLOBAL_dyadicHurst.initialized ? GLOBAL_dyadicHurst.returnBuf.size() : 0
    table.cell(hurstDebugTable, 0, 5, UI_FLD_BUFFER, text_color = color.gray, text_size = size.tiny)
    table.cell(hurstDebugTable, 1, 5, INPUT_HURST_MODE == STATIC_HURST_MODE_LEGACY ? "â€”" : str.tostring(_hurstBufSize), text_color = color.white, text_size = size.tiny)
    
    table.cell(hurstDebugTable, 0, 6, UI_FLD_H_VALUE, text_color = color.gray, text_size = size.tiny)
    table.cell(hurstDebugTable, 1, 6, str.tostring(GLOBAL_regime.hurst, "#.####"), text_color = color.yellow, text_size = size.tiny)
    
    string _hurstRegimeStr = GLOBAL_regime.hurstRegime == HURST_REGIME_TREND ? "TREND" : GLOBAL_regime.hurstRegime == HURST_REGIME_MEANREV ? "MEANREV" : "RANDOM"
    color _hurstRegimeColor = GLOBAL_regime.hurstRegime == HURST_REGIME_TREND ? color.green : GLOBAL_regime.hurstRegime == HURST_REGIME_MEANREV ? color.blue : color.gray
    table.cell(hurstDebugTable, 0, 7, UI_FLD_REGIME, text_color = color.gray, text_size = size.tiny)
    table.cell(hurstDebugTable, 1, 7, _hurstRegimeStr, text_color = _hurstRegimeColor, text_size = size.tiny)
    
    table.cell(hurstDebugTable, 0, 8, UI_FLD_HURST_OK, text_color = color.gray, text_size = size.tiny)
    table.cell(hurstDebugTable, 1, 8, GLOBAL_regime.hurstOk ? UI_ICON_CHECK : UI_SYM_CROSS, text_color = GLOBAL_regime.hurstOk ? color.green : color.red, text_size = size.tiny)
    
    // Show chunk mode for fast vs stable
    string _chunkMode = INPUT_HURST_MODE == STATIC_HURST_MODE_DYADIC_FAST ? "Single (recent)" : INPUT_HURST_MODE == STATIC_HURST_MODE_DYADIC_STABLE ? "All (averaged)" : "N/A"
    table.cell(hurstDebugTable, 0, 9, UI_FLD_CHUNKS, text_color = color.gray, text_size = size.tiny)
    table.cell(hurstDebugTable, 1, 9, _chunkMode, text_color = color.white, text_size = size.tiny)

// â”€â”€ EXTERNAL CONTEXT DEBUG OVERLAY - External symbols validation
if perf_shouldShowDebugOverlay(INPUT_EXT_DEBUG)
    var table extDebugTable = table.new(position.bottom_left, 2, 8, bgcolor = color.new(color.black, 80), border_width = 1)
    
    table.cell(extDebugTable, 0, 0, UI_TBL_EXT, text_color = color.white, text_size = size.small)
    table.cell(extDebugTable, 1, 0, "", text_color = color.white, text_size = size.small)
    
    table.cell(extDebugTable, 0, 1, UI_FLD_ENABLED, text_color = color.gray, text_size = size.tiny)
    table.cell(extDebugTable, 1, 1, GLOBAL_extContext.enabled ? UI_ICON_CHECK : UI_SYM_CROSS, text_color = GLOBAL_extContext.enabled ? color.green : color.red, text_size = size.tiny)
    
    table.cell(extDebugTable, 0, 2, UI_FLD_GATED, text_color = color.gray, text_size = size.tiny)
    table.cell(extDebugTable, 1, 2, GLOBAL_extContext.gated ? UI_ICON_CHECK : UI_SYM_CROSS, text_color = GLOBAL_extContext.gated ? color.green : color.gray, text_size = size.tiny)
    
    table.cell(extDebugTable, 0, 3, UI_FLD_BUDGET_OK, text_color = color.gray, text_size = size.tiny)
    table.cell(extDebugTable, 1, 3, GLOBAL_extContext.budgetExceeded ? UI_TEXT_EXCEEDED : UI_ICON_CHECK, text_color = GLOBAL_extContext.budgetExceeded ? color.orange : color.green, text_size = size.tiny)
    
    table.cell(extDebugTable, 0, 4, UI_FLD_CONTEXTS, text_color = color.gray, text_size = size.tiny)
    table.cell(extDebugTable, 1, 4, str.tostring(GLOBAL_extContext.usedContexts), text_color = color.white, text_size = size.tiny)
    
    table.cell(extDebugTable, 0, 5, UI_FLD_VALID, text_color = color.gray, text_size = size.tiny)
    table.cell(extDebugTable, 1, 5, str.tostring(GLOBAL_extContext.validCount) + "/" + str.tostring(array.size(GLOBAL_extContext.symbols)), text_color = color.white, text_size = size.tiny)
    
    table.cell(extDebugTable, 0, 6, UI_FLD_EXT_OK, text_color = color.gray, text_size = size.tiny)
    table.cell(extDebugTable, 1, 6, GLOBAL_extContext.extOk ? UI_ICON_CHECK : UI_SYM_CROSS, text_color = GLOBAL_extContext.extOk ? color.green : color.red, text_size = size.tiny)
    
    // Show first symbol + close if available
    string _symInfo = "â€”"
    if array.size(GLOBAL_extContext.symbols) > 0
        string _firstSym = array.get(GLOBAL_extContext.symbols, 0)
        float _firstClose = array.size(GLOBAL_extContext.closes) > 0 ? array.get(GLOBAL_extContext.closes, 0) : na
        _symInfo := _firstSym + ": " + (na(_firstClose) ? "na" : str.tostring(_firstClose, "#.##"))
    table.cell(extDebugTable, 0, 7, UI_FLD_SYMBOL_0, text_color = color.gray, text_size = size.tiny)
    table.cell(extDebugTable, 1, 7, _symInfo, text_color = color.white, text_size = size.tiny)

// â”€â”€ EXECUTION FLOW DEBUG OVERLAY - Function execution counters
if perf_shouldShowDebugOverlay(INPUT_DEBUG_FLOW)
    var table flowDebugTable = table.new(position.top_left, 2, 8, bgcolor = color.new(color.black, 80), border_width = 1)
    
    table.cell(flowDebugTable, 0, 0, UI_TBL_EXEC_FLOW, text_color = color.white, text_size = size.small)
    table.cell(flowDebugTable, 1, 0, "", text_color = color.white, text_size = size.small)
    
    table.cell(flowDebugTable, 0, 1, UI_FLD_ENTROPY_RUNS, text_color = color.gray, text_size = size.tiny)
    table.cell(flowDebugTable, 1, 1, str.tostring(DBG_counterEntropyRuns), text_color = color.yellow, text_size = size.tiny)
    
    table.cell(flowDebugTable, 0, 2, UI_FLD_HURST_RUNS, text_color = color.gray, text_size = size.tiny)
    table.cell(flowDebugTable, 1, 2, str.tostring(DBG_counterHurstRuns), text_color = color.yellow, text_size = size.tiny)
    
    table.cell(flowDebugTable, 0, 3, UI_FLD_ZSCORE_RUNS, text_color = color.gray, text_size = size.tiny)
    table.cell(flowDebugTable, 1, 3, str.tostring(DBG_counterZscoreRuns), text_color = color.yellow, text_size = size.tiny)
    
    table.cell(flowDebugTable, 0, 4, UI_FLD_LEARNING_RUNS, text_color = color.gray, text_size = size.tiny)
    table.cell(flowDebugTable, 1, 4, str.tostring(DBG_counterLearningRuns), text_color = color.yellow, text_size = size.tiny)
    
    table.cell(flowDebugTable, 0, 5, UI_FLD_SPAWN_ATTEMPTS, text_color = color.gray, text_size = size.tiny)
    table.cell(flowDebugTable, 1, 5, str.tostring(DBG_counterSpawnAttempts), text_color = color.green, text_size = size.tiny)
    
    table.cell(flowDebugTable, 0, 6, UI_FLD_SPAWN_BLOCKED, text_color = color.gray, text_size = size.tiny)
    table.cell(flowDebugTable, 1, 6, str.tostring(DBG_counterSpawnBlocked), text_color = color.orange, text_size = size.tiny)
    
    float _blockRate = DBG_counterSpawnAttempts > 0 ? float(DBG_counterSpawnBlocked) / float(DBG_counterSpawnAttempts) * 100 : 0.0
    table.cell(flowDebugTable, 0, 7, UI_FLD_BLOCK_RATE, text_color = color.gray, text_size = size.tiny)
    table.cell(flowDebugTable, 1, 7, str.tostring(_blockRate, "#.#") + "%", text_color = _blockRate > 50 ? color.red : color.green, text_size = size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERFORMANCE DASHBOARD - Limit-safe debug table
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Displays active performance preset and effective settings
//       Uses table.new() which has NO plot count impact (limit-safe).
//       Only renders on barstate.islast when dashboard enabled or Debug preset active.
if perf_shouldShowDashboard()
    var table perfDashboard = table.new(position.top_right, 2, 14, bgcolor = color.new(color.blue, 85), border_width = 1)
    
    // Header
    color _presetColor = INPUT_PERF_PRESET == PERF_PRESET_FAST ? color.yellow : INPUT_PERF_PRESET == PERF_PRESET_DEBUG ? color.orange : color.green
    table.cell(perfDashboard, 0, 0, UI_TBL_PERF, text_color = color.white, text_size = size.small)
    table.cell(perfDashboard, 1, 0, perf_getPresetName(), text_color = _presetColor, text_size = size.small)
    
    // Effective Settings Section
    table.cell(perfDashboard, 0, 1, UI_TBL_SECTION_SETTINGS, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 1, "", text_color = color.gray, text_size = size.tiny)
    
    // Entropy settings
    string _effEntMode = perf_getEntropyMode(INPUT_ENTROPY_MODE)
    bool _entDegraded = _effEntMode != INPUT_ENTROPY_MODE
    table.cell(perfDashboard, 0, 2, UI_FLD_ENTROPY_MODE, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 2, (_entDegraded ? UI_TEXT_DEGRADE_PFX : "") + (_effEntMode == ENTROPY_MODE_KGRAM ? "K-gram" : _effEntMode == ENTROPY_MODE_BINARY ? "Binary" : "Legacy"), text_color = _entDegraded ? color.yellow : color.white, text_size = size.tiny)
    
    int _effEntWindow = perf_getEntropyWindow(INPUT_ENTROPY_WINDOW)
    bool _entWinDegraded = _effEntWindow != INPUT_ENTROPY_WINDOW
    table.cell(perfDashboard, 0, 3, UI_FLD_ENTROPY_WINDOW, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 3, (_entWinDegraded ? UI_TEXT_DEGRADE_PFX : "") + str.tostring(_effEntWindow), text_color = _entWinDegraded ? color.yellow : color.white, text_size = size.tiny)
    
    // Hurst settings
    string _effHurstMode = perf_getHurstMode(INPUT_HURST_MODE)
    bool _hurstDegraded = _effHurstMode != INPUT_HURST_MODE
    table.cell(perfDashboard, 0, 4, UI_FLD_HURST_MODE, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 4, (_hurstDegraded ? UI_TEXT_DEGRADE_PFX : "") + (_effHurstMode == STATIC_HURST_MODE_DYADIC_FAST ? "Dyadic Fast" : _effHurstMode == STATIC_HURST_MODE_DYADIC_STABLE ? "Dyadic Stable" : "Legacy"), text_color = _hurstDegraded ? color.yellow : color.white, text_size = size.tiny)
    
    int _effHurstWindow = perf_getHurstWindow(INPUT_HURST_WINDOW)
    bool _hurstWinDegraded = _effHurstWindow != INPUT_HURST_WINDOW
    table.cell(perfDashboard, 0, 5, UI_FLD_HURST_WINDOW, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 5, (_hurstWinDegraded ? UI_TEXT_DEGRADE_PFX : "") + str.tostring(_effHurstWindow), text_color = _hurstWinDegraded ? color.yellow : color.white, text_size = size.tiny)
    
    // Feature Toggles Section
    table.cell(perfDashboard, 0, 6, UI_TBL_SECTION_TOGGLES, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 6, "", text_color = color.gray, text_size = size.tiny)
    
    table.cell(perfDashboard, 0, 7, UI_FLD_ENTROPY_FILTER, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 7, INPUT_ENTROPY_ENABLED ? UI_TEXT_ON : UI_TEXT_OFF, text_color = INPUT_ENTROPY_ENABLED ? color.green : color.gray, text_size = size.tiny)
    
    table.cell(perfDashboard, 0, 8, UI_FLD_HURST_FILTER, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 8, INPUT_HURST_ENABLED ? UI_TEXT_ON : UI_TEXT_OFF, text_color = INPUT_HURST_ENABLED ? color.green : color.gray, text_size = size.tiny)
    
    table.cell(perfDashboard, 0, 9, UI_FLD_ZSCORE_FILTER, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 9, INPUT_ZSCORE_ENABLED ? UI_TEXT_ON : UI_TEXT_OFF, text_color = INPUT_ZSCORE_ENABLED ? color.green : color.gray, text_size = size.tiny)
    
    table.cell(perfDashboard, 0, 10, UI_FLD_MONTE_CARLO, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 10, INPUT_MC_ENABLED ? UI_TEXT_ON : UI_TEXT_OFF, text_color = INPUT_MC_ENABLED ? color.green : color.gray, text_size = size.tiny)
    
    table.cell(perfDashboard, 0, 11, UI_FLD_LEARNING_ENGINE, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 11, INPUT_LEARNING_ENABLED ? UI_TEXT_ON : UI_TEXT_OFF, text_color = INPUT_LEARNING_ENABLED ? color.green : color.gray, text_size = size.tiny)
    
    // Runtime Info
    table.cell(perfDashboard, 0, 12, UI_TBL_SECTION_RUNTIME, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 12, "", text_color = color.gray, text_size = size.tiny)
    
    table.cell(perfDashboard, 0, 13, UI_FLD_VISUAL_MAX_KEEP, text_color = color.gray, text_size = size.tiny)
    table.cell(perfDashboard, 1, 13, str.tostring(perf_getVisualMaxKeep()), text_color = color.white, text_size = size.tiny)