//@version=6

indicator(title = 'Fibonacci Pivots [PQ_MOD]', shorttitle = 'FIBS [v0.1.17]', overlay = true, format = format.price, max_lines_count = 500, max_labels_count = 500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Fibonacci Retracement / Extentions and Pivot Points 
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Theme 
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

t_color_transarpency_main = 25
t_color_transarpency_suplementary = 70

t_color_1 = color.new(chart.fg_color, 15)

t_tzColor = color.new(chart.fg_color, 80)
t_zzColor = color.new(chart.fg_color, 75)
t_textcolor = color.new(chart.fg_color, 0)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Logs
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const int levelsCount = 22

var array<float> l_pivotLevelsLog_retracements = array.new<float>(levelsCount)
var array<float> l_pivotLevelsLog_crossed_retracements = array.new<float>(levelsCount)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Constants
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const string i_alert_id_update = 'FBU'
const string i_alert_id_crossoverExhaustion = 'EXH'
const string i_alert_id_crossoverVolatility = 'HVO'
const string i_alert_id_crossingLevelRetracements = 'RCL'

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

const string tooltip_threshold   = 'Deviation is a multiplier that affects how much the price should deviate from the previous pivot in order for the bar to become a new pivot' + 
                      '\n\nDepth affects the minimum number of bars that will be taken into account when building'

const string tooltip_pivot_point = 'A pivot point is a technical analysis indicator used to determine the overall trend of the market over different time frames'

const string tooltip_zigzag      = 'The Zig Zag indicator is used to identify price trends then connected by straight lines that help the trader visual the price action' + 
                      'This indicator works to eliminate confusion over small price changes or fluctuations and aims to project trend changes overtime'

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

const string group_pick   = 'Pick a Fibonacci Tool'
const string group_pivot  = 'Fibonacci Pivot Points Settings'
const string group_fib_threshold_sec = 'Threshold (sec)'
const string group_fib_threshold_min = 'Threshold (minutes)'
const string group_fib_threshold_h = 'Threshold (hours)'
const string group_fib_threshold_d = 'Threshold (days)'
const string group_fib_threshold_w = 'Threshold (weeks)'
const string group_fib_threshold_m = 'Threshold (months)'

const string group_fib_depth_sec = 'Depth (seconds)'
const string group_fib_depth_min = 'Depth (minutes)'
const string group_fib_depth_h = 'Depth (hours)'
const string group_fib_depth_d = 'Depth (days)'
const string group_fib_depth_w= 'Depth (weeks)'
const string group_fib_depth_m = 'Depth (months)'

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

const string group_fib_tool = 'Fibonacci Extention / Retracement / TimeZone Settings'
const string group_fib_levels = 'Fibonacci Levels'

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

const string group_zigzag = 'ZigZag Settings'
const string group_vol_vol = 'Volume / Volatility AddOns'
const string tooltip_volume_spike_sign_of_exhaustion = 'Moments where\n' + 'huge volume detected : current volume is grater than the product of the theshold value and volume moving average'
const string tooltip_high_volatility = 'Moments where\n' + 'price range of the current bar is grater than the product of the theshold value and average true range value of defined period'
const string tooltip_volume_weighted_colored_bars = 'Volume Weighted Colored Bars\nColors bars based on the bar\'s volume relative to volume moving average'


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Inputs
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

i_fibTime    = input.bool (true, 'Fib Time Zones', inline='TZ', group=group_pick)
// i_tzColor    = input.color(t_tzColor, '', inline='TZ', group=group_pick)
i_tzColor = t_tzColor

i_customThreshold = input.bool (true, 'Custom thresholds', inline='C')
i_customDepth = input.bool(true, 'Custom depths', inline='C')

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

i_htf_mode   = input.string('Auto', 'Pivot Points TimeFrame', options=['Auto', 'User Defined'], inline='HTF', group=group_pivot, tooltip=tooltip_pivot_point)
i_htf_user_  = input.string('15 Min', 'â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒor User Defined', 
                             options=['15 Min', '1 Hour', '4 Hour', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Yearly'], inline='HTF1', group=group_pivot)

i_htf_user   = i_htf_user_ == '15 Min'    ? '15'  : 
               i_htf_user_ == '1 Hour'    ? '60'  : 
               i_htf_user_ == '4 Hour'    ? '240' : 
               i_htf_user_ == 'Daily'     ? 'D'   : 
               i_htf_user_ == 'Weekly'    ? 'W'   : 
               i_htf_user_ == 'Monthly'   ? 'M'   : 
               i_htf_user_ == 'Quarterly' ? '3M'  : '12M'

i_levelsPvt  = input.string('Prices', 'Level Labels', options=['Levels', 'Prices', 'Levels + Prices', 'None'], inline='pvt', group=group_pivot)
i_levelsPvtP = input.string('Pivot End', '', options=['Last Bar', 'Pivot End'], inline='pvt', group=group_pivot)
i_levelsPvtS = input.string('Small', '', options=['Small', 'Normal'], inline='pvt', group=group_pivot)

i_extend     = input.bool(false, 'Extend Pivot Point Lines', inline='fLines', group=group_pivot)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

dev_treshold(float dev_treshold) => ta.atr(2) / close * 100 * dev_treshold

float i_dev_threshold_default     = dev_treshold(input.float(3, 'Deviation (default)', minval=0, inline='Pivots', group=group_fib_threshold_sec, tooltip=tooltip_threshold))

float i_dev_threshold_1S  = dev_treshold(input.float(3, 'Deviation (1S)', minval=0, inline='Pivots', group=group_fib_threshold_sec, tooltip=tooltip_threshold))
float i_dev_threshold_5S  = dev_treshold(input.float(3, 'Deviation (5S)', minval=0, inline='Pivots', group=group_fib_threshold_sec, tooltip=tooltip_threshold))
float i_dev_threshold_10S = dev_treshold(input.float(3, 'Deviation (10S)', minval=0, inline='Pivots', group=group_fib_threshold_sec, tooltip=tooltip_threshold))
float i_dev_threshold_15S = dev_treshold(input.float(3, 'Deviation (15S)', minval=0, inline='Pivots', group=group_fib_threshold_sec, tooltip=tooltip_threshold))
float i_dev_threshold_30S = dev_treshold(input.float(3, 'Deviation (30S)', minval=0, inline='Pivots', group=group_fib_threshold_sec, tooltip=tooltip_threshold))
float i_dev_threshold_45S = dev_treshold(input.float(3, 'Deviation (45S)', minval=0, inline='Pivots', group=group_fib_threshold_sec, tooltip=tooltip_threshold))

float i_dev_threshold_1   = dev_treshold(input.float(3, 'Deviation (1M)', minval=0, inline='Pivots', group=group_fib_threshold_min, tooltip=tooltip_threshold))
float i_dev_threshold_2   = dev_treshold(input.float(3, 'Deviation (2M)', minval=0, inline='Pivots', group=group_fib_threshold_min, tooltip=tooltip_threshold))
float i_dev_threshold_3   = dev_treshold(input.float(3, 'Deviation (3M)', minval=0, inline='Pivots', group=group_fib_threshold_min, tooltip=tooltip_threshold))
float i_dev_threshold_5   = dev_treshold(input.float(3, 'Deviation (5M)', minval=0, inline='Pivots', group=group_fib_threshold_min, tooltip=tooltip_threshold))
float i_dev_threshold_10  = dev_treshold(input.float(3, 'Deviation (10M)', minval=0, inline='Pivots', group=group_fib_threshold_min, tooltip=tooltip_threshold))
float i_dev_threshold_15  = dev_treshold(input.float(3, 'Deviation (15M)', minval=0, inline='Pivots', group=group_fib_threshold_min, tooltip=tooltip_threshold))
float i_dev_threshold_30  = dev_treshold(input.float(3, 'Deviation (30M)', minval=0, inline='Pivots', group=group_fib_threshold_min, tooltip=tooltip_threshold))
float i_dev_threshold_45  = dev_treshold(input.float(3, 'Deviation (45M)', minval=0, inline='Pivots', group=group_fib_threshold_min, tooltip=tooltip_threshold))

float i_dev_threshold_60  = dev_treshold(input.float(2, 'Deviation (1H)', minval=0, inline='Pivots', group=group_fib_threshold_h, tooltip=tooltip_threshold))
float i_dev_threshold_120 = dev_treshold(input.float(2, 'Deviation (2H)', minval=0, inline='Pivots', group=group_fib_threshold_h, tooltip=tooltip_threshold))
float i_dev_threshold_180 = dev_treshold(input.float(2, 'Deviation (3H)', minval=0, inline='Pivots', group=group_fib_threshold_h, tooltip=tooltip_threshold))
float i_dev_threshold_240 = dev_treshold(input.float(2, 'Deviation (4H)', minval=0, inline='Pivots', group=group_fib_threshold_h, tooltip=tooltip_threshold))

float i_dev_threshold_1D  = dev_treshold(input.float(2, 'Deviation (1D)', minval=0, inline='Pivots', group=group_fib_threshold_d, tooltip=tooltip_threshold))
float i_dev_threshold_7D  = dev_treshold(input.float(2, 'Deviation (7D)', minval=0, inline='Pivots', group=group_fib_threshold_d, tooltip=tooltip_threshold))

float i_dev_threshold_4W  = dev_treshold(input.float(2, 'Deviation (4W)', minval=0, inline='Pivots', group=group_fib_threshold_w, tooltip=tooltip_threshold))

float i_dev_threshold_3M  = dev_treshold(input.float(2, 'Deviation (3M)', minval=0, inline='Pivots', group=group_fib_threshold_m, tooltip=tooltip_threshold))
float i_dev_threshold_6M  = dev_treshold(input.float(2, 'Deviation (6M)', minval=0, inline='Pivots', group=group_fib_threshold_m, tooltip=tooltip_threshold))
float i_dev_threshold_12M = dev_treshold(input.float(2, 'Deviation (12M)', minval=0, inline='Pivots', group=group_fib_threshold_m, tooltip=tooltip_threshold))

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

int i_depth_default         = input.int(3, 'Depth (default)', minval=1, inline='Pivots', group=group_fib_depth_sec)

int i_depth_1S      = input.int(4, 'Depth (1S)', minval=1, inline='Pivots', group=group_fib_depth_sec)
int i_depth_5S      = input.int(6, 'Depth (5S)', minval=1, inline='Pivots', group=group_fib_depth_sec)
int i_depth_10S     = input.int(6, 'Depth (10S)', minval=1, inline='Pivots', group=group_fib_depth_sec)
int i_depth_15S     = input.int(6, 'Depth (15S)', minval=1, inline='Pivots', group=group_fib_depth_sec)
int i_depth_30S     = input.int(6, 'Depth (30S)', minval=1, inline='Pivots', group=group_fib_depth_sec)
int i_depth_45S     = input.int(6, 'Depth (45S)', minval=1, inline='Pivots', group=group_fib_depth_sec)

int i_depth_1       = input.int(3, 'Depth (1M)', minval=1, inline='Pivots', group=group_fib_depth_min)
int i_depth_2       = input.int(3, 'Depth (2M)', minval=1, inline='Pivots', group=group_fib_depth_min)
int i_depth_3       = input.int(3, 'Depth (3M)', minval=1, inline='Pivots', group=group_fib_depth_min)
int i_depth_5       = input.int(3, 'Depth (5M)', minval=1, inline='Pivots', group=group_fib_depth_min)
int i_depth_10      = input.int(3, 'Depth (10M)', minval=1, inline='Pivots', group=group_fib_depth_min)
int i_depth_15      = input.int(3, 'Depth (15M)', minval=1, inline='Pivots', group=group_fib_depth_min)
int i_depth_30      = input.int(3, 'Depth (30M)', minval=1, inline='Pivots', group=group_fib_depth_min)
int i_depth_45      = input.int(3, 'Depth (45M)', minval=1, inline='Pivots', group=group_fib_depth_min)

int i_depth_60      = input.int(2, 'Depth (1H)', minval=1, inline='Pivots', group=group_fib_depth_h)
int i_depth_120     = input.int(2, 'Depth (2H)', minval=1, inline='Pivots', group=group_fib_depth_h)
int i_depth_180     = input.int(2, 'Depth (3H)', minval=1, inline='Pivots', group=group_fib_depth_h)
int i_depth_240     = input.int(2, 'Depth (4H)', minval=1, inline='Pivots', group=group_fib_depth_h)

int i_depth_1D      = input.int(3, 'Depth (1D)', minval=1, inline='Pivots', group=group_fib_depth_d)
int i_depth_7D      = input.int(3, 'Depth (7D)', minval=1, inline='Pivots', group=group_fib_depth_d)

int i_depth_4W      = input.int(3, 'Depth (4W)', minval=1, inline='Pivots', group=group_fib_depth_w)

int i_depth_3M      = input.int(3, 'Depth (3M)', minval=1, inline='Pivots', group=group_fib_depth_m)
int i_depth_6M      = input.int(3, 'Depth (6M)', minval=1, inline='Pivots', group=group_fib_depth_m)
int i_depth_12M     = input.int(3, 'Depth (12M)', minval=1, inline='Pivots', group=group_fib_depth_m)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

i_levels     = input.string('Prices', 'Level Labels', options=['Levels', 'Prices', 'Levels + Prices', 'None'], inline='fLines', group=group_fib_tool)
i_levelsP    = input.string('Pivot Start', '', options=['Last Bar', 'Pivot Start'], inline='fLines', group=group_fib_tool)
i_levelsS    = input.string('Small', '', options=['Small', 'Normal'], inline='fLines', group=group_fib_tool)

i_reverse    = input.bool(false, 'Reverse Extention / Retracement Levels', group=group_fib_tool)
i_extendER   = input.bool(false, 'Extend Extention / Retracement Lines', inline='fLine', group=group_fib_tool)
i_histPivot  = input.int (0, 'Historical Extention / Retracement Levels', minval=0, group=group_fib_tool)

i_histPivot2 = input.int(0, 'Historical Time Zones', minval=0, group=group_fib_tool)
i_fib_tzl    = input.bool(false, 'Time Zone Lables', inline='tz poz', group=group_fib_tool)
i_fib_tzlp   = input.string('Left', '', options=['Right', 'Left'], inline='tz poz', group=group_fib_tool)
fib_tzlp     = i_fib_tzlp == 'Left' ? label.style_label_left : label.style_label_right
i_fib_tzlp2  = input.string('Bottom', '', options=['Bottom', 'Top'], inline='tz poz', group=group_fib_tool)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

show_0  = input.bool(true, '', inline='Level0', group=group_fib_levels)
value_0 = input.float(0., '', inline='Level0', group=group_fib_levels)
color_0 = input.color(color.new(#a2a2a2, t_color_transarpency_main), '', inline='Level0', group=group_fib_levels)

show_0_236  = input.bool(true, '', inline='Level0', group=group_fib_levels)
value_0_236 = input.float(0.236, '', inline='Level0', group=group_fib_levels)
color_0_236 = input.color(color.new(#f44336, t_color_transarpency_main), '', inline='Level0', group=group_fib_levels)

show_0_382  = input.bool(true, '', inline='Level1', group=group_fib_levels)
value_0_382 = input.float(0.382, '', inline='Level1', group=group_fib_levels)
color_0_382 = input.color(color.new(#81c784, t_color_transarpency_main), '', inline='Level1', group=group_fib_levels)

show_0_5  = input.bool(true, '', inline='Level1', group=group_fib_levels)
value_0_5 = input.float(0.5, '', inline='Level1', group=group_fib_levels)
color_0_5 = input.color(color.new(#4caf50, t_color_transarpency_main), '', inline='Level1', group=group_fib_levels)

show_0_618  = input.bool(true, '', inline='Level2', group=group_fib_levels)
value_0_618 = input.float(0.618, '', inline='Level2', group=group_fib_levels)
color_0_618 = input.color(color.new(#009688, t_color_transarpency_main), '', inline='Level2', group=group_fib_levels)

show_0_65  = input.bool(false, '', inline='Level2', group=group_fib_levels)
value_0_65 = input.float(0.65, '', inline='Level2', group=group_fib_levels)
color_0_65 = input.color(color.new(#009688, t_color_transarpency_suplementary), '', inline='Level2', group=group_fib_levels)

show_0_786  = input.bool(true, '', inline='Level3', group=group_fib_levels)
value_0_786 = input.float(0.786, '', inline='Level3', group=group_fib_levels)
color_0_786 = input.color(color.new(#64b5f6, t_color_transarpency_main), '', inline='Level3', group=group_fib_levels)

show_1  = input.bool(true, '', inline='Level3', group=group_fib_levels)
value_1 = input.float(1., '', inline='Level3', group=group_fib_levels)
// color_1 = input.color(t_color_1, '', inline='Level3', group=group_fib_levels)
color_1 = t_color_1

show_1_272  = input.bool(true, '', inline='Level4', group=group_fib_levels)
value_1_272 = input.float(1.272, '', inline='Level4', group=group_fib_levels)
color_1_272 = input.color(color.new(#81c784, t_color_transarpency_main), '', inline='Level4', group=group_fib_levels)

show_1_414  = input.bool(false, '', inline='Level4', group=group_fib_levels)
value_1_414 = input.float(1.414, '', inline='Level4', group=group_fib_levels)
color_1_414 = input.color(color.new(#f44336, t_color_transarpency_suplementary), '', inline='Level4', group=group_fib_levels)

show_1_618  = input.bool(true, '', inline='Level5', group=group_fib_levels)
value_1_618 = input.float(1.618, '', inline='Level5', group=group_fib_levels)
color_1_618 = input.color(color.new(#2196f3, t_color_transarpency_main), '', inline='Level5', group=group_fib_levels)

show_1_65  = input.bool(false, '', inline='Level5', group=group_fib_levels)
value_1_65 = input.float(1.65, '', inline='Level5', group=group_fib_levels)
color_1_65 = input.color(color.new(#2196f3, t_color_transarpency_suplementary), '', inline='Level5', group=group_fib_levels)

show_2_618  = input.bool(false, '', inline='Level6', group=group_fib_levels)
value_2_618 = input.float(2.618, '', inline='Level6', group=group_fib_levels)
color_2_618 = input.color(color.new(#f44336, t_color_transarpency_suplementary), '', inline='Level6', group=group_fib_levels)

show_2_65  = input.bool(true, '', inline='Level6', group=group_fib_levels)
value_2_65 = input.float(2.65, '', inline='Level6', group=group_fib_levels)
color_2_65 = input.color(color.new(#f44336, t_color_transarpency_suplementary), '', inline='Level6', group=group_fib_levels)

show_3_618  = input.bool(false, '', inline='Level7', group=group_fib_levels)
value_3_618 = input.float(3.618, '', inline='Level7', group=group_fib_levels)
color_3_618 = input.color(color.new(#9c27b0, t_color_transarpency_suplementary), '', inline='Level7', group=group_fib_levels)

show_3_65  = input.bool(true, '', inline='Level7', group=group_fib_levels)
value_3_65 = input.float(3.65, '', inline='Level7', group=group_fib_levels)
color_3_65 = input.color(color.new(#9c27b0, t_color_transarpency_suplementary), '', inline='Level7', group=group_fib_levels)

show_4_236  = input.bool(true, '', inline='Level8', group=group_fib_levels)
value_4_236 = input.float(4.236, '', inline='Level8', group=group_fib_levels)
color_4_236 = input.color(color.new(#e91e63, t_color_transarpency_suplementary), '', inline='Level8', group=group_fib_levels)

show_4_618  = input.bool(true, '', inline='Level8', group=group_fib_levels)
value_4_618 = input.float(4.618, '', inline='Level8', group=group_fib_levels)
color_4_618 = input.color(color.new(#81c784, t_color_transarpency_suplementary) , '', inline='Level8', group=group_fib_levels)

show_neg_0_236  = input.bool(true, '', inline='Level9', group=group_fib_levels)
value_neg_0_236 = input.float(-0.236, '', inline='Level9', group=group_fib_levels)
color_neg_0_236 = input.color(color.new(#f44336, t_color_transarpency_suplementary), '', inline='Level9', group=group_fib_levels)

show_neg_0_382  = input.bool(true, '', inline='Level9', group=group_fib_levels)
value_neg_0_382 = input.float(-0.382, '', inline='Level9', group=group_fib_levels)
color_neg_0_382 = input.color(color.new(#81c784, t_color_transarpency_suplementary), '', inline='Level9', group=group_fib_levels)

show_neg_0_618  = input.bool(false, '', inline='Level10', group=group_fib_levels)
value_neg_0_618 = input.float(-0.618, '', inline='Level10', group=group_fib_levels)
color_neg_0_618 = input.color(color.new(#009688, t_color_transarpency_suplementary), '', inline='Level10', group=group_fib_levels)

show_neg_0_65  = input.bool(true, '', inline='Level10', group=group_fib_levels)
value_neg_0_65 = input.float(-0.65, '', inline='Level10', group=group_fib_levels)
color_neg_0_65 = input.color(color.new(#009688, t_color_transarpency_suplementary), '', inline='Level10', group=group_fib_levels)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

i_zigZag     = input.bool(true, 'Zig Zagâ€‡â€‡', inline='ZZ', group=group_zigzag, tooltip=tooltip_zigzag)
// i_zzColor    = input.color(t_zzColor, '', inline='ZZ', group=group_zigzag)
i_zzColor = t_zzColor
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

alertEnabled = input.bool(false, 'Enable Alerts', group='Alerts')
alertMode = input.string('calculateAlertUpdates', 'Alert data collection mode', options=['calculateAlertData', 'calculateAlertUpdates'], group = 'Alerts')
s = input.string('|', 'Alert data separator', group = 'Alerts')

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// High Volatility
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

i_hATRLb = input.bool(false, 'âš¡', inline='ATR', group=group_vol_vol, tooltip=tooltip_high_volatility)
i_weightedATR = ta.atr(input.int(13, 'ATR : Length', inline='ATR', group=group_vol_vol)) * input.float(2.718, 'Mult', minval=.1, step=.1, inline='ATR', group=group_vol_vol)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Volume Moving Average : Base
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

i_vSMA = ta.sma(nz(volume), input.int(89, 'Volume Moving Average Length', group=group_vol_vol))

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Volume Spike - Sign of Exhaustion
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

i_vSpikeLb = input.bool(false, 'ğŸš¦', inline='SRS1', group=group_vol_vol, tooltip=tooltip_volume_spike_sign_of_exhaustion)
i_vSpikeThresh = input.float(4.669, 'Volume Spike Thesholdâ€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡', minval=.1, step=.1, inline='SRS1', group=group_vol_vol)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Variables
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int decimalsCount = math.round(math.abs(math.log(1 / syminfo.mintick) / math.log(10)))

var line lineLast = na
var int iLast = 0
var int iPrev = 0
var float pLast = 0
var isHighLast = false  // otherwise the last pivot is a low pivot

var iPrevPivot = 0
var pPrevPivot = 0.
var iLastPivot = 0
var pLastPivot = 0.

var int i_depth = i_depth_default

if i_customDepth
    i_depth := switch timeframe.period
        "1S" => i_depth_1S
        "5S" => i_depth_5S
        "10S" => i_depth_10S
        "15S" => i_depth_15S
        "30S" => i_depth_30S
        "45S" => i_depth_45S
        "1" => i_depth_1
        "2" => i_depth_2
        "3" => i_depth_3
        "5" => i_depth_5
        "10" => i_depth_10
        "15" => i_depth_15
        "30" => i_depth_30
        "45" => i_depth_45
        "60" => i_depth_60
        "120" => i_depth_120
        "180" => i_depth_180
        "240" => i_depth_240
        "1D" => i_depth_1D
        "7D" => i_depth_7D
        "4W" => i_depth_4W
        "3M" => i_depth_3M
        "6M" => i_depth_6M
        "12M" => i_depth_12M
        => 3

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

// This script calculates various pivot points and their corresponding values based on historical pivot data.
// The calculations are conditional, depending on whether the historical pivot values (i_histPivot and i_histPivot2) are greater than 0.
// If the historical pivot values are greater than 0, the script uses the `ta.valuewhen` function to get the pivot values at specific conditions.
// If the historical pivot values are not greater than 0, the script uses the `line.get_x` and `line.get_y` functions to get the pivot values from the last line drawn.

// Variables:
// iStartBase: Initial pivot value for the first set of historical data.
// pStartBase: Corresponding price value for the initial pivot of the first set of historical data.
// iEndBase: Ending pivot value for the first set of historical data.
// pEndBase: Corresponding price value for the ending pivot of the first set of historical data.
// iMidPivot: Middle pivot value for the first set of historical data.
// pMidPivot: Corresponding price value for the middle pivot of the first set of historical data.
// iEndBase2: Ending pivot value for the second set of historical data.
// pEndBase2: Corresponding price value for the ending pivot of the second set of historical data.
// iMidPivot2: Middle pivot value for the second set of historical data.
// pMidPivot2: Corresponding price value for the middle pivot of the second set of historical data.
//   - If there is no change in the higher time frame, update the high and low prices with the maximum and minimum values respectively.
//   - Return an array containing the previous and current OHLC values.
iStartBase = i_histPivot  > 0 ? ta.valuewhen(ta.change(iPrevPivot !=0), iPrevPivot, i_histPivot)      : ta.valuewhen(ta.change(iPrevPivot !=0), iPrevPivot, 0)
pStartBase = i_histPivot  > 0 ? ta.valuewhen(ta.change(pPrevPivot !=0), pPrevPivot, i_histPivot)      : ta.valuewhen(ta.change(pPrevPivot !=0), pPrevPivot, 0)
iEndBase   = i_histPivot  > 0 ? ta.valuewhen(ta.change(iLastPivot !=0), iLastPivot, i_histPivot  - 1) : line.get_x2(lineLast)
pEndBase   = i_histPivot  > 0 ? ta.valuewhen(ta.change(pLastPivot !=0), pLastPivot, i_histPivot  - 1) : line.get_y2(lineLast)
iMidPivot  = i_histPivot  > 0 ? ta.valuewhen(ta.change(iPrevPivot !=0), iPrevPivot, i_histPivot  - 1) : line.get_x1(lineLast)
pMidPivot  = i_histPivot  > 0 ? ta.valuewhen(ta.change(pPrevPivot !=0), pPrevPivot, i_histPivot  - 1) : line.get_y1(lineLast)
iEndBase2  = i_histPivot2 > 0 ? ta.valuewhen(ta.change(iLastPivot !=0), iLastPivot, i_histPivot2 - 1) : line.get_x2(lineLast)
pEndBase2  = i_histPivot2 > 0 ? ta.valuewhen(ta.change(pLastPivot !=0), pLastPivot, i_histPivot2 - 1) : line.get_y2(lineLast)
iMidPivot2 = i_histPivot2 > 0 ? ta.valuewhen(ta.change(iPrevPivot !=0), iPrevPivot, i_histPivot2 - 1) : line.get_x1(lineLast)
pMidPivot2 = i_histPivot2 > 0 ? ta.valuewhen(ta.change(pPrevPivot !=0), pPrevPivot, i_histPivot2 - 1) : line.get_y1(lineLast)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

// This script determines the higher timeframe (htf_auto) based on the current chart's timeframe (timeframe.period).
// The mapping is as follows:
// - For 1, 3, and 5-minute charts, the higher timeframe is 240 minutes (4 hours).
// - For 15, 30, and 45-minute charts, the higher timeframe is 1 day (D).
// - For 60, 120, 180, and 240-minute charts, the higher timeframe is 1 week (W).
// - For daily (D) charts, the higher timeframe is 1 month (M).
// - For weekly (W) charts, the higher timeframe is 3 months (3M).
// - For all other timeframes, the higher timeframe is 12 months (12M).
htf_auto = timeframe.period == '1'   ? '240' : 
           timeframe.period == '3'   ? '240' : 
           timeframe.period == '5'   ? '240' : 
           timeframe.period == '15'  ? 'D'   : 
           timeframe.period == '30'  ? 'D'   : 
           timeframe.period == '45'  ? 'D'   : 
           timeframe.period == '60'  ? 'W'   : 
           timeframe.period == '120' ? 'W'   : 
           timeframe.period == '180' ? 'W'   : 
           timeframe.period == '240' ? 'W'   : 
           timeframe.period == 'D'   ? 'M'   : 
           timeframe.period == 'W'   ? '3M'  : '12M'

htf = i_htf_mode == 'Auto' ? htf_auto : i_htf_user

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

// This script calculates specific time values based on higher timeframe (htf) changes.
// `time_x10` captures the time of the previous change in the higher timeframe.
// `time_x11` captures the time of the current change in the higher timeframe.
// `time_x21` calculates a projected time value based on the current and previous higher timeframe changes.
time_x10 = ta.valuewhen(ta.change(time(htf)) != 0, time, 1)
time_x11 = ta.valuewhen(ta.change(time(htf)) != 0, time, 0)
time_x21 = 2 * time_x11 - time_x10

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

var ln = array.new_line()
var lb = array.new_label()

nzVolume = nz(volume)
bullCandle = close > open
bearCandle = close < open
range_1 = math.abs(high - low)
exhaustVol = nzVolume > i_vSpikeThresh * i_vSMA
bool crossover_exhaustion = ta.crossover(nzVolume, i_vSMA * i_vSpikeThresh)
highVolatility = range_1 > i_weightedATR
bool crossover_volatility = ta.crossover(range_1, i_weightedATR)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Functions
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: pivots
// Description: This function identifies pivot points in a given source series.
// Parameters:
//   src (series): The source series to analyze for pivot points.
//   length (int): The length of the window to consider for identifying pivots.
//   isHigh (bool): A boolean flag indicating whether to identify high pivots (true) or low pivots (false).
// Returns:
//   array: An array containing the bar index and the pivot value if a pivot is found, otherwise an array with `na` values.
pivots(src, length, isHigh) =>
    l2 = length * 2
    c = nz(src[length])
    ok = true

    for i = 0 to l2 by 1
        if isHigh and src[i] > c
            ok := false
            ok

        if not isHigh and src[i] < c
            ok := false
            ok
    if ok
        [bar_index[length], c]
    else
        [int(na), float(na)]

[iH, pH] = pivots(high, i_depth / 2, true)
[iL, pL] = pivots(low, i_depth / 2, false)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: calc_dev
// Description: This function calculates the percentage deviation between a base price and a given price.
// Parameters:
//   base_price (float) - The base price to compare against.
//   price (float) - The current price to compare with the base price.
// Returns:
//   float - The percentage deviation between the base price and the current price.
calc_dev(base_price, price) =>
    100 * (price - base_price) / price
    
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: pivotFound
// Description: This function identifies pivot points in price data and draws lines to represent significant price movements.
// Parameters:
//   dev (float) - The deviation value indicating the price movement.
//   isHigh (bool) - A boolean indicating if the current price is a high point.
//   index (int) - The current index in the price data series.
//   price (float) - The current price value.
// Returns:
//   tuple - A tuple containing the line ID and a boolean indicating if the last point was a high point.
// Logic:
//   - If the direction of the pivot point is the same as the last one and the last line is not null:
//     - If the current price continues in the same direction, update the last line's endpoint.
//     - Otherwise, return null values.
//   - If the direction is reversed or it's the very first line:
//     - If the price movement is significant (greater than a threshold):
//       - Determine the line's color, width, and style based on the zigzag settings.
//       - Create a new line from the last point to the current point.
//       - Return the new line ID and the current direction.
//     - Otherwise, return null values.
pivotFound(float dev, bool isHigh, int index, float price) =>
    var float dev_threshold = i_dev_threshold_default

    if i_customThreshold
        dev_threshold := switch timeframe.period
            "1S" => i_dev_threshold_1S
            "5S" => i_dev_threshold_5S
            "10S" => i_dev_threshold_10S
            "15S" => i_dev_threshold_15S
            "30S" => i_dev_threshold_30S
            "45S" => i_dev_threshold_45S
            "1" => i_dev_threshold_1
            "2" => i_dev_threshold_2
            "3" => i_dev_threshold_3
            "5" => i_dev_threshold_5
            "10" => i_dev_threshold_10
            "15" => i_dev_threshold_15
            "30" => i_dev_threshold_30
            "45" => i_dev_threshold_45
            "60" => i_dev_threshold_60
            "120" => i_dev_threshold_120
            "180" => i_dev_threshold_180
            "240" => i_dev_threshold_240
            "1D" => i_dev_threshold_1D
            "7D" => i_dev_threshold_7D
            "4W" => i_dev_threshold_4W
            "3M" => i_dev_threshold_3M
            "6M" => i_dev_threshold_6M
            "12M" => i_dev_threshold_12M
            => 3

    if isHighLast == isHigh and not na(lineLast)
        // same direction
        if isHighLast ? price > pLast : price < pLast
            line.set_xy2(lineLast, index, price)
            [lineLast, isHighLast]
        else
            [line(na), bool(na)]
    else
        // reverse the direction (or create the very first line)
        if math.abs(dev) > dev_threshold
            // price move is significant

            id = line.new(iLast, pLast, index, price, color=i_zzColor, width=2, style=line.style_solid)
            [id, isHigh]
        else
            [line(na), bool(na)]
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

// This script checks if the variable `iH` is not `na` (not available).
// If `iH` is available, it calculates the deviation `dev` using the function `calc_dev` with parameters `pLast` and `pH`.
// It then calls the function `pivotFound` with parameters `dev`, `true`, `iH`, and `pH`, and assigns the returned values to `id` and `isHigh`.
// If `id` is not `na`, it further checks if `id` is not equal to `lineLast`.
// If `id` is different from `lineLast`, it retrieves the previous pivot points' coordinates using `line.get_x1`, `line.get_y1`, `line.get_x2`, and `line.get_y2` functions.
// If `i_zigZag` is not available, it deletes the line represented by `lineLast`.
// Finally, it updates the variables `lineLast`, `isHighLast`, `iPrev`, `iLast`, and `pLast` with the new pivot information.
if not na(iH)
    dev = calc_dev(pLast, pH)
    [id, isHigh] = pivotFound(dev, true, iH, pH)

    if not na(id)
        if id != lineLast
            iPrevPivot := line.get_x1(lineLast)
            pPrevPivot := line.get_y1(lineLast)
            iLastPivot := line.get_x2(lineLast)
            pLastPivot := line.get_y2(lineLast)

            if not i_zigZag
                line.delete(lineLast)

        lineLast := id
        isHighLast := isHigh
        iPrev := iLast
        iLast := iH
        pLast := pH
        pLast
else
    if not na(iL)
        dev = calc_dev(pLast, pL)
        [id, isHigh] = pivotFound(dev, false, iL, pL)

        if not na(id)
            if id != lineLast
                iPrevPivot := line.get_x1(lineLast)
                pPrevPivot := line.get_y1(lineLast)
                iLastPivot := line.get_x2(lineLast)
                pLastPivot := line.get_y2(lineLast)

                if not i_zigZag
                    line.delete(lineLast)

            lineLast := id
            isHighLast := isHigh
            iPrev := iLast
            iLast := iL
            pLast := pL
            pLast

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: f_htf_ohlc
// Description: This function calculates the OHLC (Open, High, Low, Close) values for a higher time frame (HTF).
// Parameters:
//   _htf (int) - The higher time frame interval.
// Returns:
//   array - An array containing the previous and current OHLC values for the higher time frame.
// Variables:
//   htf_o (float) - The open price for the higher time frame.
//   htf_h (float) - The high price for the higher time frame.
//   htf_l (float) - The low price for the higher time frame.
//   htf_c (float) - The close price for the higher time frame.
//   htf_ox (float) - The previous open price for the higher time frame.
//   htf_hx (float) - The previous high price for the higher time frame.
//   htf_lx (float) - The previous low price for the higher time frame.
//   htf_cx (float) - The previous close price for the higher time frame.
// Logic:
//   - On a change of the higher time frame, update the previous OHLC values and set the current OHLC values.
//   - If there is no change in the higher time frame, update the high and low prices with the maximum and minimum values respectively.
//   - Return an array containing the previous and current OHLC values.
f_htf_ohlc(_htf) =>
    var htf_o  = 0.
    var htf_h  = 0.
    var htf_l  = 0.
    htf_c      = close
    
    var htf_ox = 0.
    var htf_hx = 0.
    var htf_lx = 0.
    var htf_cx = 0.

    if ta.change(time(_htf) !=0)
        htf_ox := htf_o
        htf_o  := open
        
        htf_hx := htf_h
        htf_h  := high
        
        htf_lx := htf_l
        htf_l  := low
        
        htf_cx := htf_c[1]
        htf_cx
    else
        htf_h := math.max(high, htf_h)
        htf_l := math.min(low , htf_l)
        htf_l

    [htf_ox, htf_hx, htf_lx, htf_cx, htf_o, htf_h, htf_l, htf_c]

[_, htf_h1, htf_l1, htf_c1, _, _, _, _] = f_htf_ohlc(htf)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: f_drawLineX
// Description: This function draws a line on the chart with specified coordinates and properties.
// Parameters:
//   _x1 (float) - The x-coordinate of the first point of the line.
//   _y1 (float) - The y-coordinate of the first point of the line.
//   _x2 (float) - The x-coordinate of the second point of the line.
//   _y2 (float) - The y-coordinate of the second point of the line.
//   _xloc (string) - The location of the x-coordinates (e.g., bar_index, time).
//   _extend (string) - The extension of the line (e.g., extend.none, extend.right).
//   _color (color) - The color of the line.
//   _style (line.style) - The style of the line (e.g., line.style_solid, line.style_dotted).
//   _width (int) - The width of the line.
// Logic:
//   - Create a new line with the specified coordinates and properties.
//   - If both y-coordinates are greater than 0, set the line's coordinates and color.
//   - If either y-coordinate is not greater than 0, set the line's coordinates to the close price and color to transparent.
f_drawLineX(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    var id = line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width)

    if _y1 > 0 and _y2 > 0
        line.set_xy1(id, _x1, _y1)
        line.set_xy2(id, _x2, _y2)
        line.set_color(id, _color)
    else
        line.set_xy1(id, _x1, close)
        line.set_xy2(id, _x2, close)
        line.set_color(id, color.new(chart.fg_color, 0))

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: f_drawLabelX
// Description: This function creates and customizes a label on the chart at specified coordinates.
// Parameters:
//   _x (float) - The x-coordinate for the label.
//   _y (float) - The y-coordinate for the label.
//   _text (string) - The text to display on the label.
//   _xloc (string) - The x-location of the label (e.g., 'bar_index').
//   _yloc (string) - The y-location of the label (e.g., 'price').
//   _color (color) - The background color of the label.
//   _style (label.style) - The style of the label (e.g., label.style_label_down).
//   _textcolor (color) - The color of the text on the label.
//   _size (size) - The size of the text on the label.
//   _textalign (text.align) - The alignment of the text on the label.
//   _tooltip (string) - The tooltip text to display when hovering over the label.
// Variables:
//   id (label) - The identifier for the created label.
// Logic:
//   - Create a new label with the specified parameters.
//   - Set the text of the label, appending additional text if certain conditions are met.
//   - Set the tooltip of the label.
//   - If the y-coordinate is greater than 0, set the label's coordinates and text color.
//   - If the y-coordinate is not greater than 0, set the label's y-coordinate to the close price and the text color to transparent.
f_drawLabelX(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    var id = label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip)
    label.set_text(id, i_extend or i_extendER or i_levelsP == 'Last Bar' ? _text + '\n\n' : _text)
    label.set_tooltip(id, _tooltip)

    if _y > 0
        label.set_xy(id, _x, _y)
        label.set_textcolor(id, _textcolor)
    else
        label.set_xy(id, _x, close)
        label.set_textcolor(id, _textcolor)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: f_crossingLevel
// Description: This function checks if a given level crosses the current value.
// Parameters:
//   _curret (float) - The current value.
//   _level (float) - The level to check for crossing.
// Returns:
//   bool - True if the level crosses the current value, otherwise false.
// Logic:
//   - The function returns true if the level is greater than the current value and less than the previous value, or if the level is less than the current value and greater than the previous value.
f_crossingLevel(_curret, _level) =>
    _level > _curret and _level < _curret[1] or _level < _curret and _level > _curret[1]

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// This script checks if there is a change in the 'time' variable and if the array 'ln' has more than 0 elements.
// If both conditions are met, it iterates through the array 'ln' and deletes each line element.
// 'ta.change(time)' checks for a change in the 'time' variable.
// 'array.size(ln)' returns the number of elements in the array 'ln'.
// 'line.delete(array.shift(ln))' deletes the first element in the array 'ln' and shifts the remaining elements.
if ta.change(time) != 0 and array.size(ln) > 0
    for i = 1 to array.size(ln) by 1
        line.delete(array.shift(ln))

if ta.change(time) != 0 and array.size(lb) > 0
    for i = 1 to array.size(lb) by 1
        label.delete(array.shift(lb))

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: f_drawLineTZ
// Description: This function draws a line on the chart if the starting point of the line is within 500 bars from the current bar index.
// Parameters:
//   _x1 (int) - The x-coordinate of the starting point of the line.
//   _y1 (float) - The y-coordinate of the starting point of the line.
//   _x2 (int) - The x-coordinate of the ending point of the line.
//   _y2 (float) - The y-coordinate of the ending point of the line.
//   _xloc (string) - The location of the x-coordinate (e.g., bar_index or time).
//   _extend (string) - The extension of the line (e.g., extend.none, extend.left, extend.right, extend.both).
//   _c (color) - The color of the line.
//   _s (string) - The style of the line (e.g., line.style_solid, line.style_dotted).
//   _w (int) - The width of the line.
// Returns:
//   void - This function does not return a value.
// Logic:
//   - If the difference between the starting x-coordinate and the current bar index is less than 500, draw the line on the chart.
f_drawLineTZ(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w) =>
    if _x1 - bar_index < 500
        array.push(ln, line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w))

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: f_drawLabelTZ
// Description: This function draws a label on the chart at a specified location with various customizable properties.
// Parameters:
//   _x (int) - The x-coordinate (bar index) where the label will be placed.
//   _y (float) - The y-coordinate (price level) where the label will be placed.
//   _text (string) - The text to be displayed on the label.
//   _xloc (string) - The x-location of the label relative to the bar (e.g., 'bar_index').
//   _yloc (string) - The y-location of the label relative to the price (e.g., 'price').
//   _color (color) - The background color of the label.
//   _style (label.style) - The style of the label (e.g., 'label.style_label_down').
//   _textcolor (color) - The color of the text on the label.
//   _size (size) - The size of the text on the label.
//   _textalign (text.align) - The alignment of the text within the label (e.g., 'text.align_center').
//   _tooltip (string) - The tooltip text to be displayed when hovering over the label.
// Returns:
//   void - This function does not return a value.
// Logic:
//   - If the difference between the current bar index and the specified x-coordinate is less than 500, create a new label with the specified properties and push it to the array 'lb'.
f_drawLabelTZ(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    if _x - bar_index < 500
        array.push(lb, label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip))

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: f_drawLinePVT
// Description: This function draws a line on the chart based on the provided coordinates and styling parameters.
// Parameters:
//   _x1 (float) - The x-coordinate of the starting point of the line.
//   _y1 (float) - The y-coordinate of the starting point of the line.
//   _x2 (float) - The x-coordinate of the ending point of the line.
//   _y2 (float) - The y-coordinate of the ending point of the line.
//   _xloc (string) - The location of the x-coordinate (e.g., bar_index or time).
//   _extend (string) - The extension type of the line (e.g., extend.none, extend.left, extend.right, extend.both).
//   _c (color) - The color of the line.
//   _s (string) - The style of the line (e.g., line.style_solid, line.style_dotted).
//   _w (int) - The width of the line.
// Returns:
//   void - This function does not return a value.
// Logic:
//   - If the y-coordinate of the starting point (_y1) is greater than 0, a new line is created with the specified parameters and added to the array `ln`.
f_drawLinePVT(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w) =>
    if _y1 > 0
        array.push(ln, line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w))

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: f_drawLabelPVT
// Description: This function draws a label on the chart at the specified coordinates with the given properties.
// Parameters:
//   _x (float) - The x-coordinate for the label.
//   _y (float) - The y-coordinate for the label.
//   _text (string) - The text to display on the label.
//   _xloc (series int) - The x-location of the label (e.g., bar index).
//   _yloc (series float) - The y-location of the label (e.g., price level).
//   _color (color) - The background color of the label.
//   _style (label.style) - The style of the label (e.g., label.style_label_down).
//   _textcolor (color) - The color of the text on the label.
//   _size (size) - The size of the text on the label.
//   _textalign (text.align) - The alignment of the text within the label.
//   _tooltip (string) - The tooltip text to display when hovering over the label.
// Logic:
//   - If the y-coordinate (_y) is greater than 0, push a new label to the array 'lb' with the specified properties.
//   - The label text is appended with new lines if 'i_extend' or 'i_levelsPvtP' is "Last Bar".
f_drawLabelPVT(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    if _y > 0
        array.push(lb, label.new(_x, _y, i_extend or i_levelsPvtP == "Last Bar" ? _text + '\n\n' : _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip))

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
f_setLog(log) => 
    array.set(log, 0, 0.0)
    array.set(log, 1, 0.0)
    array.set(log, 2, 0.0)
    array.set(log, 3, 0.0)
    array.set(log, 4, 0.0)
    array.set(log, 5, 0.0)
    array.set(log, 6, 0.0)
    array.set(log, 7, 0.0)
    array.set(log, 8, 0.0)
    array.set(log, 9, 0.0)
    array.set(log, 10, 0.0)
    array.set(log, 11, 0.0)
    array.set(log, 12, 0.0)
    array.set(log, 13, 0.0)
    array.set(log, 14, 0.0)
    array.set(log, 15, 0.0)
    array.set(log, 16, 0.0)
    array.set(log, 17, 0.0)
    array.set(log, 18, 0.0)
    array.set(log, 19, 0.0)
    array.set(log, 20, 0.0)
    array.set(log, 21, 0.0)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
f_getLevelIndex(float level) =>
    switch level
        value_0         => 0
        value_0_236     => 1
        value_0_382     => 2
        value_0_5       => 3
        value_0_618     => 4
        value_0_65      => 5
        value_0_786     => 6
        value_1         => 7
        value_1_272     => 8
        value_1_414     => 9
        value_1_618     => 10
        value_1_65      => 11
        value_2_618     => 12
        value_2_65      => 13
        value_3_618     => 14
        value_3_65      => 15
        value_4_236     => 16
        value_4_618     => 17
        value_neg_0_236 => 18
        value_neg_0_382 => 19
        value_neg_0_618 => 20
        value_neg_0_65  => 21
        => na

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
f_updateLevelsLog(log, float level, float value) =>
    array.set(log, f_getLevelIndex(level), value)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Function: f_processLevelX
// Description: This function processes and draws Fibonacci levels (Extensions, Retracements, and Pivot Points) on a chart based on the specified parameters.
// Parameters:
//   _show (bool) - A flag to determine whether to display the levels on the chart.
//   _level (float) - The Fibonacci level to be processed and drawn.
//   _color (color) - The color to be used for drawing the levels.
// Variables:
//   pPivotDiff (float) - The absolute difference between the mid pivot and the end base price.
//   price (float) - The calculated price level based on the Fibonacci level and other parameters.
//   offset (float) - The offset value used in calculating the price level for Extensions.
//   bar (int) - The bar index used for placing labels.
//   style (label.style) - The style of the label to be drawn.
//   size (size) - The size of the label to be drawn.
//   pivot (float) - The pivot point calculated as the average of high, low, and close prices of the higher time frame.
//   range_2 (float) - The range between the high and low prices of the higher time frame.
//   time_xx (int) - The time value used for placing labels.
// Logic:
//   - Depending on the selected Fibonacci tool (Extensions, Retracements, or Pivot Points), the function calculates and draws the respective levels on the chart.
//   - For Extensions, it draws lines and labels based on the calculated price levels and offsets.
//   - For Retracements, it draws lines and labels based on the calculated price levels and pivot differences.
//   - For Pivot Points, it calculates the pivot point and range, then draws lines and labels for the pivot levels.
//   - Alerts are triggered if the close price crosses any of the drawn levels.
f_processLevelX(_show, _level, _color) =>
    if _show
        pPivotDiff = math.abs(pMidPivot - pEndBase)
        price = 0.

        price := pEndBase < pMidPivot ? (i_reverse ? pEndBase : pMidPivot) - (i_reverse ? -1 : 1) * pPivotDiff * _level : (i_reverse ? pEndBase : pMidPivot) + (i_reverse ? -1 : 1) * pPivotDiff * _level
        price := math.round_to_mintick(price)
        f_drawLineX(_x1=iMidPivot, _y1=price, _x2=bar_index, _y2=price, _xloc=xloc.bar_index, _extend=i_extendER ? extend.both : extend.right, _color=_color, _style=line.style_solid, _width=_level != 1 ? 1 : 2)

        if i_levels != 'None'
            bar = i_levelsP == "Last Bar" ? bar_index : iMidPivot
            style = i_levelsP == "Last Bar" ? label.style_label_left : label.style_label_right
            size = i_levelsS == 'Small' ? size.small : size.normal

            f_drawLabelX(_x=bar, _y=price, _text=(i_levels == 'Prices' ? '' : 'RET ' + str.tostring(_level)) + (i_levels == 'Levels + Prices' or i_levels == 'Prices' ? ' (' + str.tostring(price, format.mintick) + ')' : ''), _xloc=xloc.bar_index, _yloc=yloc.price, _color=color.new(chart.fg_color, 100), _style=style, _textcolor=color.new(chart.fg_color, 0), _size=size, _textalign=text.align_right, _tooltip=str.tostring(price, format.mintick))
            f_updateLevelsLog(l_pivotLevelsLog_retracements, _level, price)

            if f_crossingLevel(close, price) //crossing level
                f_updateLevelsLog(l_pivotLevelsLog_crossed_retracements, _level, price)
 
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
f_logToString(log) => 
    result = ''

    for i = 0 to array.size(log) - 1
        current = array.get(log, i)

        if na(current)
            result := result + '0' + (i < array.size(log) - 1 ? s : '')
        else
            result := result + str.tostring(current) + (i < array.size(log) - 1 ? s : '')
        
    result

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
f_getAlertMessage(id) =>
    string log = ''
    string alert_base = str.tostring(bar_index) + s + str.tostring(last_bar_index) + s + str.tostring(time_tradingday) + s + str.tostring(time_close) + s + str.tostring(barstate.isnew ? 1 : 0) + s + str.tostring(barstate.isfirst ? 1 : 0) + s + str.tostring(barstate.islast ? 1 : 0) + s + str.tostring(barstate.isconfirmed ? 1 : 0) + s + str.tostring(barstate.ishistory ? 1 : 0) + s + str.tostring(barstate.islastconfirmedhistory ? 1 : 0) + s + str.tostring(session.isfirstbar ? 1 : 0) + s + str.tostring(open) + s + str.tostring(high) + s + str.tostring(low) + s + str.tostring(close) + s + str.tostring(hl2) + s + str.tostring(hlc3) + s + str.tostring(hlcc4) + s + str.tostring(ohlc4) + s + str.tostring(volume)

    if id == i_alert_id_update
        log := i_alert_id_update + s + alert_base + s + f_logToString(l_pivotLevelsLog_retracements) + s + f_logToString(l_pivotLevelsLog_crossed_retracements)
        
    if id == i_alert_id_crossoverExhaustion
        log := i_alert_id_crossoverExhaustion + s + alert_base + s + str.tostring(bullCandle) + s + str.tostring(bearCandle) + s + str.tostring(exhaustVol)
    
    if id == i_alert_id_crossoverVolatility
        log := i_alert_id_crossoverVolatility + s + alert_base + s + str.tostring(bullCandle) + s + str.tostring(bearCandle) + s + str.tostring(highVolatility)
    
    if id == i_alert_id_crossingLevelRetracements
        log := f_logToString(l_pivotLevelsLog_crossed_retracements)
        log := i_alert_id_crossingLevelRetracements + s + alert_base + s + log

    log


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Pivots
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// This script draws multiple lines on a chart based on Fibonacci time zones.
// The lines are drawn at intervals determined by the Fibonacci sequence (1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89).
// The reference interval is calculated as the rounded difference between `iEndBase2` and `iMidPivot2`.
// The color of the lines alternates between `i_tzColor` and `color.gray`.
if i_fibTime
    t_lineTZ_style = line.style_dotted
    t_lineTZ_width = 1
    t_lineTZ_color = color.new(chart.fg_color, 50)

    referance = math.round(iEndBase2 - iMidPivot2)

    f_drawLineTZ(_x1=iMidPivot2 - referance       , _y1=pEndBase2, _x2=iMidPivot2 - referance     , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2                   , _y1=pEndBase2, _x2=iMidPivot2                 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=t_lineTZ_color, _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance       , _y1=pEndBase2, _x2=iMidPivot2 + referance     , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=t_lineTZ_color, _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 2   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 2 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 3   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 3 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 5   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 5 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 8   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 8 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 13  , _y1=pEndBase2, _x2=iMidPivot2 + referance * 13, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 21  , _y1=pEndBase2, _x2=iMidPivot2 + referance * 21, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 34  , _y1=pEndBase2, _x2=iMidPivot2 + referance * 34, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 55  , _y1=pEndBase2, _x2=iMidPivot2 + referance * 55, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 89  , _y1=pEndBase2, _x2=iMidPivot2 + referance * 89, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=i_tzColor , _s=t_lineTZ_style, _w=t_lineTZ_width)

    // This block of code draws Fibonacci time zone labels on a chart.
    // The labels are drawn at specific intervals based on the Fibonacci sequence (0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89).
    if i_fib_tzl
        t_labelTZ_background = color.new(chart.fg_color, 100)
        t_labelTZ_text_align = text.align_center
        t_labelTZ_size = size.small
        t_labelTZ_color = color.new(chart.fg_color, 0)

        f_drawLabelTZ(_x=iMidPivot2 + referance * -1, _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='-1', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 0 , _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='0' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=t_labelTZ_color, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 1 , _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='1' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=t_labelTZ_color, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 2 , _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='2' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 3 , _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='3' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 5 , _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='5' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 8 , _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='8' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 13, _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='13', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 21, _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='21', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 34, _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='34', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 55, _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='55', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 89, _y=i_fib_tzlp2 == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='89', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=i_tzColor, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

f_processLevelX(show_0, value_0, color_0)
f_processLevelX(show_0_236, value_0_236, color_0_236)
f_processLevelX(show_0_382, value_0_382, color_0_382)
f_processLevelX(show_0_5, value_0_5, color_0_5)
f_processLevelX(show_0_618, value_0_618, color_0_618)
f_processLevelX(show_0_65, value_0_65, color_0_65)
f_processLevelX(show_0_786, value_0_786, color_0_786)
f_processLevelX(show_1, value_1, color_1)
f_processLevelX(show_1_272, value_1_272, color_1_272)
f_processLevelX(show_1_414, value_1_414, color_1_414)
f_processLevelX(show_1_618, value_1_618, color_1_618)
f_processLevelX(show_1_65, value_1_65, color_1_65)
f_processLevelX(show_2_618, value_2_618, color_2_618)
f_processLevelX(show_2_65, value_2_65, color_2_65)
f_processLevelX(show_3_618, value_3_618, color_3_618)
f_processLevelX(show_3_65, value_3_65, color_3_65)
f_processLevelX(show_4_236, value_4_236, color_4_236)
f_processLevelX(show_4_618, value_4_618, color_4_618)
f_processLevelX(show_neg_0_236, value_neg_0_236, color_neg_0_236)
f_processLevelX(show_neg_0_382, value_neg_0_382, color_neg_0_382)
f_processLevelX(show_neg_0_618, value_neg_0_618, color_neg_0_618)
f_processLevelX(show_neg_0_65, value_neg_0_65, color_neg_0_65)


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// AddOns
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Volume Spike - Sign of Exhaustion and High Volatility
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

plotchar(i_vSpikeLb and nzVolume != 0 ? exhaustVol : false, 'Exhaustion Bar', 'ğŸš¦', location.abovebar, size=size.tiny)

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
// Volume Spike - Sign of Exhaustion and High Volatility
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

plotchar(i_hATRLb ? highVolatility : false, 'High Volatile Bar', 'âš¡', location.belowbar, size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Alerts
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if alertEnabled and alertMode == 'calculateAlertUpdates'
    if barstate.isconfirmed
        alert(f_getAlertMessage(i_alert_id_update), alert.freq_once_per_bar) 
    
    if barstate.ishistory
        f_setLog(l_pivotLevelsLog_retracements)
        f_setLog(l_pivotLevelsLog_crossed_retracements)