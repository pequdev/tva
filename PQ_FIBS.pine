//@version=6
indicator(title = 'Shox Fibonacci Pivots [PQ_MOD]', shorttitle = 'FIBS1.0.0', overlay = true, max_lines_count=500, max_labels_count=500, max_boxes_count=500, max_polylines_count=100, max_bars_back=5000, dynamic_requests=true)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS & THEME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Colors
color COLOR_FG_MAIN     = chart.fg_color
color COLOR_RED         = #f44336
color COLOR_GREEN       = #4caf50
color COLOR_TEAL        = #009688
color COLOR_BLUE        = #2196f3
color COLOR_PURPLE      = #9c27b0
color COLOR_PINK        = #e91e63
color COLOR_GRAY        = #a2a2a2
color COLOR_LIGHT_GREEN = #81c784
color COLOR_LIGHT_BLUE  = #64b5f6

// Theme Transparencies
int TRANS_MAIN          = 25
int TRANS_SUPP          = 70

// Static Colors
color COLOR_TZ          = color.new(COLOR_FG_MAIN, 80)
color COLOR_ZZ          = color.new(COLOR_FG_MAIN, 75)
color COLOR_TEXT        = color.new(COLOR_FG_MAIN, 0)

// Configuration Constants
int LEVELS_COUNT        = 22

// Alert IDs
string ALERT_ID_UPDATE     = 'FBU'
string ALERT_ID_EXHAUSTION = 'EXH'
string ALERT_ID_VOLATILITY = 'HVO'
string ALERT_ID_CROSSING   = 'RCL'
string ALERT_ID_SETUP      = 'SCT'
string ALERT_ID_ENTRY      = 'SEN'
string ALERT_ID_OUTCOME    = 'SOT'
string ALERT_ID_LEARNING   = 'LRN'

// Alert Schema Version
string ALERT_SCHEMA_VERSION = '1.0.0'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIBONACCI CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float FIB_GOLDEN_RATIO    = 0.618
float FIB_GOLDEN_POCKET_H = 0.65
float FIB_EXTENSION_1272  = 1.272
float FIB_EXTENSION_1618  = 1.618

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOGARITHMIC RETURNS CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Annualization factors (periods per year)
int   LOG_PERIODS_DAILY         = 252   // Trading days per year (equities)
int   LOG_PERIODS_CRYPTO        = 365   // Calendar days (24/7 markets)
float LOG_PERIODS_1M            = 252.0 * 6.5 * 60  // 1-min bars per trading year
float LOG_PERIODS_5M            = 252.0 * 6.5 * 12  // 5-min bars per trading year
float LOG_PERIODS_15M           = 252.0 * 6.5 * 4   // 15-min bars per trading year
float LOG_PERIODS_1H            = 252.0 * 6.5       // 1-hour bars per trading year
float LOG_PERIODS_4H            = 252.0 * 1.625     // 4-hour bars per trading year

// Volatility window defaults
int   LOG_VOL_WINDOW            = 20    // Rolling volatility window

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SHANNON ENTROPY CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Default parameters
int   ENTROPY_WINDOW_DEFAULT    = 20    // Rolling window for log returns
int   ENTROPY_BINS_DEFAULT      = 5     // Number of bins for discretization
float ENTROPY_THRESH_DEFAULT    = 0.7   // Normalized entropy threshold (0-1)

// Regime classification
int   ENTROPY_REGIME_ORDERED    = 0     // Low entropy: structured/trending
int   ENTROPY_REGIME_TRANSITION = 1     // Highâ†’Low entropy: breakout
int   ENTROPY_REGIME_DISORDERED = 2     // High entropy: choppy/random

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HURST EXPONENT CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Default parameters
int   HURST_WINDOW_DEFAULT      = 100   // Rolling window for R/S calculation
float HURST_TREND_THRESH        = 0.55  // H > this â†’ persistent/trending
float HURST_MEANREV_THRESH      = 0.45  // H < this â†’ anti-persistent/mean-reverting
int   HURST_MIN_WINDOW          = 20    // Minimum window for stable estimate

// Regime classification
int   HURST_REGIME_TREND        = 0     // H > upper: persistent/trending
int   HURST_REGIME_RANDOM       = 1     // H near 0.5: random walk
int   HURST_REGIME_MEANREV      = 2     // H < lower: anti-persistent/mean-reverting

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Z-SCORE MOMENTUM CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Default parameters
int   ZSCORE_LR_LEN_DEFAULT     = 14    // Linear regression lookback
int   ZSCORE_ATR_LEN_DEFAULT    = 14    // ATR period for normalization
int   ZSCORE_Z_LEN_DEFAULT      = 50    // Rolling window for Z-score stats
float ZSCORE_THRESH_DEFAULT     = 2.0   // Z-score threshold for significance
int   ZSCORE_MIN_SAMPLES        = 10    // Minimum samples for valid Z-score

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BAYESIAN WIN-RATE & SORTINO CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Beta prior parameters (uninformative Bayes-Laplace prior)
float BAYES_ALPHA_PRIOR         = 1.0   // Prior alpha (pseudo-wins)
float BAYES_BETA_PRIOR          = 1.0   // Prior beta (pseudo-losses)
float BAYES_CONFIDENCE_LEVEL    = 0.95  // Confidence level for credible interval
float BAYES_PERCENTILE          = 0.05  // Lower bound percentile (1 - CL)

// Sortino ratio parameters
float SORTINO_MAR               = 0.0   // Minimum Acceptable Return (target)
float SORTINO_RF                = 0.0   // Risk-free rate
float SORTINO_MAX_CAP           = 10.0  // Cap Sortino when downside deviation is zero

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MONTE CARLO PERMUTATION CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int   MC_SIMS_DEFAULT           = 100   // Default number of permutation simulations
int   MC_SIMS_MAX               = 500   // Maximum simulations (Pine runtime safety)
int   MC_MIN_TRADES             = 10    // Minimum trades for valid permutation test
float MC_PVALUE_THRESH          = 0.05  // p-value threshold for significance (5%)
int   MC_SEED_BASE              = 42    // Base seed for reproducible randomness

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE FLAGS - Bitwise Trade/Setup State Representation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Direction Flag (Bit 0)
int FLAG_IS_LONG        = 1

// Entry State (Bit 1)
int FLAG_ZONE_TOUCHED   = 2

// Exit States (Bits 2-3) - Mutually exclusive
int FLAG_SL_HIT         = 4
int FLAG_TP_HIT         = 8

// Confluence Flags (Bit 4)
int FLAG_HAD_RSI_DIV    = 16

// TP Mode (Bit 5)
int FLAG_TP_AGGRESSIVE  = 32

// Analytics Tracking (Bits 6-7)
int FLAG_CONS_TP_HIT    = 64
int FLAG_AGGR_TP_HIT    = 128

// Lifecycle States (Bits 8-10) - Mutually exclusive
int FLAG_PENDING        = 256
int FLAG_ACTIVE         = 512
int FLAG_CLOSED         = 1024

// Outcome (Bit 11)
int FLAG_WON            = 2048

// Intrabar Resolution (Bit 12)
int FLAG_LTF_RESOLVED   = 4096

// Composite Masks
int MASK_OUTCOME        = 12
int MASK_CLOSED         = 1024
int MASK_LIFECYCLE      = 1792
int MASK_TP_TRACKING    = 192

// Max bit index
int STATE_MAX_BIT       = 12

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE FLAGS API - Arithmetic-Based Bit Operations for State Management
// Pine Script v6 does not have native bitwise operators, so we simulate them using arithmetic.
// Flags must be powers of 2: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048...
// NOTE: State flag methods are defined on each UDT (SetupRecord, BacktestTrade, SetupState) after their type definitions.
//       Methods: hasFlag(), setFlag(), clearFlag(), hasAny(), hasAll(), setLifecycle(), setOutcome()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTRABAR RESOLUTION - Chronological TP/SL Resolution Using LTF Data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Resolve TP/SL outcome chronologically using LTF intrabar data
// @param ltf_highs Array of LTF high values within current HTF bar
// @param ltf_lows Array of LTF low values within current HTF bar
// @param is_long True if this is a long trade (affects TP/SL direction checks)
// @param sl_price Stop loss price level
// @param tp_price Take profit price level
// @param conservative_tiebreak True = assume SL first on same-bar conflict, False = assume TP first
// @returns Tuple: [outcome, ltf_resolved, hit_index]
//          outcome: 1 = TP hit first, -1 = SL hit first, 0 = neither hit
//          ltf_resolved: true if resolved via LTF data, false if fallback used
//          hit_index: LTF bar index where outcome was determined (-1 if none)
f_resolveIntrabar(array<float> ltf_highs, array<float> ltf_lows, bool is_long, float sl_price, float tp_price, bool conservative_tiebreak) =>
    int outcome = 0          // 0 = undetermined, 1 = TP first, -1 = SL first
    bool ltf_resolved = false
    int hit_index = -1
    
    // Check if LTF data is available
    int ltf_count = array.size(ltf_highs)
    
    if ltf_count > 0
        // Iterate LTF bars chronologically (index 0 = earliest in HTF bar)
        for i = 0 to ltf_count - 1
            float ltf_high = array.get(ltf_highs, i)
            float ltf_low = array.get(ltf_lows, i)
            
            // Check TP/SL hits for this LTF bar
            bool sl_hit = is_long ? (ltf_low <= sl_price) : (ltf_high >= sl_price)
            bool tp_hit = is_long ? (ltf_high >= tp_price) : (ltf_low <= tp_price)
            
            // Resolve outcome for this intrabar
            if sl_hit and tp_hit
                // Both hit in same LTF bar - apply tie-break policy
                outcome := conservative_tiebreak ? -1 : 1  // -1 = SL, 1 = TP
                ltf_resolved := true
                hit_index := i
                break
            else if sl_hit
                outcome := -1  // SL hit first
                ltf_resolved := true
                hit_index := i
                break
            else if tp_hit
                outcome := 1   // TP hit first
                ltf_resolved := true
                hit_index := i
                break
    
    [outcome, ltf_resolved, hit_index]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOGARITHMIC RETURNS - Canonical Return Computation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Compute logarithmic (continuously compounded) return
// @param price_now Current price
// @param price_prev Previous price
// @returns Log return: ln(price_now / price_prev), or 0.0 if invalid
f_logReturn(float price_now, float price_prev) =>
    float result = 0.0
    if not na(price_now) and not na(price_prev) and price_prev > 0 and price_now > 0
        result := math.log(price_now / price_prev)
    result

// @function Convert summed log returns to simple (arithmetic) total return
// @param sum_log_returns Sum of log returns over period
// @returns Simple total return: exp(sum) - 1
f_logToSimpleReturn(float sum_log_returns) =>
    math.exp(sum_log_returns) - 1

// @function Get annualization factor based on timeframe
// @returns Periods per year for current chart timeframe
f_getPeriodsPerYear() =>
    float result = float(LOG_PERIODS_DAILY)
    if timeframe.isseconds
        result := LOG_PERIODS_1M * 60 / timeframe.multiplier
    else if timeframe.isminutes
        if timeframe.multiplier <= 1
            result := LOG_PERIODS_1M
        else if timeframe.multiplier <= 5
            result := LOG_PERIODS_5M
        else if timeframe.multiplier <= 15
            result := LOG_PERIODS_15M
        else if timeframe.multiplier <= 60
            result := LOG_PERIODS_1H
        else
            result := LOG_PERIODS_4H
    else if timeframe.isdaily
        result := float(LOG_PERIODS_DAILY)
    else if timeframe.isweekly
        result := 52.0
    else if timeframe.ismonthly
        result := 12.0
    result

// @function Compute annualized volatility from rolling log-return stdev
// @param log_return_stdev Standard deviation of log returns
// @param periods_per_year Annualization factor
// @returns Annualized volatility
f_annualizedVol(float log_return_stdev, float periods_per_year) =>
    log_return_stdev * math.sqrt(periods_per_year)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SHANNON ENTROPY - Regime Filter for Price Action Structure
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Compute Shannon entropy from bin counts
// @param bin_counts Array of counts per bin
// @param total_count Total number of samples
// @param num_bins Number of bins
// @returns Tuple [raw_entropy, normalized_entropy]
f_shannonEntropy(array<int> bin_counts, int total_count, int num_bins) =>
    float entropy = 0.0
    if total_count > 0
        for i = 0 to num_bins - 1
            int count = array.get(bin_counts, i)
            if count > 0
                float p = float(count) / float(total_count)
                entropy -= p * math.log(p) / math.log(2)
    float max_entropy = math.log(float(num_bins)) / math.log(2)
    float entropy_norm = max_entropy > 0 ? entropy / max_entropy : 0.0
    [entropy, entropy_norm]

// @function Compute rolling Shannon entropy of log returns
// @param log_return Current bar's log return
// @param window Rolling window length
// @param num_bins Number of bins for discretization
// @returns Tuple [raw_entropy, normalized_entropy, regime]
f_rollingEntropy(float log_return, int window, int num_bins, float threshold, bool allow_transition) =>
    var array<float> return_buffer = array.new_float(0)
    var float prev_entropy_norm = na
    
    if not na(log_return)
        array.push(return_buffer, log_return)
        if array.size(return_buffer) > window
            array.shift(return_buffer)
    
    float entropy = 0.0
    float entropy_norm = 0.0
    int regime = ENTROPY_REGIME_DISORDERED
    
    int buf_size = array.size(return_buffer)
    if buf_size >= num_bins
        float min_ret = array.min(return_buffer)
        float max_ret = array.max(return_buffer)
        float range_ret = max_ret - min_ret
        
        array<int> bin_counts = array.new_int(num_bins, 0)
        
        if range_ret > 0
            for i = 0 to buf_size - 1
                float r = array.get(return_buffer, i)
                int bin_idx = int(math.floor((r - min_ret) / range_ret * float(num_bins - 1)))
                bin_idx := math.min(bin_idx, num_bins - 1)
                array.set(bin_counts, bin_idx, array.get(bin_counts, bin_idx) + 1)
        else
            array.set(bin_counts, num_bins / 2, buf_size)
        
        [raw_h, norm_h] = f_shannonEntropy(bin_counts, buf_size, num_bins)
        entropy := raw_h
        entropy_norm := norm_h
        
        if entropy_norm < threshold
            regime := ENTROPY_REGIME_ORDERED
        else if allow_transition and not na(prev_entropy_norm) and prev_entropy_norm >= threshold and entropy_norm < threshold
            regime := ENTROPY_REGIME_TRANSITION
        else
            regime := ENTROPY_REGIME_DISORDERED
    
    prev_entropy_norm := entropy_norm
    [entropy, entropy_norm, regime]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HURST EXPONENT - Regime Filter for Market Persistence
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Compute R/S (Rescaled Range) for a single window
// @param data Array of values (log returns)
// @param start_idx Start index in array
// @param length Window length
// @returns R/S value (Range / StdDev)
f_computeRS(array<float> data, int start_idx, int length) =>
    float result = na
    if length >= 2 and start_idx >= 0 and start_idx + length <= array.size(data)
        // Compute mean of window
        float sum = 0.0
        for i = 0 to length - 1
            sum += array.get(data, start_idx + i)
        float mean_val = sum / float(length)
        
        // Compute mean-adjusted cumulative deviations and stdev
        float cum_dev = 0.0
        float min_cum = 0.0
        float max_cum = 0.0
        float sq_sum = 0.0
        
        for i = 0 to length - 1
            float val = array.get(data, start_idx + i)
            float dev = val - mean_val
            cum_dev += dev
            min_cum := i == 0 ? cum_dev : math.min(min_cum, cum_dev)
            max_cum := i == 0 ? cum_dev : math.max(max_cum, cum_dev)
            sq_sum += dev * dev
        
        // Range = max(cumulative) - min(cumulative)
        float range_val = max_cum - min_cum
        // Standard deviation
        float stdev = math.sqrt(sq_sum / float(length))
        
        // R/S = Range / StdDev (with S=0 handling)
        result := stdev > 0 ? range_val / stdev : 0.0
    result

// @function Estimate Hurst exponent using multi-scale R/S regression
// @param log_return Current bar's log return
// @param window Maximum window length
// @param min_window Minimum sub-window size
// @returns Tuple [hurst_value, regime]
f_rollingHurst(float log_return, int window, int min_window, float trend_thresh, float meanrev_thresh) =>
    var array<float> return_buffer = array.new_float(0)
    
    // Accumulate log returns
    if not na(log_return)
        array.push(return_buffer, log_return)
        if array.size(return_buffer) > window
            array.shift(return_buffer)
    
    float hurst = 0.5   // Default to random walk
    int regime = HURST_REGIME_RANDOM
    
    int buf_size = array.size(return_buffer)
    
    // Need enough data for multi-scale analysis
    if buf_size >= min_window
        // Multi-scale R/S regression: use sub-windows of increasing size
        // Sub-window sizes: min_window, min_window*1.5, min_window*2, ... up to buf_size
        array<float> log_n = array.new_float(0)
        array<float> log_rs = array.new_float(0)
        
        int n = min_window
        while n <= buf_size
            // Compute average R/S for this window size by dividing buffer into chunks
            int num_chunks = buf_size / n
            if num_chunks > 0
                float rs_sum = 0.0
                int valid_chunks = 0
                for chunk = 0 to num_chunks - 1
                    int start = chunk * n
                    float rs = f_computeRS(return_buffer, start, n)
                    if not na(rs) and rs > 0
                        rs_sum += rs
                        valid_chunks += 1
                
                if valid_chunks > 0
                    float avg_rs = rs_sum / float(valid_chunks)
                    array.push(log_n, math.log(float(n)))
                    array.push(log_rs, math.log(avg_rs))
            
            // Increase window size (geometric progression for efficiency)
            n := int(math.ceil(float(n) * 1.5))
        
        // Linear regression: log(R/S) = H * log(n) + c
        // Hurst = slope of the line
        int num_points = array.size(log_n)
        if num_points >= 2
            float sum_x = 0.0
            float sum_y = 0.0
            float sum_xy = 0.0
            float sum_xx = 0.0
            
            for i = 0 to num_points - 1
                float x = array.get(log_n, i)
                float y = array.get(log_rs, i)
                sum_x += x
                sum_y += y
                sum_xy += x * y
                sum_xx += x * x
            
            float n_pts = float(num_points)
            float denom = n_pts * sum_xx - sum_x * sum_x
            if math.abs(denom) > 1e-10
                hurst := (n_pts * sum_xy - sum_x * sum_y) / denom
                // Clamp to valid Hurst range [0, 1]
                hurst := math.max(0.0, math.min(1.0, hurst))
        
        // Classify regime based on thresholds
        if hurst > trend_thresh
            regime := HURST_REGIME_TREND
        else if hurst < meanrev_thresh
            regime := HURST_REGIME_MEANREV
        else
            regime := HURST_REGIME_RANDOM
    
    [hurst, regime]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Z-SCORE MOMENTUM - Regression Slope for Displacement Validation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Compute linear regression slope over a lookback window
// @param src Source series (typically close)
// @param length Lookback length
// @returns Slope value (price change per bar)
f_linregSlope(float src, int length) =>
    float slope = 0.0
    if length >= 2 and bar_index >= length - 1
        float sum_x = 0.0
        float sum_y = 0.0
        float sum_xy = 0.0
        float sum_xx = 0.0
        for i = 0 to length - 1
            float x = float(i)
            float y = nz(src[length - 1 - i])
            sum_x += x
            sum_y += y
            sum_xy += x * y
            sum_xx += x * x
        float n = float(length)
        float denom = n * sum_xx - sum_x * sum_x
        slope := math.abs(denom) > 1e-10 ? (n * sum_xy - sum_x * sum_y) / denom : 0.0
    slope

// @function Compute rolling Z-score of normalized slope
// @param norm_slope ATR-normalized slope value
// @param z_len Rolling window for mean/stdev
// @param min_samples Minimum samples for valid Z-score
// @returns Tuple [z_score, strong_momentum]
f_rollingZScore(float norm_slope, int z_len, int min_samples, float z_thresh) =>
    var array<float> slope_buffer = array.new_float(0)
    
    // Accumulate normalized slopes
    if not na(norm_slope)
        array.push(slope_buffer, norm_slope)
        if array.size(slope_buffer) > z_len
            array.shift(slope_buffer)
    
    float z_score = 0.0
    bool strong_momentum = false
    
    int buf_size = array.size(slope_buffer)
    if buf_size >= min_samples
        // Compute rolling mean
        float sum = 0.0
        for i = 0 to buf_size - 1
            sum += array.get(slope_buffer, i)
        float mean_val = sum / float(buf_size)
        
        // Compute rolling stdev
        float sq_sum = 0.0
        for i = 0 to buf_size - 1
            float dev = array.get(slope_buffer, i) - mean_val
            sq_sum += dev * dev
        float stdev = math.sqrt(sq_sum / float(buf_size))
        
        // Compute Z-score (with stdev=0 handling)
        z_score := stdev > 1e-10 ? (norm_slope - mean_val) / stdev : 0.0
        
        // Strong momentum = absolute Z exceeds threshold
        strong_momentum := math.abs(z_score) >= z_thresh
    
    [z_score, strong_momentum]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BAYESIAN WIN-RATE - Beta-Binomial Model for Sample-Size Penalized Estimation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Compute Beta distribution posterior mean
// @param alpha Posterior alpha (prior + wins)
// @param beta_param Posterior beta (prior + losses)
// @returns Posterior mean E[Î¸] = Î± / (Î± + Î²)
f_betaMean(float alpha, float beta_param) =>
    float total = alpha + beta_param
    total > 0 ? alpha / total : 0.5

// @function Compute Beta distribution variance
// @param alpha Posterior alpha
// @param beta_param Posterior beta
// @returns Variance = Î±Î² / ((Î±+Î²)Â²(Î±+Î²+1))
f_betaVariance(float alpha, float beta_param) =>
    float total = alpha + beta_param
    float denom = total * total * (total + 1.0)
    denom > 1e-10 ? (alpha * beta_param) / denom : 0.0

// @function Compute approximate lower credible bound using Normal approximation
// @description Uses Normal approximation to Beta: mean Â± z * sqrt(variance)
//              Valid when Î±, Î² > 1 and sample size is moderate.
//              Clamps result to [0, 1] to ensure valid probability.
// @param alpha Posterior alpha (prior + wins)
// @param beta_param Posterior beta (prior + losses)
// @param percentile Lower percentile (e.g., 0.05 for 5th percentile)
// @returns Conservative lower bound on win rate
f_betaLowerBound(float alpha, float beta_param, float percentile) =>
    float mean_val = f_betaMean(alpha, beta_param)
    float var_val = f_betaVariance(alpha, beta_param)
    float stdev = math.sqrt(var_val)
    
    // Z-score for percentile (approximation for common values)
    // percentile 0.05 â†’ z â‰ˆ -1.645, percentile 0.10 â†’ z â‰ˆ -1.282
    float z_score = percentile <= 0.05 ? -1.645 : percentile <= 0.10 ? -1.282 : percentile <= 0.25 ? -0.674 : 0.0
    
    float lower_bound = mean_val + z_score * stdev
    // Clamp to valid probability range
    math.max(0.0, math.min(1.0, lower_bound))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SORTINO RATIO - Downside-Risk Adjusted Performance Metric
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Compute Sortino Ratio from trade returns array
// @description Sortino = (Rp - Rf) / Ïƒ_down where Ïƒ_down only considers returns below MAR
// @param returns Array of trade log returns
// @param mar Minimum Acceptable Return (target threshold)
// @param rf Risk-free rate
// @param max_cap Maximum Sortino when downside deviation is zero
// @returns Sortino ratio (capped)
f_sortino(array<float> returns, float mar, float rf, float max_cap) =>
    int n = array.size(returns)
    if n < 2
        0.0
    else
        // Compute mean return
        float sum_returns = 0.0
        for i = 0 to n - 1
            sum_returns += array.get(returns, i)
        float mean_return = sum_returns / float(n)
        
        // Compute downside deviation (only returns below MAR)
        float sum_sq_downside = 0.0
        int downside_count = 0
        for i = 0 to n - 1
            float ret = array.get(returns, i)
            if ret < mar
                float diff = ret - mar
                sum_sq_downside += diff * diff
                downside_count += 1
        
        // Downside deviation = sqrt(mean of squared downside deviations)
        float downside_dev = downside_count > 0 ? math.sqrt(sum_sq_downside / float(n)) : 0.0
        
        // Sortino = (mean - rf) / downside_dev
        if downside_dev > 1e-10
            (mean_return - rf) / downside_dev
        else
            // No downside returns: return capped positive or 0 based on mean
            mean_return > rf ? max_cap : 0.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MONTE CARLO PERMUTATION - Fisher-Yates Shuffle & Significance Testing
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Simple linear congruential generator for reproducible pseudo-random numbers
// @param seed Current seed value
// @returns New pseudo-random seed (use modulo for range)
f_lcgNext(int seed) =>
    int a = 1664525
    int c = 1013904223
    int m = 2147483647
    (a * seed + c) % m

// @function Fisher-Yates shuffle (in-place) with LCG randomness
// @param arr Array to shuffle (modified in-place)
// @param seed Random seed for reproducibility
// @returns Final seed after shuffle
f_fisherYatesShuffle(array<float> arr, int seed) =>
    int n = array.size(arr)
    int current_seed = seed
    if n > 1
        for i = n - 1 to 1
            current_seed := f_lcgNext(current_seed)
            int j = current_seed % (i + 1)
            float temp = array.get(arr, i)
            array.set(arr, i, array.get(arr, j))
            array.set(arr, j, temp)
    current_seed

// @function Compute maximum drawdown from a return sequence
// @param returns Array of trade returns (log or R-multiples)
// @returns Maximum drawdown as positive fraction (0 = no drawdown, 1 = 100% loss)
f_maxDrawdown(array<float> returns) =>
    int n = array.size(returns)
    if n < 1
        0.0
    else
        float equity = 1.0
        float peak = 1.0
        float max_dd = 0.0
        for i = 0 to n - 1
            float ret = array.get(returns, i)
            equity := equity * math.exp(ret)
            peak := math.max(peak, equity)
            float dd = (peak - equity) / peak
            max_dd := math.max(max_dd, dd)
        max_dd

// @function Run Monte Carlo permutation test on trade returns
// @param returns Array of trade returns (log returns)
// @param num_sims Number of permutation simulations
// @param seed_base Base seed for reproducibility
// @returns Tuple [original_dd, mean_shuffled_dd, p_value, simulations_run]
f_monteCarloDD(array<float> returns, int num_sims, int seed_base) =>
    int n = array.size(returns)
    float original_dd = 0.0
    float mean_shuffled_dd = 0.0
    float p_value = 1.0
    int sims_run = 0
    
    if n >= MC_MIN_TRADES
        original_dd := f_maxDrawdown(returns)
        float sum_shuffled_dd = 0.0
        int better_count = 0
        
        array<float> shuffled = array.copy(returns)
        int current_seed = seed_base
        
        for sim = 0 to num_sims - 1
            shuffled := array.copy(returns)
            current_seed := f_fisherYatesShuffle(shuffled, current_seed + sim)
            float shuffled_dd = f_maxDrawdown(shuffled)
            sum_shuffled_dd += shuffled_dd
            if shuffled_dd < original_dd
                better_count += 1
            sims_run += 1
        
        mean_shuffled_dd := sum_shuffled_dd / float(num_sims)
        p_value := float(better_count) / float(num_sims)
    
    [original_dd, mean_shuffled_dd, p_value, sims_run]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEARNING ENGINE CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Minimum sample thresholds
int   LEARN_MIN_SAMPLES_SL      = 20
int   LEARN_MIN_SAMPLES_BUFFER  = 10
int   LEARN_MIN_SAMPLES_WR      = 10
int   LEARN_MIN_SAMPLES_MAE     = 5
int   LEARN_MIN_SAMPLES_DIV     = 5
int   LEARN_MIN_SAMPLES_DIR     = 5
int   LEARN_MIN_SAMPLES_LOSING  = 3
int   LEARN_MIN_SAMPLES_TP_COMP = 10
int   LEARN_MIN_SAMPLES_TIME    = 10

// Volatility regime thresholds
int   VOL_REGIME_HIGH_THRESH    = 60
int   VOL_REGIME_LOW_THRESH     = 40

// Near-miss detection
float NEAR_MISS_RATE_THRESH     = 0.10
float NEAR_MISS_BUFFER_MULT     = 5.0
float NEAR_MISS_BUFFER_MAX      = 5.0
float NEAR_MISS_CLOSE_THRESH    = 0.3

// Time decay Fibonacci thresholds
int   TIME_DECAY_T1             = 8
int   TIME_DECAY_T2             = 13
int   TIME_DECAY_T3             = 21
int   TIME_DECAY_T4             = 34
int   TIME_DECAY_T5             = 55
float TIME_DECAY_DEFAULT_RATE   = 0.85
float TIME_DECAY_SCALE_MIN      = 0.5
float TIME_DECAY_SCALE_MAX      = 2.0
int   TIME_DECAY_REFERENCE_BARS = 13

// SL learning
float SL_BUFFER_ATR             = 0.5
float SL_LOSING_MAE_FACTOR      = 1.5

// Confidence scoring thresholds
int   CONF_GRADE_D_THRESH       = 25
int   CONF_GRADE_C_THRESH       = 50
int   CONF_GRADE_B_THRESH       = 70
int   CONF_GRADE_A_THRESH       = 85

// Streak tracking
int   STREAK_WIN_BONUS_THRESH   = 3
int   STREAK_LOSS_PENALTY_THRESH = 3
int   STREAK_PENALTY_MAX        = 15
float STREAK_PENALTY_RATE       = 5.0
int   STREAK_LOSS_PENALTY_BASE  = 2
int   STREAK_BONUS_MAX          = 10
float STREAK_BONUS_RATE         = 3.33
int   STREAK_WIN_BONUS_BASE     = 2

// Health check thresholds
int   HEALTH_STALE_BARS         = 100
float HEALTH_WR_MIN             = 0.25
float HEALTH_WR_MAX             = 0.85
float HEALTH_PF_MIN             = 0.7

// Kelly calculation
float KELLY_MIN_EDGE            = 0.01

// Decay rate learning
float DECAY_RATE_MIN            = 0.75
float DECAY_RATE_MAX            = 0.95
float DECAY_RATE_ADJUST         = 0.14

// Confidence scoring weights
int   CONF_WR_WEIGHT            = 35
float CONF_WR_MIN_MAP           = 0.3
float CONF_WR_MAX_MAP           = 0.8
int   CONF_RSI_WEIGHT           = 20
int   CONF_PF_WEIGHT            = 15
int   CONF_HEALTH_WEIGHT        = 15
float CONF_PF_MIN_MAP           = 0.5
float CONF_PF_MAX_MAP           = 2.0

// Default initial values
float DEFAULT_WIN_RATE          = 0.618
float DEFAULT_DECAY_RATE        = 0.85
float DEFAULT_CONFIDENCE        = 50.0
float DEFAULT_MIN_DISTANCE      = 100.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI TEXT CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string TEXT_LONG        = "LONG"
string TEXT_SHORT       = "SHORT"
string TEXT_SETUP       = " SETUP"
string TEXT_ACTIVE      = " [ACTIVE]"
string TEXT_SL_HIT      = " [SL HIT]"
string TEXT_TP_HIT      = " [TP HIT]"
string TEXT_EXPIRED     = " [EXPIRED]"
string TEXT_FRESH       = "FRESH"
string TEXT_STALE       = "STALE"
string TEXT_LEARNING    = "ğŸ“Š Learning..."
string TEXT_SAMPLES     = " samples"

// UI Icons
string ICON_BRAIN       = "ğŸ§ "
string ICON_CHART       = "ğŸ“Š"
string ICON_TARGET      = "ğŸ¯"
string ICON_FIRE        = "ğŸ”¥"
string ICON_ICE         = "â„ï¸"
string ICON_LIGHTNING   = "âš¡"
string ICON_WAVE        = "ğŸŒŠ"
string ICON_CHECK       = "âœ“"
string ICON_WARNING     = "âš "
string ICON_HOURGLASS   = "â³"

// Tooltips
string TOOLTIP_THRESHOLD   = 'Deviation is a multiplier that affects how much the price should deviate from the previous pivot in order for the bar to become a new pivot\n\nDepth affects the minimum number of bars that will be taken into account when building'
string TOOLTIP_PIVOT_POINT = 'A pivot point is a technical analysis indicator used to determine the overall trend of the market over different time frames'
string TOOLTIP_ZIGZAG      = 'The Zig Zag indicator is used to identify price trends then connected by straight lines that help the trader visual the price action.'
string TOOLTIP_VOL_EXHAUST = 'Moments where huge volume detected'
string TOOLTIP_HIGH_VOL    = 'Moments where price range of the current bar is greater than average true range'
string TOOLTIP_STAT_POS    = 'Calculates the Statistical "Golden Pocket" (0.618-0.65) entry zone.\n\nStop Loss is placed at the Pivot Start (Invalidation) adjusted by an ATR variance to prevent Stop Hunting.\n\nTake Profit targets the Pivot End (Conservative) or 1.272 Extension (Aggressive).'

// Groups
string GROUP_PICK       = 'Pick a Fibonacci Tool'
string GROUP_PIVOT      = 'Fibonacci Pivot Points Settings'
string GROUP_THRESH_SEC = 'Threshold (sec)'
string GROUP_THRESH_MIN = 'Threshold (minutes)'
string GROUP_THRESH_H   = 'Threshold (hours)'
string GROUP_THRESH_D   = 'Threshold (days)'
string GROUP_THRESH_W   = 'Threshold (weeks)'
string GROUP_THRESH_M   = 'Threshold (months)'
string GROUP_DEPTH_SEC  = 'Depth (seconds)'
string GROUP_DEPTH_MIN  = 'Depth (minutes)'
string GROUP_DEPTH_H    = 'Depth (hours)'
string GROUP_DEPTH_D    = 'Depth (days)'
string GROUP_DEPTH_W    = 'Depth (weeks)'
string GROUP_DEPTH_M    = 'Depth (months)'
string GROUP_FIB_TOOL   = 'Fibonacci Extention / Retracement / TimeZone Settings'
string GROUP_FIB_LEVELS = 'Fibonacci Levels'
string GROUP_ZIGZAG     = 'ZigZag Settings'
string GROUP_VOL_VOL    = 'Volume / Volatility AddOns'
string GROUP_ALERTS     = 'Alerts'
string GROUP_STAT_POS   = 'Statistical Position Engine'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INPUT_SHOW_FIB_TIME     = input.bool(true, 'Fib Time Zones', inline='TZ', group=GROUP_PICK)
INPUT_CUSTOM_THRESHOLD  = input.bool(true, 'Custom thresholds', inline='C')
INPUT_CUSTOM_DEPTH      = input.bool(true, 'Custom depths', inline='C')

// Pivot Settings
INPUT_HTF_MODE          = input.string('Auto', 'Pivot Points TimeFrame', options=['Auto', 'User Defined'], inline='HTF', group=GROUP_PIVOT, tooltip=TOOLTIP_PIVOT_POINT)
INPUT_HTF_USER_RAW      = input.string('15 Min', 'â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒor User Defined', options=['15 Min', '1 Hour', '4 Hour', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Yearly'], inline='HTF1', group=GROUP_PIVOT)

// Parse HTF input
htf_user_parsed = INPUT_HTF_USER_RAW == '15 Min'? '15' : 
                  INPUT_HTF_USER_RAW == '1 Hour'? '60' : 
                  INPUT_HTF_USER_RAW == '4 Hour'? '240' : 
                  INPUT_HTF_USER_RAW == 'Daily'? 'D' : 
                  INPUT_HTF_USER_RAW == 'Weekly'? 'W' : 
                  INPUT_HTF_USER_RAW == 'Monthly'? 'M' : 
                  INPUT_HTF_USER_RAW == 'Quarterly'? '3M' : '12M'

INPUT_LEVELS_PVT        = input.string('Prices', 'Level Labels', options=['Levels', 'Prices', 'Levels + Prices', 'None'], inline='pvt', group=GROUP_PIVOT)
INPUT_LEVELS_PVT_POS    = input.string('Pivot End', '', options=['Last Bar', 'Pivot End'], inline='pvt', group=GROUP_PIVOT)
INPUT_LEVELS_PVT_SIZE   = input.string('Small', '', options=['Small', 'Normal'], inline='pvt', group=GROUP_PIVOT)
INPUT_EXTEND_PVT        = input.bool(false, 'Extend Pivot Point Lines', inline='fLines', group=GROUP_PIVOT)

// @function Calculate deviation threshold based on ATR and multiplier
// @param dev_treshold Deviation multiplier
// @returns Deviation threshold as percentage
dev_treshold(float dev_treshold) => ta.atr(2) / close * 100 * dev_treshold
// Deviation Thresholds (map-based for O(1) lookup)
var map<string, float> TF_DEV_THRESHOLDS = map.new<string, float>()
TF_DEV_THRESHOLDS.put("DEFAULT", dev_treshold(input.float(2.0, 'Deviation (default)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC, tooltip=TOOLTIP_THRESHOLD)))
TF_DEV_THRESHOLDS.put("1S", dev_treshold(input.float(2.0, 'Deviation (1S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
TF_DEV_THRESHOLDS.put("5S", dev_treshold(input.float(2.0, 'Deviation (5S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
TF_DEV_THRESHOLDS.put("10S", dev_treshold(input.float(2.0, 'Deviation (10S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
TF_DEV_THRESHOLDS.put("15S", dev_treshold(input.float(2.0, 'Deviation (15S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
TF_DEV_THRESHOLDS.put("30S", dev_treshold(input.float(2.0, 'Deviation (30S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
TF_DEV_THRESHOLDS.put("45S", dev_treshold(input.float(2.0, 'Deviation (45S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC)))
TF_DEV_THRESHOLDS.put("1", dev_treshold(input.float(2.0, 'Deviation (1M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
TF_DEV_THRESHOLDS.put("2", dev_treshold(input.float(2.0, 'Deviation (2M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
TF_DEV_THRESHOLDS.put("3", dev_treshold(input.float(2.0, 'Deviation (3M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
TF_DEV_THRESHOLDS.put("5", dev_treshold(input.float(2.0, 'Deviation (5M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
TF_DEV_THRESHOLDS.put("10", dev_treshold(input.float(2.0, 'Deviation (10M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
TF_DEV_THRESHOLDS.put("15", dev_treshold(input.float(2.0, 'Deviation (15M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
TF_DEV_THRESHOLDS.put("30", dev_treshold(input.float(2.0, 'Deviation (30M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
TF_DEV_THRESHOLDS.put("45", dev_treshold(input.float(2.0, 'Deviation (45M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN)))
TF_DEV_THRESHOLDS.put("60", dev_treshold(input.float(2.0, 'Deviation (1H)', minval=0, inline='Pivots', group=GROUP_THRESH_H)))
TF_DEV_THRESHOLDS.put("120", dev_treshold(input.float(2.0, 'Deviation (2H)', minval=0, inline='Pivots', group=GROUP_THRESH_H)))
TF_DEV_THRESHOLDS.put("180", dev_treshold(input.float(2.0, 'Deviation (3H)', minval=0, inline='Pivots', group=GROUP_THRESH_H)))
TF_DEV_THRESHOLDS.put("240", dev_treshold(input.float(2.0, 'Deviation (4H)', minval=0, inline='Pivots', group=GROUP_THRESH_H)))
TF_DEV_THRESHOLDS.put("1D", dev_treshold(input.float(2.0, 'Deviation (1D)', minval=0, inline='Pivots', group=GROUP_THRESH_D)))
TF_DEV_THRESHOLDS.put("7D", dev_treshold(input.float(2.0, 'Deviation (7D)', minval=0, inline='Pivots', group=GROUP_THRESH_D)))
TF_DEV_THRESHOLDS.put("4W", dev_treshold(input.float(2.0, 'Deviation (4W)', minval=0, inline='Pivots', group=GROUP_THRESH_W)))
TF_DEV_THRESHOLDS.put("3M", dev_treshold(input.float(2.0, 'Deviation (3Mo)', minval=0, inline='Pivots', group=GROUP_THRESH_M)))
TF_DEV_THRESHOLDS.put("6M", dev_treshold(input.float(2.0, 'Deviation (6Mo)', minval=0, inline='Pivots', group=GROUP_THRESH_M)))
TF_DEV_THRESHOLDS.put("12M", dev_treshold(input.float(2.0, 'Deviation (12Mo)', minval=0, inline='Pivots', group=GROUP_THRESH_M)))

// Depths (map-based for O(1) lookup)
var map<string, int> TF_DEPTHS = map.new<string, int>()
TF_DEPTHS.put("DEFAULT", input.int(10, 'Depth (default)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
TF_DEPTHS.put("1S", input.int(10, 'Depth (1S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
TF_DEPTHS.put("5S", input.int(10, 'Depth (5S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
TF_DEPTHS.put("10S", input.int(10, 'Depth (10S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
TF_DEPTHS.put("15S", input.int(10, 'Depth (15S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
TF_DEPTHS.put("30S", input.int(10, 'Depth (30S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
TF_DEPTHS.put("45S", input.int(10, 'Depth (45S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC))
TF_DEPTHS.put("1", input.int(10, 'Depth (1M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
TF_DEPTHS.put("2", input.int(10, 'Depth (2M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
TF_DEPTHS.put("3", input.int(10, 'Depth (3M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
TF_DEPTHS.put("5", input.int(10, 'Depth (5M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
TF_DEPTHS.put("10", input.int(10, 'Depth (10M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
TF_DEPTHS.put("15", input.int(10, 'Depth (15M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
TF_DEPTHS.put("30", input.int(10, 'Depth (30M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
TF_DEPTHS.put("45", input.int(10, 'Depth (45M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN))
TF_DEPTHS.put("60", input.int(10, 'Depth (1H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H))
TF_DEPTHS.put("120", input.int(10, 'Depth (2H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H))
TF_DEPTHS.put("180", input.int(10, 'Depth (3H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H))
TF_DEPTHS.put("240", input.int(10, 'Depth (4H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H))
TF_DEPTHS.put("1D", input.int(10, 'Depth (1D)', minval=1, inline='Pivots', group=GROUP_DEPTH_D))
TF_DEPTHS.put("7D", input.int(10, 'Depth (7D)', minval=1, inline='Pivots', group=GROUP_DEPTH_D))
TF_DEPTHS.put("4W", input.int(10, 'Depth (4W)', minval=1, inline='Pivots', group=GROUP_DEPTH_W))
TF_DEPTHS.put("3M", input.int(10, 'Depth (3Mo)', minval=1, inline='Pivots', group=GROUP_DEPTH_M))
TF_DEPTHS.put("6M", input.int(10, 'Depth (6Mo)', minval=1, inline='Pivots', group=GROUP_DEPTH_M))
TF_DEPTHS.put("12M", input.int(10, 'Depth (12Mo)', minval=1, inline='Pivots', group=GROUP_DEPTH_M))

// Fibonacci Tools
INPUT_LEVELS_LABEL      = input.string('Prices', 'Level Labels', options=['Levels', 'Prices', 'Levels + Prices', 'None'], inline='fLines', group=GROUP_FIB_TOOL)
INPUT_LEVELS_POS        = input.string('Pivot Start', '', options=['Last Bar', 'Pivot Start'], inline='fLines', group=GROUP_FIB_TOOL)
INPUT_LEVELS_SIZE       = input.string('Small', '', options=['Small', 'Normal'], inline='fLines', group=GROUP_FIB_TOOL)
INPUT_REVERSE           = input.bool(false, 'Reverse Extention / Retracement Levels', group=GROUP_FIB_TOOL)
INPUT_EXTEND_ER         = input.bool(false, 'Extend Extention / Retracement Lines', inline='fLine', group=GROUP_FIB_TOOL)
INPUT_HIST_PIVOT        = input.int (0, 'Historical Extention / Retracement Levels', minval=0, group=GROUP_FIB_TOOL)
INPUT_HIST_PIVOT_2      = input.int(0, 'Historical Time Zones', minval=0, group=GROUP_FIB_TOOL)
INPUT_FIB_TZ_LABEL      = input.bool(false, 'Time Zone Lables', inline='tz poz', group=GROUP_FIB_TOOL)
INPUT_FIB_TZ_POS_X      = input.string('Left', '', options=['Right', 'Left'], inline='tz poz', group=GROUP_FIB_TOOL)
fib_tzlp                = INPUT_FIB_TZ_POS_X == 'Left' ? label.style_label_left : label.style_label_right
INPUT_FIB_TZ_POS_Y      = input.string('Bottom', '', options=['Bottom', 'Top'], inline='tz poz', group=GROUP_FIB_TOOL)

// --- STATISTICAL POSITION ENGINE INPUTS ---
INPUT_SHOW_POS          = input.bool(true, 'Show Stat Position Preview', group=GROUP_STAT_POS, tooltip=TOOLTIP_STAT_POS)
INPUT_POS_SL_MULT       = input.float(1.5, 'Stop Loss Variance (ATR Mult)', minval=0.1, step=0.1, group=GROUP_STAT_POS, tooltip="Buffer added to the Structural Invalidation Point (Pivot Start) to prevent Stop Hunts.")
INPUT_POS_SL_DYNAMIC    = input.bool(true, 'Dynamic SL (Volatility-Adjusted)', group=GROUP_STAT_POS, tooltip="Automatically widens SL during high-volatility regimes and tightens during low-volatility.\nUses ATR percentile ranking over 100 bars to scale the SL multiplier Â±50%.")
INPUT_POS_RSI_DIV       = input.bool(true, 'RSI Divergence Filter', group=GROUP_STAT_POS, tooltip="Adds momentum confluence by detecting RSI divergence at the Golden Pocket.\nBullish div: price lower but RSI higher (for longs).\nBearish div: price higher but RSI lower (for shorts).\nBoosts confidence when divergence confirms the setup.")
INPUT_POS_RSI_LEN       = input.int(14, 'RSI Length', minval=2, maxval=50, group=GROUP_STAT_POS, tooltip="Period for RSI calculation. Default 14 is standard.")
INPUT_POS_TIME_DECAY    = input.bool(true, 'Fib Time Decay', group=GROUP_STAT_POS, tooltip="Applies time-based decay to zone validity using Fibonacci sequence thresholds (8, 13, 21, 34, 55, 89 bars).\nZone fades 15% at each Fib threshold, reducing win probability and visual opacity.\nCrypto moves fastâ€”stale setups lose edge.")
INPUT_POS_TP_MODE       = input.string('Conservative', 'Take Profit Mode', options=['Conservative', 'Aggressive'], group=GROUP_STAT_POS, tooltip="Conservative: Targets Pivot End (0.0).\nAggressive: Targets 1.272 Extension.")
INPUT_POS_WIN_RATE      = input.float(61.8, 'Assumed Win Rate %', minval=1.0, maxval=99.0, step=1.0, group=GROUP_STAT_POS, tooltip="Estimated win probability for Kelly Criterion sizing.\nDefault 61.8% aligns with Golden Ratio confluence.\nAdjust based on your backtested strategy performance.")
INPUT_POS_KELLY_FRAC    = input.float(0.5, 'Kelly Fraction', minval=0.1, maxval=1.0, step=0.1, group=GROUP_STAT_POS, tooltip="Fraction of Kelly to use (Half-Kelly = 0.5 is standard for reduced variance).\n1.0 = Full Kelly (aggressive), 0.25 = Quarter Kelly (conservative).")
// --- LEARNING ENGINE INPUTS ---
INPUT_LEARNING_ENABLED  = input.bool(true, 'ğŸ“Š Adaptive Learning', group=GROUP_STAT_POS, tooltip="Enables backtesting-based learning.\nTracks setup outcomes over historical bars to:\nâ€¢ Adapt zone buffer based on near-misses\nâ€¢ Calculate empirical win rate\nâ€¢ Optimize parameters automatically.")
INPUT_LEARNING_SAMPLES  = input.int(50, 'Learning Sample Size', minval=10, maxval=500, group=GROUP_STAT_POS, tooltip="Number of past setups to analyze for learning.\nMore samples = more stable estimates but slower adaptation.")
INPUT_ZONE_BUFFER_BASE  = input.float(0.0, 'Zone Buffer % (Base)', minval=0.0, maxval=100.0, step=0.05, group=GROUP_STAT_POS, tooltip="Manual buffer added to Golden Pocket boundaries.\nLearning engine may increase this if near-misses detected.")
INPUT_NEAR_MISS_THRESH  = input.float(0.5, 'Near-Miss Threshold %', minval=0.1, maxval=100.0, step=0.1, group=GROUP_STAT_POS, tooltip="Distance threshold for detecting near-misses.\nIf price comes within this % of zone but doesn't enter, it's a near-miss.")
INPUT_USE_LEARNED_SL    = input.bool(true, 'ğŸ§  Use Learned SL (Phase 2)', group=GROUP_STAT_POS, tooltip="When enabled, uses the learned optimal SL multiplier from MAE analysis.\nRequires 20+ samples with 5+ winning trades.\nThe learned SL is based on: avg MAE of winners + 0.5 ATR buffer.")
// --- PHASE 3: ADVANCED LEARNING CONTROLS ---
INPUT_LEARN_TP          = input.bool(true, 'ğŸ§  Learn Optimal TP Mode', group=GROUP_STAT_POS, tooltip="Learns whether Conservative or Aggressive TP mode has better expected value.\nCompares hit rates and R:R of each mode from historical data.")
INPUT_LEARN_DECAY       = input.bool(true, 'ğŸ§  Learn Time Decay Rate', group=GROUP_STAT_POS, tooltip="Learns optimal time decay rate from bars_to_outcome distribution.\nIf most wins happen early, accelerates decay. If wins persist, slows decay.")
INPUT_LEARN_RSI_WEIGHT  = input.bool(true, 'ğŸ§  Learn RSI Weight', group=GROUP_STAT_POS, tooltip="Learns how much to weight RSI divergence in Kelly calculation.\nBased on the edge gained from divergence-confirmed vs non-confirmed setups.")
INPUT_LEARN_MIN_SAMPLES = input.int(30, 'Min Samples for Learning', minval=10, maxval=100, group=GROUP_STAT_POS, tooltip="Minimum number of samples required before applying learned parameters.\nHigher = more stable but slower adaptation.")
// --- PROJECTION MODE ---
INPUT_PROJECTION_MODE   = input.bool(true, 'âš¡ Projection Mode (Early Pivot)', group=GROUP_STAT_POS, tooltip="Shows tentative Golden Pocket in real-time when price retraces by deviation threshold from local high/low.\nDoes not wait for full depth confirmation.\nAllows earlier entry signals but may repaint.")
INPUT_PROJ_SENSITIVITY  = input.float(0.5, '   â†³ Sensitivity', minval=0.1, maxval=1.0, step=0.1, group=GROUP_STAT_POS, tooltip="Scalar for deviation threshold. < 1.0 reduces lag for tentative setups but increases false positive rate.\n0.5 = 50% of normal threshold (faster signals).\n1.0 = same as confirmed ZigZag (no early warning).")
// --- INTRABAR PRECISION (Backtest Engine) ---
INPUT_INTRABAR_ENABLED  = input.bool(true, 'ğŸ”¬ Intrabar Precision', group=GROUP_STAT_POS, tooltip="Uses lower timeframe data to resolve TP/SL order when both are hit in the same HTF bar.\nEliminates look-ahead bias and improves backtest accuracy.\nRequires dynamic_requests=true in indicator declaration.")
INPUT_INTRABAR_TF       = input.string('5', '   â†³ LTF Resolution', options=['1', '5', '15'], group=GROUP_STAT_POS, tooltip="Lower timeframe for intrabar inspection.\n1 = 1 minute (most precise, higher overhead)\n5 = 5 minutes (balanced, recommended)\n15 = 15 minutes (fastest, less precise)")
INPUT_INTRABAR_TIEBREAK = input.string('Conservative', '   â†³ Tie-Break Policy', options=['Conservative', 'Optimistic'], group=GROUP_STAT_POS, tooltip="When TP and SL are hit in the same LTF bar:\nConservative: Assume SL hit first (capital preservation)\nOptimistic: Assume TP hit first (best case)")
// --- SHANNON ENTROPY FILTER ---
INPUT_ENTROPY_ENABLED   = input.bool(true, 'ğŸ² Entropy Regime Filter', group=GROUP_STAT_POS, tooltip="Filters trades based on Shannon Entropy of recent price action.\nBlocks signals during high-entropy (choppy/random) regimes.\nAllows signals during low-entropy (structured/trending) regimes.")
INPUT_ENTROPY_WINDOW    = input.int(20, '   â†³ Window Length', minval=5, maxval=100, group=GROUP_STAT_POS, tooltip="Number of bars for entropy calculation.\nLarger = more stable but slower to adapt.\n20 is recommended for most timeframes.")
INPUT_ENTROPY_BINS      = input.int(5, '   â†³ Bin Count', minval=3, maxval=10, group=GROUP_STAT_POS, tooltip="Number of bins for discretizing returns.\n5 bins = [Large Down, Small Down, Neutral, Small Up, Large Up]\nMore bins = finer resolution but needs more data.")
INPUT_ENTROPY_THRESH    = input.float(0.7, '   â†³ Threshold', minval=0.1, maxval=1.0, step=0.05, group=GROUP_STAT_POS, tooltip="Normalized entropy threshold (0-1).\nBelow = ORDERED (allow trades)\nAbove = DISORDERED (block trades)\n0.7 is a balanced default.")
INPUT_ENTROPY_TRANSITION = input.bool(false, '   â†³ Allow Transitions', group=GROUP_STAT_POS, tooltip="When enabled, allows trades during highâ†’low entropy transitions.\nDetects breakouts from consolidation (chopâ†’trend).\nExperimental: may increase false positives.")
// --- HURST EXPONENT FILTER ---
INPUT_HURST_ENABLED     = input.bool(true, 'ğŸ“ˆ Hurst Regime Filter', group=GROUP_STAT_POS, tooltip="Filters trades based on Hurst Exponent (market persistence).\nH > 0.5 = trending (persistent), H < 0.5 = mean-reverting.\nOptionally blocks trades near H â‰ˆ 0.5 (random walk).")
INPUT_HURST_WINDOW      = input.int(100, '   â†³ Window Length', minval=20, maxval=500, group=GROUP_STAT_POS, tooltip="Number of bars for Hurst calculation.\nLarger = more stable but slower to adapt.\n100 is recommended for most timeframes.")
INPUT_HURST_TREND       = input.float(0.55, '   â†³ Trend Threshold', minval=0.50, maxval=0.80, step=0.01, group=GROUP_STAT_POS, tooltip="H above this = TRENDING regime.\nPersistent price movement, favor breakouts.\n0.55 is a conservative default.")
INPUT_HURST_MEANREV     = input.float(0.45, '   â†³ Mean-Revert Threshold', minval=0.20, maxval=0.50, step=0.01, group=GROUP_STAT_POS, tooltip="H below this = MEAN-REVERTING regime.\nAnti-persistent movement, favor fades.\n0.45 is a conservative default.")
INPUT_HURST_BLOCK_RANDOM = input.bool(false, '   â†³ Block Random Regime', group=GROUP_STAT_POS, tooltip="When enabled, blocks trades when H is near 0.5 (random walk).\nReduces exposure during unpredictable conditions.\nExperimental: may reduce trade frequency significantly.")
// --- Z-SCORE MOMENTUM FILTER ---
INPUT_ZSCORE_ENABLED    = input.bool(true, 'âš¡ Momentum Z-Score Filter', group=GROUP_STAT_POS, tooltip="Filters trades based on displacement velocity.\nRequires statistically significant momentum (Z > threshold).\nBlocks slow drift fakeouts.")
INPUT_ZSCORE_LR_LEN     = input.int(14, '   â†³ Regression Length', minval=5, maxval=50, group=GROUP_STAT_POS, tooltip="Lookback for linear regression slope.\n14 bars is a balanced default.\nShorter = more sensitive, longer = smoother.")
INPUT_ZSCORE_ATR_LEN    = input.int(14, '   â†³ ATR Length', minval=5, maxval=50, group=GROUP_STAT_POS, tooltip="ATR period for volatility normalization.\nMakes momentum comparable across assets.\n14 is standard.")
INPUT_ZSCORE_Z_LEN      = input.int(50, '   â†³ Z-Score Window', minval=20, maxval=200, group=GROUP_STAT_POS, tooltip="Rolling window for mean/stdev of normalized slope.\nLarger = more stable Z-score.\n50 is recommended.")
INPUT_ZSCORE_THRESH     = input.float(2.0, '   â†³ Z Threshold', minval=1.0, maxval=4.0, step=0.1, group=GROUP_STAT_POS, tooltip="Z-score threshold for significant momentum.\n2.0 = ~95% confidence (2 sigma).\nHigher = stricter filtering.")
// --- BAYESIAN WIN-RATE & SORTINO ---
INPUT_BAYES_ENABLED     = input.bool(true, 'ğŸ“Š Bayesian Win-Rate', group=GROUP_STAT_POS, tooltip="Replaces naive win rate with Bayesian Beta-Binomial model.\nAutomatically penalizes small sample sizes.\nOutputs conservative lower credible bound.")
INPUT_BAYES_ALPHA_PRIOR = input.float(1.0, '   â†³ Prior Î± (Pseudo-Wins)', minval=0.1, maxval=10.0, step=0.1, group=GROUP_STAT_POS, tooltip="Prior pseudo-wins for Beta distribution.\n1.0 = uninformative Bayes-Laplace prior.\nHigher = more conservative (shrinks toward 0.5).")
INPUT_BAYES_BETA_PRIOR  = input.float(1.0, '   â†³ Prior Î² (Pseudo-Losses)', minval=0.1, maxval=10.0, step=0.1, group=GROUP_STAT_POS, tooltip="Prior pseudo-losses for Beta distribution.\n1.0 = uninformative Bayes-Laplace prior.\nHigher = more conservative (shrinks toward 0.5).")
INPUT_BAYES_CONFIDENCE  = input.float(0.95, '   â†³ Confidence Level', minval=0.80, maxval=0.99, step=0.01, group=GROUP_STAT_POS, tooltip="Confidence level for credible interval.\n0.95 = 95% confidence (5th percentile lower bound).\nHigher = more conservative estimate.")
INPUT_SORTINO_ENABLED   = input.bool(true, 'ğŸ“‰ Sortino Ratio', group=GROUP_STAT_POS, tooltip="Downside-risk adjusted performance metric.\nPenalizes losses/drawdowns without penalizing upside volatility.\nAligns with asymmetric payoff goals.")
INPUT_SORTINO_MAR       = input.float(0.0, '   â†³ Min Acceptable Return', minval=-0.10, maxval=0.10, step=0.01, group=GROUP_STAT_POS, tooltip="Minimum Acceptable Return (MAR) threshold.\nReturns below this are considered 'downside'.\n0.0 = break-even target.")
// --- MONTE CARLO PERMUTATION TEST ---
INPUT_MC_ENABLED        = input.bool(true, 'ğŸ² Monte Carlo Validation', group=GROUP_STAT_POS, tooltip="Permutation test to validate timing edge.\nShuffles trade sequence to test if drawdown control is real.\nRejects strategies that look good by chance.")
INPUT_MC_SIMS           = input.int(100, '   â†³ Simulations', minval=20, maxval=500, group=GROUP_STAT_POS, tooltip="Number of permutation simulations.\nMore = more accurate p-value, but slower.\n100 is a good balance.")
INPUT_MC_PVALUE         = input.float(0.05, '   â†³ p-value Threshold', minval=0.01, maxval=0.20, step=0.01, group=GROUP_STAT_POS, tooltip="Significance threshold.\np < 0.05 = 95% confidence timing edge is real.\nLower = stricter filter.")
// ------------------------------------------

// Fibonacci Levels
INPUT_SHOW_0            = input.bool(true, '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_VAL_0             = input.float(0., '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_COL_0             = input.color(color.new(COLOR_GRAY, TRANS_MAIN), '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_236        = input.bool(true, '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_236         = input.float(0.236, '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_COL_0_236         = input.color(color.new(COLOR_RED, TRANS_MAIN), '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_382        = input.bool(true, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_382         = input.float(0.382, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_COL_0_382         = input.color(color.new(COLOR_LIGHT_GREEN, TRANS_MAIN), '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_5          = input.bool(true, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_5           = input.float(0.5, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_COL_0_5           = input.color(color.new(COLOR_GREEN, TRANS_MAIN), '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_618        = input.bool(true, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_618         = input.float(0.618, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_COL_0_618         = input.color(color.new(COLOR_TEAL, TRANS_MAIN), '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_65         = input.bool(true, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_65          = input.float(0.65, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_COL_0_65          = input.color(color.new(COLOR_TEAL, TRANS_SUPP), '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_786        = input.bool(true, '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_786         = input.float(0.786, '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_COL_0_786         = input.color(color.new(COLOR_LIGHT_BLUE, TRANS_MAIN), '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1            = input.bool(true, '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_VAL_1             = input.float(1., '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_COL_1             = input.color(color.new(#787b86, 15), '', inline='Level3', group=GROUP_FIB_LEVELS) 
INPUT_SHOW_1_272        = input.bool(true, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_272         = input.float(1.272, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_COL_1_272         = input.color(color.new(COLOR_LIGHT_GREEN, TRANS_MAIN), '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1_414        = input.bool(false, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_414         = input.float(1.414, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_COL_1_414         = input.color(color.new(COLOR_RED, TRANS_SUPP), '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1_618        = input.bool(true, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_618         = input.float(1.618, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_COL_1_618         = input.color(color.new(COLOR_BLUE, TRANS_MAIN), '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1_65         = input.bool(false, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_65          = input.float(1.65, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_COL_1_65          = input.color(color.new(COLOR_BLUE, TRANS_SUPP), '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_SHOW_2_618        = input.bool(false, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_VAL_2_618         = input.float(2.618, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_COL_2_618         = input.color(color.new(COLOR_RED, TRANS_SUPP), '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_SHOW_2_65         = input.bool(true, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_VAL_2_65          = input.float(2.65, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_COL_2_65          = input.color(color.new(COLOR_RED, TRANS_SUPP), '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_SHOW_3_618        = input.bool(false, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_VAL_3_618         = input.float(3.618, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_COL_3_618         = input.color(color.new(COLOR_PURPLE, TRANS_SUPP), '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_SHOW_3_65         = input.bool(true, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_VAL_3_65          = input.float(3.65, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_COL_3_65          = input.color(color.new(COLOR_PURPLE, TRANS_SUPP), '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_SHOW_4_236        = input.bool(true, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_VAL_4_236         = input.float(4.236, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_COL_4_236         = input.color(color.new(COLOR_PINK, TRANS_SUPP), '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_SHOW_4_618        = input.bool(true, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_VAL_4_618         = input.float(4.669, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_COL_4_618         = input.color(color.new(COLOR_LIGHT_GREEN, TRANS_SUPP) , '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_236    = input.bool(true, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_236     = input.float(-0.236, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_236     = input.color(color.new(COLOR_RED, TRANS_SUPP), '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_382    = input.bool(true, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_382     = input.float(-0.382, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_382     = input.color(color.new(COLOR_LIGHT_GREEN, TRANS_SUPP), '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_618    = input.bool(false, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_618     = input.float(-0.618, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_618     = input.color(color.new(COLOR_TEAL, TRANS_SUPP), '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_65     = input.bool(true, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_65      = input.float(-0.65, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_65      = input.color(color.new(COLOR_TEAL, TRANS_SUPP), '', inline='Level10', group=GROUP_FIB_LEVELS)

// ZigZag
INPUT_SHOW_ZIGZAG       = input.bool(true, 'Zig Zagâ€‡â€‡', inline='ZZ', group=GROUP_ZIGZAG, tooltip=TOOLTIP_ZIGZAG)

// Alerts
INPUT_ALERT_ENABLED     = input.bool(false, 'Enable Alerts', group=GROUP_ALERTS)
INPUT_ALERT_MODE        = input.string('calculateAlertUpdates', 'Alert data collection mode', options=['calculateAlertData', 'calculateAlertUpdates'], group = GROUP_ALERTS)
INPUT_ALERT_SEPARATOR   = input.string('|', 'Alert data separator', group = GROUP_ALERTS)

// Volatility & Volume AddOns
INPUT_SHOW_HIGH_ATR     = input.bool(false, 'âš¡', inline='ATR', group=GROUP_VOL_VOL, tooltip=TOOLTIP_HIGH_VOL)
INPUT_ATR_LENGTH        = input.int(7, 'ATR : Length', inline='ATR', group=GROUP_VOL_VOL)
INPUT_ATR_MULT          = input.float(2.0, 'Mult', minval=.1, step=.1, inline='ATR', group=GROUP_VOL_VOL)
INPUT_VOL_SMA_LEN       = input.int(89, 'Volume Moving Average Length', group=GROUP_VOL_VOL)
INPUT_SHOW_VOL_SPIKE    = input.bool(false, 'ğŸš¦', inline='SRS1', group=GROUP_VOL_VOL, tooltip=TOOLTIP_VOL_EXHAUST)
INPUT_VOL_SPIKE_THRESH  = input.float(2.5, 'Volume Spike Thesholdâ€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡', minval=.1, step=.1, inline='SRS1', group=GROUP_VOL_VOL)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULATIONS & LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Data Structures - Level Log Maps (wrapped in LevelLog UDT after type definition)
var map<float, float> GLOBAL_pivotLevelsLogRetracementsMap = map.new<float, float>()
var map<float, float> GLOBAL_pivotLevelsLogCrossedMap = map.new<float, float>()

// @type LevelLog - Wraps a map for tracking Fibonacci level prices and crossings
// @description Stores price levels for each Fibonacci ratio and tracks which ones have been crossed.
//              Used for generating alert data.
// @field data Map storing level ratio -> price mappings
type LevelLog
    map<float, float> data

// @function Clear all entries from this LevelLog
// @param this LevelLog instance
// @returns LevelLog instance for chaining
method clear(LevelLog this) =>
    this.data.clear()
    this

// @function Update or add a level-price mapping
// @param this LevelLog instance
// @param level Fibonacci ratio (e.g., 0.618)
// @param value Price at that level
// @returns LevelLog instance for chaining
method put(LevelLog this, float level, float value) =>
    this.data.put(level, value)
    this

// @function Get price for a specific level
// @param this LevelLog instance
// @param level Fibonacci ratio to lookup
// @returns Price at that level, or na if not found
method get(LevelLog this, float level) =>
    this.data.get(level)

// NOTE: toJson method is defined after fibLevels array is available (see below FibLevel type)

// @type PivotContext - Encapsulates pivot coordinates for Fibonacci level calculations
// @description Holds the start and end prices of a swing for calculating Fibonacci retracement/extension levels.
// @field pMid Price of the mid pivot (swing point)
// @field pEnd Price of the end base (retracement target)
// @field reverse Whether to reverse the calculation direction
type PivotContext
    float pMid
    float pEnd
    bool reverse = false

// @function Calculate price at a given Fibonacci ratio
// @param this PivotContext instance
// @param ratio Fibonacci ratio (e.g., 0.618, 0.65, 1.272)
// @returns Price level at the specified ratio
method getLevel(PivotContext this, float ratio) =>
    float diff = math.abs(this.pMid - this.pEnd)
    float result = this.pEnd < this.pMid ? 
         (this.reverse ? this.pEnd : this.pMid) - (this.reverse ? -1 : 1) * diff * ratio : 
         (this.reverse ? this.pEnd : this.pMid) + (this.reverse ? -1 : 1) * diff * ratio
    result

// @type ZigZagEngine - Encapsulates ZigZag pivot detection and line drawing state
// @field ln The current ZigZag line being drawn
// @field iLast Bar index of last point
// @field pLast Price of last point
// @field isHighLast True if last pivot was a high
// @field iPrev Bar index of previous point (before iLast)
// @field iPrevPivot Bar index of the pivot before the current one (x1 of previous line)
// @field pPrevPivot Price of the pivot before the current one
// @field iLastPivot Bar index of the most recent confirmed pivot (x2 of previous line)
// @field pLastPivot Price of the most recent confirmed pivot
// @field changed True if a new pivot was confirmed this bar (reset each bar)
type ZigZagEngine
    line ln = na
    int iLast = 0
    float pLast = 0.0
    bool isHighLast = false
    int iPrev = 0
    int iPrevPivot = 0
    float pPrevPivot = 0.0
    int iLastPivot = 0
    float pLastPivot = 0.0
    bool changed = false

// @function Reset the changed flag at the start of each bar
// @param this ZigZagEngine instance
// @returns ZigZagEngine instance for chaining
method resetChanged(ZigZagEngine this) =>
    this.changed := false
    this

// @function Check if a pivot change occurred this bar
// @param this ZigZagEngine instance
// @returns True if pivot changed this bar
method wasChanged(ZigZagEngine this) =>
    this.changed

// @function Calculate deviation between two prices
// @param base_price Base price for deviation calculation
// @param price Current price to compare
// @returns Deviation as percentage
f_calcDev(float base_price, float price) =>
    100 * (price - base_price) / price

// @function Process a potential pivot and update ZigZag line
// @param this ZigZagEngine instance
// @param dev Deviation from last point
// @param isHigh True if this is a high pivot candidate
// @param index Bar index of the pivot
// @param price Price of the pivot
// @param dev_threshold Deviation threshold for confirming new pivots
// @param zz_color Color for ZigZag lines
// @param show_zigzag Whether to display the ZigZag lines
// @returns True if a NEW line segment was created (not just extended)
method processPivot(ZigZagEngine this, float dev, bool isHigh, int index, float price, float dev_threshold, color zz_color, bool show_zigzag) =>
    bool newSegment = false
    
    if this.isHighLast == isHigh and not na(this.ln)
        // Same direction - check if we should extend the existing line
        if this.isHighLast ? price > this.pLast : price < this.pLast
            line.set_xy2(this.ln, index, price)
            // Update tracking vars
            this.iPrev := this.iLast
            this.iLast := index
            this.pLast := price
    else
        // Different direction or no existing line
        if na(this.ln)
            // First line ever
            line newLine = line.new(this.iLast, this.pLast, index, price, color=zz_color, width=2, style=line.style_solid)
            this.ln := newLine
            this.isHighLast := isHigh
            this.iPrev := this.iLast
            this.iLast := index
            this.pLast := price
            newSegment := true
        else if math.abs(dev) > dev_threshold
            // Deviation threshold met - create new line segment
            // First, capture the previous line's coordinates for caching
            this.iPrevPivot := line.get_x1(this.ln)
            this.pPrevPivot := line.get_y1(this.ln)
            this.iLastPivot := line.get_x2(this.ln)
            this.pLastPivot := line.get_y2(this.ln)
            
            // Delete old line if ZigZag display is disabled
            if not show_zigzag
                line.delete(this.ln)
            
            // Create new line
            line newLine = line.new(this.iLast, this.pLast, index, price, color=zz_color, width=2, style=line.style_solid)
            this.ln := newLine
            this.isHighLast := isHigh
            this.iPrev := this.iLast
            this.iLast := index
            this.pLast := price
            this.changed := true
            newSegment := true
    
    newSegment

// @function Initialize the ZigZag with the first pivot point (no line yet)
// @param this ZigZagEngine instance
// @param index Bar index of first point
// @param price Price of first point
// @param isHigh True if first point is a high
// @returns ZigZagEngine instance for chaining
method initFirst(ZigZagEngine this, int index, float price, bool isHigh) =>
    this.iLast := index
    this.pLast := price
    this.isHighLast := isHigh
    this

// @type RegimeState - Consolidates all regime detection state
// @description Computed-per-bar market regime indicators including entropy, Hurst, momentum, and volatility.
// @field logReturn Single-bar logarithmic return
// @field logReturnStdev Rolling stdev of log returns
// @field periodsPerYear Annualization factor for current timeframe
// @field annualizedVol Annualized volatility from log returns
// @field entropy Raw Shannon entropy value
// @field entropyNorm Normalized entropy (0-1)
// @field entropyRegime Regime classification (0=ordered, 1=transition, 2=disordered)
// @field entropyOk True if entropy regime allows trading
// @field hurst Hurst exponent value
// @field hurstRegime Regime classification (0=trend, 1=random, 2=meanrev)
// @field hurstOk True if Hurst regime allows trading
// @field zscoreAtr ATR used for slope normalization
// @field linregSlope Linear regression slope
// @field normSlope ATR-normalized slope
// @field zscore Z-score of normalized slope
// @field strongMomentum True if momentum exceeds threshold
// @field momentumOk True if momentum filter allows trading
// @field rawAtr Raw ATR without multiplier
// @field atrPercentile ATR percentile rank (0-100)
// @field rsi RSI value for divergence detection
type RegimeState
    float logReturn = na
    float logReturnStdev = na
    float periodsPerYear = na
    float annualizedVol = na
    float entropy = na
    float entropyNorm = na
    int   entropyRegime = 2
    bool  entropyOk = true
    float hurst = na
    int   hurstRegime = 1
    bool  hurstOk = true
    float zscoreAtr = na
    float linregSlope = na
    float normSlope = na
    float zscore = na
    bool  strongMomentum = false
    bool  momentumOk = true
    float rawAtr = na
    float atrPercentile = na
    float rsi = na

// @type LearningMetrics - Encapsulates all machine learning computed values
// @description Consolidates learning state and metrics into a single UDT.
//              Updated only when new trade is recorded (needsRecalc flag).
//              Provides accessor methods for key metrics and health status.
// @field zoneBuffer Adaptive zone buffer from near-miss analysis
// @field winRate Overall empirical win rate
// @field slMult Optimal SL multiplier from MAE analysis
// @field avgMae Average MAE of winning trades (ATR units)
// @field avgMfe Average MFE before outcome (ATR units)
// @field avgBars Average bars to outcome
// @field wrWithDiv Win rate when RSI divergence present
// @field wrWithoutDiv Win rate when no RSI divergence
// @field divEdge Edge from RSI divergence (wrWithDiv - wrWithoutDiv)
// @field rsiWeight Weight for RSI in Kelly (0=ignore, 1=full)
// @field wrLong Win rate for LONG setups
// @field wrShort Win rate for SHORT setups
// @field losingMae Average MAE of losing trades
// @field optimalHold Optimal holding period (bars)
// @field decayRate Time decay rate per threshold
// @field tpAggressive Should use aggressive TP mode?
// @field consWr Win rate for conservative TP
// @field aggrWr Win rate for aggressive TP
// @field consEv Expected value for conservative TP
// @field aggrEv Expected value for aggressive TP
// @field confidence Unified confidence score (0-100)
// @field profitFactor Total R won / Total R lost
// @field expectancy Average R per trade
// @field winStreak Current winning streak
// @field lossStreak Current losing streak
// @field wrHighVol Win rate in high volatility
// @field wrLowVol Win rate in low volatility
// @field cumLogReturn Cumulative log return of all trades
// @field avgLogReturn Average log return per trade
// @field logReturnStdev Standard deviation of trade log returns
// @field sharpeRatio Risk-adjusted return (avgLogReturn / logReturnStdev)
// @field bayesAlpha Posterior alpha for Beta distribution (prior + wins)
// @field bayesBeta Posterior beta for Beta distribution (prior + losses)
// @field bayesMean Posterior mean E[Î¸] = Î± / (Î± + Î²)
// @field bayesLowerBound Conservative lower credible bound (sample-size penalized)
// @field sortinoRatio Downside-risk adjusted return (Rp - Rf) / Ïƒ_down
// @field downsideDev Downside deviation (volatility of losses only)
// @field meanTradeReturn Mean trade log return
// @field mcOriginalDD Original max drawdown from actual trade sequence
// @field mcMeanShuffledDD Mean max drawdown from shuffled permutations
// @field mcPValue p-value (fraction of shuffles with lower drawdown)
// @field mcSimsRun Number of Monte Carlo simulations completed
// @field mcSignificant True if timing edge is statistically significant
// @field lastOutcomeBar Bar index of last outcome
// @field isHealthy Learning system health status
// @field nearMissCount Count of near-miss setups (approached but didn't touch zone)
// @field totalSetups Total valid setups analyzed
// @field needsRecalc Flag to trigger learning recalculation
type LearningMetrics
    // Core metrics
    float zoneBuffer = 0.0
    float winRate = 0.55
    float slMult = 1.5
    float avgMae = 0.0
    float avgMfe = 0.0
    int   avgBars = 0
    // RSI divergence analytics
    float wrWithDiv = 0.55
    float wrWithoutDiv = 0.5
    float divEdge = 0.0
    float rsiWeight = 0.0
    // Direction-specific win rates
    float wrLong = 0.55
    float wrShort = 0.55
    // Loss analysis
    float losingMae = 0.0
    // Time-based
    int   optimalHold = 0
    float decayRate = 0.03
    // TP mode comparison
    bool  tpAggressive = false
    float consWr = 0.0
    float aggrWr = 0.0
    float consEv = 0.0
    float aggrEv = 0.0
    // Performance metrics
    float confidence = 50.0
    float profitFactor = 1.0
    float expectancy = 0.0
    int   winStreak = 0
    int   lossStreak = 0
    // Volatility regime
    float wrHighVol = 0.55
    float wrLowVol = 0.55
    // Entropy regime analytics
    float wrOrdered = 0.55
    float wrDisordered = 0.55
    float entropyEdge = 0.0
    // Hurst regime analytics
    float wrTrend = 0.55
    float wrMeanRev = 0.55
    float wrRandom = 0.55
    float hurstEdge = 0.0
    // Z-score momentum analytics
    float wrStrongMom = 0.55
    float wrWeakMom = 0.55
    float momentumEdge = 0.0
    // Log-return performance metrics
    float cumLogReturn = 0.0
    float avgLogReturn = 0.0
    float logReturnStdev = 0.0
    float sharpeRatio = 0.0
    // Bayesian win-rate estimation (Beta-Binomial model)
    float bayesAlpha = 1.0         // Posterior alpha (prior + wins)
    float bayesBeta = 1.0          // Posterior beta (prior + losses)
    float bayesMean = 0.5          // Posterior mean E[Î¸] = Î± / (Î± + Î²)
    float bayesLowerBound = 0.0    // Conservative lower credible bound
    // Sortino ratio (downside-risk adjusted)
    float sortinoRatio = 0.0       // (Rp - Rf) / Ïƒ_down
    float downsideDev = 0.0        // Downside deviation (Ïƒ_down)
    float meanTradeReturn = 0.0    // Mean trade log return
    // Monte Carlo permutation test
    float mcOriginalDD = 0.0       // Original max drawdown
    float mcMeanShuffledDD = 0.0   // Mean of shuffled max drawdowns
    float mcPValue = 1.0           // p-value (fraction of shuffles with lower DD)
    int   mcSimsRun = 0            // Number of simulations completed
    bool  mcSignificant = false    // True if timing edge is statistically significant
    // Health tracking
    int   lastOutcomeBar = 0
    bool  isHealthy = true
    // State tracking (consolidated from orphan var primitives)
    int   nearMissCount = 0
    int   totalSetups = 0
    bool  needsRecalc = false

// @function Get win rate for specific direction
// @param this LearningMetrics instance
// @param isLong True for long direction, false for short
// @returns Direction-specific win rate
method getWinRate(LearningMetrics this, bool isLong) =>
    isLong ? this.wrLong : this.wrShort

// @function Get win rate for specific volatility regime
// @param this LearningMetrics instance
// @param isHighVol True for high volatility regime
// @returns Regime-specific win rate
method getRegimeWinRate(LearningMetrics this, bool isHighVol) =>
    isHighVol ? this.wrHighVol : this.wrLowVol

// @function Get optimal SL multiplier
// @param this LearningMetrics instance
// @returns Learned SL multiplier
method getSlMult(LearningMetrics this) =>
    this.slMult

// @function Get time decay rate
// @param this LearningMetrics instance
// @returns Learned decay rate
method getDecayRate(LearningMetrics this) =>
    this.decayRate

// @function Get confidence score
// @param this LearningMetrics instance
// @returns Confidence score 0-100
method getConfidence(LearningMetrics this) =>
    this.confidence

// @function Check if learning system is healthy
// @param this LearningMetrics instance
// @returns True if system is healthy
method checkHealth(LearningMetrics this) =>
    this.isHealthy

// @function Check if RSI divergence provides meaningful edge
// @param this LearningMetrics instance
// @returns True if divergence edge > 0
method hasDivergenceEdge(LearningMetrics this) =>
    this.divEdge > 0

// @type PositionVisual - Manages all visual elements for the position display
// @description Encapsulates box, lines, and label for the Golden Pocket setup visualization.
//              Handles create/update/delete lifecycle and projection vs confirmed styling.
// @field boxEntry Entry zone box
// @field lineSl Stop loss line
// @field lineSmartSl Smart SL line (backtest optimized)
// @field lineTp Take profit line
// @field lblRisk Position info label
type PositionVisual
    box boxEntry = na
    line lineSl = na
    line lineSmartSl = na
    line lineTp = na
    label lblRisk = na

// @function Delete all visual elements
// @param this PositionVisual instance
// @returns PositionVisual instance for chaining
method deleteAll(PositionVisual this) =>
    if not na(this.boxEntry)
        box.delete(this.boxEntry)
        this.boxEntry := na
    if not na(this.lineSl)
        line.delete(this.lineSl)
        this.lineSl := na
    if not na(this.lineSmartSl)
        line.delete(this.lineSmartSl)
        this.lineSmartSl := na
    if not na(this.lineTp)
        line.delete(this.lineTp)
        this.lineTp := na
    if not na(this.lblRisk)
        label.delete(this.lblRisk)
        this.lblRisk := na
    this

// @function Check if visuals exist
// @param this PositionVisual instance
// @returns True if any visual elements exist
method exists(PositionVisual this) =>
    not na(this.boxEntry)

// @function Create all visual elements with specified parameters
// @param this PositionVisual instance
// @param zoneTop Top of entry zone
// @param zoneBottom Bottom of entry zone
// @param slPrice Stop loss price
// @param tpPrice Take profit price
// @param labelPrice Y position for label
// @param labelText Text for position label
// @param bgCol Background color for box
// @param borderCol Border color for box
// @param slCol Stop loss line color
// @param tpCol Take profit line color
// @param lineStyle Line style (solid for confirmed, dotted for projection)
// @param smartSlPrice Smart SL price (na if not available)
// @param smartSlCol Smart SL line color
// @returns PositionVisual instance for chaining
method create(PositionVisual this, float zoneTop, float zoneBottom, float slPrice, float tpPrice, float labelPrice, string labelText, color bgCol, color borderCol, color slCol, color tpCol, string lineStyle, float smartSlPrice, color smartSlCol, color textCol) =>
    this.boxEntry := box.new(bar_index, zoneTop, bar_index + 5, zoneBottom, bgcolor=bgCol, border_color=borderCol, border_style=lineStyle == "solid" ? line.style_solid : line.style_dotted)
    this.lineSl := line.new(bar_index, slPrice, bar_index + 5, slPrice, color=slCol, style=lineStyle == "solid" ? line.style_solid : line.style_dotted, width=2)
    if not na(smartSlPrice)
        this.lineSmartSl := line.new(bar_index, smartSlPrice, bar_index + 5, smartSlPrice, color=smartSlCol, style=line.style_dotted, width=3)
    this.lineTp := line.new(bar_index, tpPrice, bar_index + 5, tpPrice, color=tpCol, style=lineStyle == "solid" ? line.style_solid : line.style_dotted, width=3)
    this.lblRisk := label.new(bar_index + 5, labelPrice, labelText, xloc.bar_index, yloc.price, color.new(textCol, 100), label.style_label_left, color.new(textCol, 0), size.small, text.align_left)
    this

// @function Update existing visual elements with new values
// @param this PositionVisual instance
// @param zoneTop Top of entry zone
// @param zoneBottom Bottom of entry zone
// @param slPrice Stop loss price
// @param tpPrice Take profit price
// @param labelPrice Y position for label
// @param labelText Text for position label
// @param bgCol Background color for box
// @param borderCol Border color for box
// @param slCol Stop loss line color
// @param tpCol Take profit line color
// @param smartSlPrice Smart SL price (na if not available)
// @param smartSlCol Smart SL line color
// @returns PositionVisual instance for chaining
method update(PositionVisual this, float zoneTop, float zoneBottom, float slPrice, float tpPrice, float labelPrice, string labelText, color bgCol, color borderCol, color slCol, color tpCol, float smartSlPrice, color smartSlCol) =>
    // Update box
    box.set_top(this.boxEntry, zoneTop)
    box.set_bottom(this.boxEntry, zoneBottom)
    box.set_right(this.boxEntry, bar_index + 5)
    box.set_bgcolor(this.boxEntry, bgCol)
    box.set_border_color(this.boxEntry, borderCol)
    // Update SL line
    line.set_x2(this.lineSl, bar_index + 5)
    line.set_y1(this.lineSl, slPrice)
    line.set_y2(this.lineSl, slPrice)
    line.set_color(this.lineSl, slCol)
    // Update Smart SL line (if available)
    if not na(smartSlPrice) and not na(this.lineSmartSl)
        line.set_x2(this.lineSmartSl, bar_index + 5)
        line.set_y1(this.lineSmartSl, smartSlPrice)
        line.set_y2(this.lineSmartSl, smartSlPrice)
    else if not na(smartSlPrice) and na(this.lineSmartSl)
        this.lineSmartSl := line.new(bar_index, smartSlPrice, bar_index + 5, smartSlPrice, color=smartSlCol, style=line.style_dotted, width=2)
    // Update TP line
    line.set_x2(this.lineTp, bar_index + 5)
    line.set_y1(this.lineTp, tpPrice)
    line.set_y2(this.lineTp, tpPrice)
    line.set_color(this.lineTp, tpCol)
    // Update label
    label.set_x(this.lblRisk, bar_index + 5)
    label.set_y(this.lblRisk, labelPrice)
    label.set_text(this.lblRisk, labelText)
    this

// @type ProjectionState - Manages projection mode state and tentative pivot detection
// @description Encapsulates local extreme tracking, tentative pivot detection, and projection pivot values.
//              Provides methods for updating state and checking projection activity.
// @field localHigh Local high since last confirmed pivot
// @field localHighBar Bar index of local high
// @field localLow Local low since last confirmed pivot
// @field localLowBar Bar index of local low
// @field isHighLast Was last confirmed pivot a high?
// @field iMidPivot Projection mid pivot bar index
// @field pMidPivot Projection mid pivot price
// @field iEndBase Projection end base bar index
// @field pEndBase Projection end base price
// @field active Is projection currently active?
type ProjectionState
    float localHigh = na
    int localHighBar = na
    float localLow = na
    int localLowBar = na
    bool isHighLast = true
    int iMidPivot = na
    float pMidPivot = na
    int iEndBase = na
    float pEndBase = na
    bool active = false

// @function Reset local extreme tracking on confirmed pivot
// @param this ProjectionState instance
// @param currentHigh Current bar high
// @param currentLow Current bar low
// @param wasHigh Whether the confirmed pivot was a high
// @returns ProjectionState instance for chaining
method resetLocals(ProjectionState this, float currentHigh, float currentLow, bool wasHigh) =>
    this.localHigh := currentHigh
    this.localHighBar := bar_index
    this.localLow := currentLow
    this.localLowBar := bar_index
    this.isHighLast := wasHigh
    this

// @function Update local extremes on each bar
// @param this ProjectionState instance
// @param currentHigh Current bar high
// @param currentLow Current bar low
// @returns ProjectionState instance for chaining
method updateLocals(ProjectionState this, float currentHigh, float currentLow) =>
    if currentHigh > nz(this.localHigh, currentHigh)
        this.localHigh := currentHigh
        this.localHighBar := bar_index
    if currentLow < nz(this.localLow, currentLow)
        this.localLow := currentLow
        this.localLowBar := bar_index
    this

// @function Check if tentative HIGH pivot detected
// @param this ProjectionState instance
// @param closePrice Current close price
// @param threshold Deviation threshold
// @returns True if tentative high pivot detected
method detectTentativeHigh(ProjectionState this, float closePrice, float threshold) =>
    float devFromHigh = this.localHigh > 0 ? 100 * (this.localHigh - closePrice) / this.localHigh : 0
    devFromHigh > threshold and not this.isHighLast

// @function Check if tentative LOW pivot detected
// @param this ProjectionState instance
// @param closePrice Current close price
// @param threshold Deviation threshold
// @returns True if tentative low pivot detected
method detectTentativeLow(ProjectionState this, float closePrice, float threshold) =>
    float devFromLow = this.localLow > 0 ? 100 * (closePrice - this.localLow) / this.localLow : 0
    devFromLow > threshold and this.isHighLast

// @function Activate projection with tentative pivot values
// @param this ProjectionState instance
// @param isHigh Whether tentative pivot is a high
// @param currentExtreme Current bar extreme (low if high pivot, high if low pivot)
// @returns ProjectionState instance for chaining
method activate(ProjectionState this, bool isHigh, float currentExtreme) =>
    this.iMidPivot := isHigh ? this.localHighBar : this.localLowBar
    this.pMidPivot := isHigh ? this.localHigh : this.localLow
    this.iEndBase := bar_index
    this.pEndBase := currentExtreme
    this.active := true
    this

// @function Deactivate projection (confirmed pivot overrides)
// @param this ProjectionState instance
// @returns ProjectionState instance for chaining
method deactivate(ProjectionState this) =>
    this.active := false
    this

// @function Check if projection is currently active
// @param this ProjectionState instance
// @returns True if projection mode is active
method isActive(ProjectionState this) =>
    this.active

// Global projection state instance
var ProjectionState GLOBAL_projection = ProjectionState.new()

// @type FibLevel - Represents a single Fibonacci level configuration and state
// @field level The Fibonacci ratio (e.g., 0.618)
// @field col Color for the level line/label
// @field show Whether to display this level
// @field ln The line object for this level
// @field lb The label object for this level
// @field crossed Pre-computed crossing flag (Pine v6 best practice)
type FibLevel
    float level
    color col
    bool show
    line ln = na
    label lb = na
    bool crossed = false

var array<FibLevel> fibLevels = array.new<FibLevel>()
if barstate.isfirst
    fibLevels.push(FibLevel.new(INPUT_VAL_0, INPUT_COL_0, INPUT_SHOW_0))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_236, INPUT_COL_0_236, INPUT_SHOW_0_236))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_382, INPUT_COL_0_382, INPUT_SHOW_0_382))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_5, INPUT_COL_0_5, INPUT_SHOW_0_5))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_618, INPUT_COL_0_618, INPUT_SHOW_0_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_65, INPUT_COL_0_65, INPUT_SHOW_0_65))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_786, INPUT_COL_0_786, INPUT_SHOW_0_786))
    fibLevels.push(FibLevel.new(INPUT_VAL_1, INPUT_COL_1, INPUT_SHOW_1))
    fibLevels.push(FibLevel.new(INPUT_VAL_1_272, INPUT_COL_1_272, INPUT_SHOW_1_272))
    fibLevels.push(FibLevel.new(INPUT_VAL_1_414, INPUT_COL_1_414, INPUT_SHOW_1_414))
    fibLevels.push(FibLevel.new(INPUT_VAL_1_618, INPUT_COL_1_618, INPUT_SHOW_1_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_1_65, INPUT_COL_1_65, INPUT_SHOW_1_65))
    fibLevels.push(FibLevel.new(INPUT_VAL_2_618, INPUT_COL_2_618, INPUT_SHOW_2_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_2_65, INPUT_COL_2_65, INPUT_SHOW_2_65))
    fibLevels.push(FibLevel.new(INPUT_VAL_3_618, INPUT_COL_3_618, INPUT_SHOW_3_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_3_65, INPUT_COL_3_65, INPUT_SHOW_3_65))
    fibLevels.push(FibLevel.new(INPUT_VAL_4_236, INPUT_COL_4_236, INPUT_SHOW_4_236))
    fibLevels.push(FibLevel.new(INPUT_VAL_4_618, INPUT_COL_4_618, INPUT_SHOW_4_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_236, INPUT_COL_NEG_0_236, INPUT_SHOW_NEG_0_236))
    fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_382, INPUT_COL_NEG_0_382, INPUT_SHOW_NEG_0_382))
    fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_618, INPUT_COL_NEG_0_618, INPUT_SHOW_NEG_0_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_65, INPUT_COL_NEG_0_65, INPUT_SHOW_NEG_0_65))

// @function Convert LevelLog to JSON string (uses fibLevels for key names)
// @param this LevelLog instance
// @returns JSON string representation of the log
method toJson(LevelLog this) =>
    string result = '{'
    int levelCount = array.size(fibLevels)
    for i = 0 to levelCount - 1
        FibLevel lvl = array.get(fibLevels, i)
        float val = this.data.get(lvl.level)
        string levelKey = str.replace(str.tostring(lvl.level), '.', '_')
        if na(val)
            result := result + '"' + levelKey + '":null'
        else
            result := result + '"' + levelKey + '":' + str.tostring(val)
        if i < levelCount - 1
            result := result + ','
    result + '}'

// Create LevelLog instances wrapping the raw maps
var LevelLog GLOBAL_pivotLevelsLogRetracements = LevelLog.new(GLOBAL_pivotLevelsLogRetracementsMap)
var LevelLog GLOBAL_pivotLevelsLogCrossed = LevelLog.new(GLOBAL_pivotLevelsLogCrossedMap)

int decimalsCount = math.round(math.abs(math.log(1 / syminfo.mintick) / math.log(10)))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTRABAR DATA REQUEST - Lower Timeframe Arrays for Chronological TP/SL Resolution
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTE: request.security_lower_tf MUST be called at global scope (not inside conditionals)

array<float> GLOBAL_ltfHighs = request.security_lower_tf(syminfo.tickerid, INPUT_INTRABAR_TF, high)
array<float> GLOBAL_ltfLows  = request.security_lower_tf(syminfo.tickerid, INPUT_INTRABAR_TF, low)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEARNING ENGINE DATA STRUCTURES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @type SetupRecord - Tracks outcome of each Golden Pocket setup for backtesting learning
// @field setup_bar Bar index when setup formed
// @field state_mask Bitwise flags for boolean states (see FLAG_* constants)
// @field zone_top Golden Pocket upper boundary
// @field zone_bottom Golden Pocket lower boundary
// @field sl_level Stop loss price
// @field tp_level Take profit price
// @field closest_approach Closest distance to zone (% of zone width)
// @field bars_to_outcome Bars from setup to SL/TP hit (0 if neither)
// @field max_adverse Maximum Adverse Excursion (ATR multiple)
// @field max_favorable Maximum Favorable Excursion (ATR multiple)
// @field entry_price Price when zone was first touched
// @field atr_at_setup ATR value when setup formed
// @field rsi_at_entry RSI when zone was touched
// @field tp_conservative Conservative TP price (Pivot End)
// @field tp_aggressive Aggressive TP price (1.272 Extension)
// @field vol_percentile ATR percentile at setup (0-100)
// NOTE: Must be declared before CircularBufferSetupRecord which references it
// @type SetupRecord - Compact storage for historical setup data
// @description Used in CircularBuffer for machine learning. Stores outcome and context of past trades.
// @field setup_bar Bar index of the setup pivot
// @field state_mask Bitwise flags for setup state (won/lost, long/short, etc.)
// @field zone_top Upper boundary of entry zone
// @field zone_bottom Lower boundary of entry zone
// @field sl_level Stop loss price level
// @field tp_level Take profit price level
// @field closest_approach Closest distance to zone before outcome (for near-miss analysis)
// @field bars_to_outcome Duration of trade in bars
// @field max_adverse Maximum adverse excursion (drawdown)
// @field max_favorable Maximum favorable excursion (profit)
// @field entry_price Price at entry
// @field atr_at_setup Volatility at setup time
// @field rsi_at_entry Momentum at entry time
// @field tp_conservative Conservative TP target price
// @field tp_aggressive Aggressive TP target price
// @field vol_percentile Volatility percentile rank (0-100)
// @field entropy_regime Entropy regime at setup (ORDERED=0, TRANSITION=1, DISORDERED=2)
// @field entropy_norm Normalized Shannon entropy at setup (0-1)
// @field hurst_regime Hurst regime at setup (TREND=0, RANDOM=1, MEANREV=2)
// @field hurst_value Hurst exponent at setup (0-1)
// @field zscore_value Z-score of momentum at setup
// @field strong_momentum Whether momentum was statistically significant at setup
// @field log_return Log return of the trade (positive for wins, negative for losses)
type SetupRecord
    int    setup_bar
    int    state_mask = 0
    float  zone_top
    float  zone_bottom
    float  sl_level
    float  tp_level
    float  closest_approach
    int    bars_to_outcome
    float  max_adverse
    float  max_favorable
    float  entry_price
    float  atr_at_setup
    float  rsi_at_entry
    float  tp_conservative
    float  tp_aggressive
    float  vol_percentile
    int    entropy_regime = 0
    float  entropy_norm = 0.0
    int    hurst_regime = 1
    float  hurst_value = 0.5
    float  zscore_value = 0.0
    bool   strong_momentum = false
    float  log_return = 0.0

// @function Check if a specific flag is set in this SetupRecord's state_mask
// @param this SetupRecord instance
// @param flag Flag to check (power-of-2 constant)
// @returns True if flag is set
method hasFlag(SetupRecord this, int flag) =>
    math.floor(this.state_mask / flag) % 2 == 1

// @function Set a flag in this SetupRecord's state_mask (idempotent)
// @param this SetupRecord instance
// @param flag Flag to set (power-of-2 constant)
// @returns SetupRecord instance for chaining
method setFlag(SetupRecord this, int flag) =>
    if not this.hasFlag(flag)
        this.state_mask += flag
    this

// @function Clear a flag from this SetupRecord's state_mask (idempotent)
// @param this SetupRecord instance
// @param flag Flag to clear (power-of-2 constant)
// @returns SetupRecord instance for chaining
method clearFlag(SetupRecord this, int flag) =>
    if this.hasFlag(flag)
        this.state_mask -= flag
    this

// @function Check if ANY of the flags in a composite mask are set
// @param this SetupRecord instance
// @param mask Composite mask (sum of multiple power-of-2 flags)
// @returns True if at least one flag in mask is set
method hasAny(SetupRecord this, int mask) =>
    bool result = false
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if this.hasFlag(testBit)
                result := true
                break
        testBit := testBit * 2
    result

// @function Check if ALL flags in a composite mask are set
// @param this SetupRecord instance
// @param mask Composite mask (sum of multiple power-of-2 flags)
// @returns True if all flags in mask are set
method hasAll(SetupRecord this, int mask) =>
    bool result = true
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if not this.hasFlag(testBit)
                result := false
                break
        testBit := testBit * 2
    result

// @function Set lifecycle phase with mutual exclusion
// @param this SetupRecord instance
// @param phase Lifecycle flag (FLAG_PENDING, FLAG_ACTIVE, or FLAG_CLOSED)
// @returns SetupRecord instance for chaining
method setLifecycle(SetupRecord this, int phase) =>
    this.clearFlag(FLAG_PENDING).clearFlag(FLAG_ACTIVE).clearFlag(FLAG_CLOSED).setFlag(phase)

// @function Set outcome with mutual exclusion (SL_HIT xor TP_HIT)
// @param this SetupRecord instance
// @param outcome Outcome flag (FLAG_SL_HIT or FLAG_TP_HIT)
// @returns SetupRecord instance for chaining
method setOutcome(SetupRecord this, int outcome) =>
    this.clearFlag(FLAG_SL_HIT).clearFlag(FLAG_TP_HIT).setFlag(outcome)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CIRCULAR BUFFER - O(1) Fixed-Size Ring Buffer for Historical Data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// @type CircularBufferSetupRecord - Fixed-size ring buffer with O(1) operations
// @description Efficiently stores historical SetupRecord instances for machine learning analysis.
//              Overwrites oldest entries when capacity is reached.
// @field data Preallocated array of SetupRecord (size = capacity)
// @field head Index of next write position (0 to capacity-1)
// @field count Number of valid entries (0 to capacity)
// @field capacity Maximum buffer size (fixed at initialization)
type CircularBufferSetupRecord
    array<SetupRecord> data
    int head = 0
    int count = 0
    int capacity = 50

// @function Initialize a CircularBuffer with preallocated capacity
// @param this CircularBuffer instance
// @param _capacity Maximum number of elements to store
// @returns Initialized CircularBuffer
method init(CircularBufferSetupRecord this, int _capacity) =>
    this.capacity := _capacity
    this.head := 0
    this.count := 0
    this.data := array.new<SetupRecord>(_capacity)
    this

// @function Push a new value into the buffer (overwrites oldest when full)
// @param this CircularBuffer instance
// @param value SetupRecord to push
// @returns The CircularBuffer instance (for chaining)
method push(CircularBufferSetupRecord this, SetupRecord value) =>
    array.set(this.data, this.head, value)
    this.head := (this.head + 1) % this.capacity
    this.count := math.min(this.count + 1, this.capacity)
    this

// @function Get value at lookback index (0 = newest, count-1 = oldest valid)
// @param this CircularBuffer instance
// @param lookback Lookback index (0 = most recent push)
// @returns SetupRecord at that position, or na if out of bounds
method get(CircularBufferSetupRecord this, int lookback) =>
    if lookback < 0 or lookback >= this.count
        na
    else
        int physicalIndex = (this.head - 1 - lookback + this.capacity) % this.capacity
        array.get(this.data, physicalIndex)

// @function Get the number of valid entries in the buffer
// @param this CircularBuffer instance
// @returns Number of entries (0 to capacity)
method size(CircularBufferSetupRecord this) =>
    this.count

// @function Check if buffer has any valid entries
// @param this CircularBuffer instance
// @returns True if count > 0
method isEmpty(CircularBufferSetupRecord this) =>
    this.count == 0

// @function Check if buffer is at capacity
// @param this CircularBuffer instance
// @returns True if count == capacity
method isFull(CircularBufferSetupRecord this) =>
    this.count == this.capacity

var CircularBufferSetupRecord GLOBAL_setupHistory = CircularBufferSetupRecord.new()

if barstate.isfirst
    GLOBAL_setupHistory.init(INPUT_LEARNING_SAMPLES)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKTESTING ENGINE - Trade Mining System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @type BacktestTrade - Represents a single simulated trade position
// @description Stores all data for a single backtested trade, including entry/exit points,
//              outcome flags, and performance metrics (MAE/MFE).
// @field id Pivot Bar Index (unique identifier)
// @field state_mask Bitwise flags: FLAG_IS_LONG for direction, FLAG_PENDING/ACTIVE/CLOSED for lifecycle, FLAG_WON for outcome
//                   NOTE: Must be initialized via BacktestTrade.new() with proper flags (see lines ~1470-1485)
// @field entry_price Calculated Golden Pocket entry level (mid of zone)
// @field entry_top Golden Pocket upper boundary
// @field entry_btm Golden Pocket lower boundary
// @field sl_price Initial Stop Loss price
// @field tp_price Initial Take Profit price
// @field mae Max Adverse Excursion (worst drawdown from entry, in price)
// @field mfe Max Favorable Excursion (best unrealized profit from entry, in price)
// @field entry_bar Bar index when position became Active
// @field exit_bar Bar index when position was Closed
type BacktestTrade
    int    id
    int    state_mask  // No default - must be initialized with proper flags
    float  entry_price
    float  entry_top
    float  entry_btm
    float  sl_price
    float  tp_price
    float  mae
    float  mfe
    int    entry_bar
    int    exit_bar

// @function Check if a specific flag is set in this BacktestTrade's state_mask
// @param this BacktestTrade instance
// @param flag Flag to check (power-of-2 constant)
// @returns True if flag is set
method hasFlag(BacktestTrade this, int flag) =>
    math.floor(this.state_mask / flag) % 2 == 1

// @function Set a flag in this BacktestTrade's state_mask (idempotent)
// @param this BacktestTrade instance
// @param flag Flag to set (power-of-2 constant)
// @returns BacktestTrade instance for chaining
method setFlag(BacktestTrade this, int flag) =>
    if not this.hasFlag(flag)
        this.state_mask += flag
    this

// @function Clear a flag from this BacktestTrade's state_mask (idempotent)
// @param this BacktestTrade instance
// @param flag Flag to clear (power-of-2 constant)
// @returns BacktestTrade instance for chaining
method clearFlag(BacktestTrade this, int flag) =>
    if this.hasFlag(flag)
        this.state_mask -= flag
    this

// @function Check if ANY of the flags in a composite mask are set
// @param this BacktestTrade instance
// @param mask Composite mask (sum of multiple power-of-2 flags)
// @returns True if at least one flag in mask is set
method hasAny(BacktestTrade this, int mask) =>
    bool result = false
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if this.hasFlag(testBit)
                result := true
                break
        testBit := testBit * 2
    result

// @function Check if ALL flags in a composite mask are set
// @param this BacktestTrade instance
// @param mask Composite mask (sum of multiple power-of-2 flags)
// @returns True if all flags in mask are set
method hasAll(BacktestTrade this, int mask) =>
    bool result = true
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if not this.hasFlag(testBit)
                result := false
                break
        testBit := testBit * 2
    result

// @function Set lifecycle phase with mutual exclusion
// @param this BacktestTrade instance
// @param phase Lifecycle flag (FLAG_PENDING, FLAG_ACTIVE, or FLAG_CLOSED)
// @returns BacktestTrade instance for chaining
method setLifecycle(BacktestTrade this, int phase) =>
    this.clearFlag(FLAG_PENDING).clearFlag(FLAG_ACTIVE).clearFlag(FLAG_CLOSED).setFlag(phase)

// @function Set outcome with mutual exclusion (SL_HIT xor TP_HIT)
// @param this BacktestTrade instance
// @param outcome Outcome flag (FLAG_SL_HIT or FLAG_TP_HIT)
// @returns BacktestTrade instance for chaining
method setOutcome(BacktestTrade this, int outcome) =>
    this.clearFlag(FLAG_SL_HIT).clearFlag(FLAG_TP_HIT).setFlag(outcome)

// @type BacktestStats - Optimization results calculated from backtest history
// @description Computed once on barstate.islast from GLOBAL_backtest.history array.
//              Provides Smart SL offset and confidence metrics for live trading.
// @field avgWinningMae Average MAE of winning trades (ATR units)
// @field avgLosingMae Average MAE of losing trades (ATR units)
// @field winRate Win rate from backtest (0-1)
// @field totalTrades Total completed trades
// @field winningTrades Number of winning trades
// @field smartSlOffset Smart SL = Avg Winning MAE * 1.1
// @field lowConfidence True if win rate < 40%
// @field statsReady True once stats have been calculated
type BacktestStats
    float avgWinningMae = 0.0
    float avgLosingMae = 0.0
    float winRate = 0.0
    int   totalTrades = 0
    int   winningTrades = 0
    float smartSlOffset = 0.0
    bool  lowConfidence = false
    bool  statsReady = false

// @function Check if stats are ready for use
// @param this BacktestStats instance
// @returns True if statistics have been calculated
method isReady(BacktestStats this) =>
    this.statsReady

// @function Check if backtest shows low confidence
// @param this BacktestStats instance
// @returns True if win rate < 40%
method hasLowConfidence(BacktestStats this) =>
    this.lowConfidence

// @function Get smart SL offset based on MAE analysis
// @param this BacktestStats instance
// @returns Smart SL offset in price units
method getSmartSlOffset(BacktestStats this) =>
    this.smartSlOffset

// @type BacktestEngine - Manages trade simulation and performance tracking
// @description Encapsulates GLOBAL_backtest.history, GLOBAL_backtest.current, and stats calculation.
//              Spawns trades on pivot changes, manages lifecycle, closes on SL/TP.
// @field history Completed trade history (replaces GLOBAL_backtest.history)
// @field current Current trade being simulated (replaces GLOBAL_backtest.current)
// @field stats Optimization results (replaces bt_* vars)
type BacktestEngine
    array<BacktestTrade> history = na
    BacktestTrade current = na
    BacktestStats stats = na

// @function Initialize the backtest engine
// @param this BacktestEngine instance
// @returns BacktestEngine instance for chaining
method init(BacktestEngine this) =>
    this.history := array.new<BacktestTrade>()
    this.stats := BacktestStats.new()
    this

// @function Check if there is an active trade
// @param this BacktestEngine instance
// @returns True if current trade exists
method hasActiveTrade(BacktestEngine this) =>
    not na(this.current)

// @function Get number of completed trades
// @param this BacktestEngine instance
// @returns Size of history array
method getTradeCount(BacktestEngine this) =>
    na(this.history) ? 0 : this.history.size()

// @function Add completed trade to history
// @param this BacktestEngine instance
// @param trade Completed BacktestTrade to archive
// @returns BacktestEngine instance for chaining
method archiveTrade(BacktestEngine this, BacktestTrade trade) =>
    if not na(this.history)
        this.history.push(trade)
    this

// @function Calculate statistics from completed trades (call on barstate.islast)
// @param this BacktestEngine instance
// @returns BacktestEngine instance for chaining
method calculateStats(BacktestEngine this) =>
    if na(this.history) or na(this.stats) or this.stats.statsReady
        this
    else
        int total = this.history.size()
        if total > 0
            int wins = 0
            float sumWinningMae = 0.0
            float sumLosingMae = 0.0
            int losingCount = 0
            
            for i = 0 to total - 1
                BacktestTrade trade = this.history.get(i)
                if trade.hasFlag(FLAG_WON)
                    wins += 1
                    sumWinningMae += trade.mae
                else
                    losingCount += 1
                    sumLosingMae += trade.mae
            
            this.stats.totalTrades := total
            this.stats.winningTrades := wins
            this.stats.winRate := total > 0 ? float(wins) / float(total) : 0.0
            this.stats.avgWinningMae := wins > 0 ? sumWinningMae / float(wins) : 0.0
            this.stats.avgLosingMae := losingCount > 0 ? sumLosingMae / float(losingCount) : 0.0
            this.stats.smartSlOffset := this.stats.avgWinningMae * 1.1
            this.stats.lowConfidence := this.stats.winRate < 0.40
            this.stats.statsReady := true
        this

// Global BacktestEngine instance (replaces GLOBAL_backtest.history, GLOBAL_backtest.current, bt_* vars)
var BacktestEngine GLOBAL_backtest = BacktestEngine.new().init()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SetupState UDT: Tracks LIVE state of a Golden Pocket setup
// Used to separate CONFIRMED trade tracking (for learning) from PROJECTION preview (visual only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// @type SetupState - Tracks live state of a Golden Pocket setup
// @description Separates confirmed trade tracking (learning) from projection preview (visual only).
// @field setup_bar Bar index when setup formed (pivot bar)
// @field creation_bar Bar index when setup was created (for time decay)
// @field state_mask Bitwise flags for boolean states (see FLAG_* constants)
// @field zone_top Golden Pocket upper boundary (with buffer)
// @field zone_bottom Golden Pocket lower boundary (with buffer)
// @field sl_price Stop loss price
// @field tp_price Take profit price (active mode)
// @field tp_cons Conservative TP price (MidPivot)
// @field tp_aggr Aggressive TP price (1.272 extension)
// @field min_distance Closest approach to zone (% of zone width)
// @field entry_bar Bar when zone was first touched
// @field entry_price Price at zone entry
// @field max_adverse Worst drawdown from entry (ATR units)
// @field max_favorable Best unrealized profit (ATR units)
// @field atr_at_setup ATR at setup formation
// @field rsi_at_entry RSI when zone touched
// @field vol_percentile ATR percentile at setup (0-100)
type SetupState
    int    setup_bar
    int    creation_bar
    int    state_mask = 0
    float  zone_top
    float  zone_bottom
    float  sl_price
    float  tp_price
    float  tp_cons
    float  tp_aggr
    float  min_distance
    int    entry_bar
    float  entry_price
    float  max_adverse
    float  max_favorable
    float  atr_at_setup
    float  rsi_at_entry
    float  vol_percentile

// @function Check if a specific flag is set in this SetupState's state_mask
// @param this SetupState instance
// @param flag Flag to check (power-of-2 constant)
// @returns True if flag is set
method hasFlag(SetupState this, int flag) =>
    math.floor(this.state_mask / flag) % 2 == 1

// @function Set a flag in this SetupState's state_mask (idempotent)
// @param this SetupState instance
// @param flag Flag to set (power-of-2 constant)
// @returns SetupState instance for chaining
method setFlag(SetupState this, int flag) =>
    if not this.hasFlag(flag)
        this.state_mask += flag
    this

// @function Clear a flag from this SetupState's state_mask (idempotent)
// @param this SetupState instance
// @param flag Flag to clear (power-of-2 constant)
// @returns SetupState instance for chaining
method clearFlag(SetupState this, int flag) =>
    if this.hasFlag(flag)
        this.state_mask -= flag
    this

// @function Check if ANY of the flags in a composite mask are set
// @param this SetupState instance
// @param mask Composite mask (sum of multiple power-of-2 flags)
// @returns True if at least one flag in mask is set
method hasAny(SetupState this, int mask) =>
    bool result = false
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if this.hasFlag(testBit)
                result := true
                break
        testBit := testBit * 2
    result

// @function Check if ALL flags in a composite mask are set
// @param this SetupState instance
// @param mask Composite mask (sum of multiple power-of-2 flags)
// @returns True if all flags in mask are set
method hasAll(SetupState this, int mask) =>
    bool result = true
    int testBit = 1
    for i = 0 to STATE_MAX_BIT
        if math.floor(mask / testBit) % 2 == 1
            if not this.hasFlag(testBit)
                result := false
                break
        testBit := testBit * 2
    result

// @function Set lifecycle phase with mutual exclusion
// @param this SetupState instance
// @param phase Lifecycle flag (FLAG_PENDING, FLAG_ACTIVE, or FLAG_CLOSED)
// @returns SetupState instance for chaining
method setLifecycle(SetupState this, int phase) =>
    this.clearFlag(FLAG_PENDING).clearFlag(FLAG_ACTIVE).clearFlag(FLAG_CLOSED).setFlag(phase)

// @function Set outcome with mutual exclusion (SL_HIT xor TP_HIT)
// @param this SetupState instance
// @param outcome Outcome flag (FLAG_SL_HIT or FLAG_TP_HIT)
// @returns SetupState instance for chaining
method setOutcome(SetupState this, int outcome) =>
    this.clearFlag(FLAG_SL_HIT).clearFlag(FLAG_TP_HIT).setFlag(outcome)

// @function Create a fresh SetupState with default values
// @returns New SetupState with state_mask = 0 (no flags set)
f_new_setup_state() =>
    SetupState.new(
        na,                    // setup_bar
        na,                    // creation_bar
        0,                     // state_mask (no flags)
        na,                    // zone_top
        na,                    // zone_bottom
        na,                    // sl_price
        na,                    // tp_price
        na,                    // tp_cons
        na,                    // tp_aggr
        DEFAULT_MIN_DISTANCE,  // min_distance
        na,                    // entry_bar
        na,                    // entry_price
        0.0,                   // max_adverse
        0.0,                   // max_favorable
        na,                    // atr_at_setup
        na,                    // rsi_at_entry
        DEFAULT_CONFIDENCE     // vol_percentile
    )

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERT STATE UDT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// @type AlertState - Captures all state needed for JSON alert generation
// @description Populated at end of Statistical Position Engine block, consumed in ALERTS section
type AlertState
    // Setup flags
    bool isProjection = false
    bool isLong = false
    bool zoneTouched = false
    bool slHit = false
    bool tpHit = false
    bool inZone = false
    bool zoneEntry = false
    bool useAggressiveTp = false
    bool expired = false
    // Zone/position values
    float rawZoneTop = na
    float rawZoneBottom = na
    float adjustedZoneTop = na
    float adjustedZoneBottom = na
    float bufferPct = na
    float minDistance = na
    float slPrice = na
    float tpPrice = na
    float tpCons = na
    float tpAggr = na
    float slMult = na
    float atr = na
    float smartSl = na
    // Time decay
    int creationBar = na
    int barsSinceCreation = 0
    int timePhase = 0
    float decayRate = 0.85

// @function Populate all alert state fields from Statistical Position Engine context
// @param this AlertState instance
// @param _isProj Projection mode active
// @param _isLong Long direction
// @param _zoneTouched Zone was touched
// @param _slHit SL hit
// @param _tpHit TP hit
// @param _inZone Currently in zone
// @param _zoneEntry Just entered zone
// @param _useAggr Using aggressive TP
// @param _expired Time expired
// @param _rawTop Raw zone top
// @param _rawBottom Raw zone bottom
// @param _adjTop Adjusted zone top
// @param _adjBottom Adjusted zone bottom
// @param _bufferPct Buffer percentage
// @param _minDist Minimum distance
// @param _sl SL price
// @param _tp TP price
// @param _tpCons Conservative TP
// @param _tpAggr Aggressive TP
// @param _slMult SL multiplier
// @param _atr ATR value
// @param _smartSl Smart SL price
// @param _creationBar Creation bar
// @param _barsSince Bars since creation
// @param _phase Time phase
// @param _decay Decay rate
// @returns AlertState instance for chaining
method populate(AlertState this, bool _isProj, bool _isLong, bool _zoneTouched, bool _slHit, bool _tpHit, bool _inZone, bool _zoneEntry, bool _useAggr, bool _expired, float _rawTop, float _rawBottom, float _adjTop, float _adjBottom, float _bufferPct, float _minDist, float _sl, float _tp, float _tpCons, float _tpAggr, float _slMult, float _atr, float _smartSl, int _creationBar, int _barsSince, int _phase, float _decay) =>
    this.isProjection := _isProj
    this.isLong := _isLong
    this.zoneTouched := _zoneTouched
    this.slHit := _slHit
    this.tpHit := _tpHit
    this.inZone := _inZone
    this.zoneEntry := _zoneEntry
    this.useAggressiveTp := _useAggr
    this.expired := _expired
    this.rawZoneTop := _rawTop
    this.rawZoneBottom := _rawBottom
    this.adjustedZoneTop := _adjTop
    this.adjustedZoneBottom := _adjBottom
    this.bufferPct := _bufferPct
    this.minDistance := _minDist
    this.slPrice := _sl
    this.tpPrice := _tp
    this.tpCons := _tpCons
    this.tpAggr := _tpAggr
    this.slMult := _slMult
    this.atr := _atr
    this.smartSl := _smartSl
    this.creationBar := _creationBar
    this.barsSinceCreation := _barsSince
    this.timePhase := _phase
    this.decayRate := _decay
    this

// Global alert state - populated in Statistical Position Engine, consumed in ALERTS
var AlertState GLOBAL_alertState = AlertState.new()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE SEPARATION: Active Trade vs Projection Preview
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL_activeTrade: Updated on confirmed ZigZag pivots (GLOBAL_zigzag.changed)
//                     Source of truth for learning engine and setup history
//                     Rendered with solid visual elements
var SetupState GLOBAL_activeTrade = f_new_setup_state()

// GLOBAL_projectionPreview: Recalculated each bar during projection mode
//                           Visual preview only - not recorded to history
//                           Rendered with dashed visual elements
SetupState GLOBAL_projectionPreview = f_new_setup_state()

// Learning engine state
var LearningMetrics GLOBAL_learning = LearningMetrics.new()

// AddOn Logic: Volatility & Volume
float i_weightedATR = ta.atr(INPUT_ATR_LENGTH) * INPUT_ATR_MULT
float i_vSMA = ta.sma(nz(volume), INPUT_VOL_SMA_LEN)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REGIME STATE - Global Instance
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RegimeState GLOBAL_regime = RegimeState.new()

// Populate log-return volatility state
GLOBAL_regime.logReturn := f_logReturn(close, close[1])
GLOBAL_regime.logReturnStdev := ta.stdev(GLOBAL_regime.logReturn, LOG_VOL_WINDOW)
GLOBAL_regime.periodsPerYear := f_getPeriodsPerYear()
GLOBAL_regime.annualizedVol := f_annualizedVol(GLOBAL_regime.logReturnStdev, GLOBAL_regime.periodsPerYear)

// Populate entropy state
[_ent, _entNorm, _entReg] = f_rollingEntropy(GLOBAL_regime.logReturn, INPUT_ENTROPY_WINDOW, INPUT_ENTROPY_BINS, INPUT_ENTROPY_THRESH, INPUT_ENTROPY_TRANSITION)
GLOBAL_regime.entropy := _ent
GLOBAL_regime.entropyNorm := _entNorm
GLOBAL_regime.entropyRegime := _entReg
GLOBAL_regime.entropyOk := not INPUT_ENTROPY_ENABLED or _entReg != ENTROPY_REGIME_DISORDERED

// Populate Hurst state
[_hurst, _hurstReg] = f_rollingHurst(GLOBAL_regime.logReturn, INPUT_HURST_WINDOW, HURST_MIN_WINDOW, INPUT_HURST_TREND, INPUT_HURST_MEANREV)
GLOBAL_regime.hurst := _hurst
GLOBAL_regime.hurstRegime := _hurstReg
GLOBAL_regime.hurstOk := not INPUT_HURST_ENABLED or not INPUT_HURST_BLOCK_RANDOM or _hurstReg != HURST_REGIME_RANDOM

// Populate Z-score momentum state
GLOBAL_regime.zscoreAtr := ta.atr(INPUT_ZSCORE_ATR_LEN)
GLOBAL_regime.linregSlope := f_linregSlope(close, INPUT_ZSCORE_LR_LEN)
GLOBAL_regime.normSlope := GLOBAL_regime.zscoreAtr > 0 ? GLOBAL_regime.linregSlope / GLOBAL_regime.zscoreAtr : 0.0
[_zscore, _strongMom] = f_rollingZScore(GLOBAL_regime.normSlope, INPUT_ZSCORE_Z_LEN, ZSCORE_MIN_SAMPLES, INPUT_ZSCORE_THRESH)
GLOBAL_regime.zscore := _zscore
GLOBAL_regime.strongMomentum := _strongMom
GLOBAL_regime.momentumOk := not INPUT_ZSCORE_ENABLED or _strongMom

// Populate volatility state
GLOBAL_regime.rawAtr := i_weightedATR / INPUT_ATR_MULT
GLOBAL_regime.atrPercentile := ta.percentrank(GLOBAL_regime.rawAtr, 100)
GLOBAL_regime.rsi := ta.rsi(close, INPUT_POS_RSI_LEN)

float nzVolume = nz(volume)
bool bullCandle = close > open
bool bearCandle = close < open
float range_1 = math.abs(high - low)
bool exhaustVol = nzVolume > INPUT_VOL_SPIKE_THRESH * i_vSMA
bool crossover_exhaustion = ta.crossover(nzVolume, i_vSMA * INPUT_VOL_SPIKE_THRESH)
bool highVolatility = range_1 > i_weightedATR
bool crossover_volatility = ta.crossover(range_1, i_weightedATR)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZIGZAG ENGINE - Manages ZigZag line drawing and pivot state
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var ZigZagEngine GLOBAL_zigzag = ZigZagEngine.new()

// @type CachedPivots - Stores cached pivot coordinates for stable Fibonacci drawing
// @description Encapsulates bar index (i) and price (p) for both primary and secondary pivot pairs.
//              Used to prevent flicker during intrabar updates by caching confirmed values.
// @field iMidPivot Bar index of mid pivot (primary)
// @field pMidPivot Price of mid pivot (primary)
// @field iEndBase Bar index of end base (primary)
// @field pEndBase Price of end base (primary)
// @field iMidPivot2 Bar index of mid pivot (secondary)
// @field pMidPivot2 Price of mid pivot (secondary)
// @field iEndBase2 Bar index of end base (secondary)
// @field pEndBase2 Price of end base (secondary)
type CachedPivots
    int iMidPivot = na
    float pMidPivot = na
    int iEndBase = na
    float pEndBase = na
    int iMidPivot2 = na
    float pMidPivot2 = na
    int iEndBase2 = na
    float pEndBase2 = na

// @function Reset all cached pivot values
// @param this CachedPivots instance
// @returns CachedPivots instance for chaining
method reset(CachedPivots this) =>
    this.iMidPivot := na
    this.pMidPivot := na
    this.iEndBase := na
    this.pEndBase := na
    this.iMidPivot2 := na
    this.pMidPivot2 := na
    this.iEndBase2 := na
    this.pEndBase2 := na
    this

// @function Update primary pivot pair
// @param this CachedPivots instance
// @param iMid Bar index of mid pivot
// @param pMid Price of mid pivot
// @param iEnd Bar index of end base
// @param pEnd Price of end base
// @returns CachedPivots instance for chaining
method updatePrimary(CachedPivots this, int iMid, float pMid, int iEnd, float pEnd) =>
    this.iMidPivot := iMid
    this.pMidPivot := pMid
    this.iEndBase := iEnd
    this.pEndBase := pEnd
    this

// @function Update secondary pivot pair
// @param this CachedPivots instance
// @param iMid Bar index of mid pivot
// @param pMid Price of mid pivot
// @param iEnd Bar index of end base
// @param pEnd Price of end base
// @returns CachedPivots instance for chaining
method updateSecondary(CachedPivots this, int iMid, float pMid, int iEnd, float pEnd) =>
    this.iMidPivot2 := iMid
    this.pMidPivot2 := pMid
    this.iEndBase2 := iEnd
    this.pEndBase2 := pEnd
    this

// Global cached pivots instance
var CachedPivots GLOBAL_cachedPivots = CachedPivots.new()

// Timeframe-based deviation threshold (O(1) map lookup)
float GLOBAL_DEV_THRESHOLD = INPUT_CUSTOM_THRESHOLD and TF_DEV_THRESHOLDS.contains(timeframe.period) ? 
    TF_DEV_THRESHOLDS.get(timeframe.period) : TF_DEV_THRESHOLDS.get("DEFAULT")

// Timeframe-based depth (O(1) map lookup)
int i_depth = INPUT_CUSTOM_DEPTH and TF_DEPTHS.contains(timeframe.period) ? 
    TF_DEPTHS.get(timeframe.period) : TF_DEPTHS.get("DEFAULT")

// Determine HTF
htf_auto = timeframe.period == '1'   ? '240' : 
           timeframe.period == '3'   ? '240' : 
           timeframe.period == '5'   ? '240' : 
           timeframe.period == '15'  ? 'D'   : 
           timeframe.period == '30'  ? 'D'   : 
           timeframe.period == '45'  ? 'D'   : 
           timeframe.period == '60'  ? 'W'   : 
           timeframe.period == '120' ? 'W'   : 
           timeframe.period == '180' ? 'W'   : 
           timeframe.period == '240' ? 'W'   : 
           timeframe.period == 'D'   ? 'M'   : 
           timeframe.period == 'W'   ? '3M'  : '12M'

htf = INPUT_HTF_MODE == 'Auto' ? htf_auto : htf_user_parsed

// Time Calculations
time_x10 = ta.valuewhen(ta.change(time(htf)) != 0, time, 1)
time_x11 = ta.valuewhen(ta.change(time(htf)) != 0, time, 0)
time_x21 = 2 * time_x11 - time_x10

var ln = array.new<line>()
var lb = array.new<label>()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pivotLength = math.max(1, int(math.round(i_depth / 2)))
pH = ta.pivothigh(high, pivotLength, pivotLength)
pL = ta.pivotlow(low, pivotLength, pivotLength)
iH = not na(pH) ? bar_index[pivotLength] : int(na)
iL = not na(pL) ? bar_index[pivotLength] : int(na)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROJECTION MODE: Tentative Pivot Detection (real-time, before depth confirmation)
// UDT: Uses GLOBAL_projection for state management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Reset or update local extreme tracking
if not na(pH) or not na(pL)
    GLOBAL_projection.resetLocals(high, low, not na(pH))
else
    GLOBAL_projection.updateLocals(high, low)

// Scaled threshold for projection: INPUT_PROJ_SENSITIVITY < 1.0 reduces lag (earlier signals)
float proj_scaled_threshold = GLOBAL_DEV_THRESHOLD * INPUT_PROJ_SENSITIVITY

// Detect tentative pivots using UDT methods
bool proj_tentative_high = INPUT_PROJECTION_MODE and GLOBAL_projection.detectTentativeHigh(close, proj_scaled_threshold)
bool proj_tentative_low = INPUT_PROJECTION_MODE and GLOBAL_projection.detectTentativeLow(close, proj_scaled_threshold)

// Projection pivot values (use local extreme as tentative pivot)
float proj_pivot_price = proj_tentative_high ? GLOBAL_projection.localHigh : (proj_tentative_low ? GLOBAL_projection.localLow : na)
int   proj_pivot_bar = proj_tentative_high ? GLOBAL_projection.localHighBar : (proj_tentative_low ? GLOBAL_projection.localLowBar : int(na))
bool  proj_pivot_is_high = proj_tentative_high

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRE-CALCULATION OF HISTORICAL PIVOT VALUES (Pine v6 - call ta.valuewhen unconditionally)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pre-compute all ta.valuewhen calls unconditionally (Pine v6 best practice)
// These maintain internal state and must be called on every bar
// NOTE: Using GLOBAL_zigzag fields for pivot tracking
bool _pivotChange_iPrev = ta.change(GLOBAL_zigzag.iPrevPivot != 0)
bool _pivotChange_pPrev = ta.change(GLOBAL_zigzag.pPrevPivot != 0)
bool _pivotChange_iLast = ta.change(GLOBAL_zigzag.iLastPivot != 0)
bool _pivotChange_pLast = ta.change(GLOBAL_zigzag.pLastPivot != 0)

// Historical pivot 1 - always compute, conditionally use
int _iMidPivot_hist_0 = ta.valuewhen(_pivotChange_iPrev, GLOBAL_zigzag.iPrevPivot, math.max(0, INPUT_HIST_PIVOT - 1))
float _pMidPivot_hist_0 = ta.valuewhen(_pivotChange_pPrev, GLOBAL_zigzag.pPrevPivot, math.max(0, INPUT_HIST_PIVOT - 1))
int _iEndBase_hist_0 = ta.valuewhen(_pivotChange_iLast, GLOBAL_zigzag.iLastPivot, math.max(0, INPUT_HIST_PIVOT - 1))
float _pEndBase_hist_0 = ta.valuewhen(_pivotChange_pLast, GLOBAL_zigzag.pLastPivot, math.max(0, INPUT_HIST_PIVOT - 1))

// Historical pivot 2 - always compute, conditionally use
int _iMidPivot_hist_1 = ta.valuewhen(_pivotChange_iPrev, GLOBAL_zigzag.iPrevPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))
float _pMidPivot_hist_1 = ta.valuewhen(_pivotChange_pPrev, GLOBAL_zigzag.pPrevPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))
int _iEndBase_hist_1 = ta.valuewhen(_pivotChange_iLast, GLOBAL_zigzag.iLastPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))
float _pEndBase_hist_1 = ta.valuewhen(_pivotChange_pLast, GLOBAL_zigzag.pLastPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))

// Apply conditional logic after function calls
temp_iMidPivot_hist = INPUT_HIST_PIVOT > 0 ? _iMidPivot_hist_0 : int(na)
temp_pMidPivot_hist = INPUT_HIST_PIVOT > 0 ? _pMidPivot_hist_0 : float(na)
temp_iEndBase_hist = INPUT_HIST_PIVOT > 0 ? _iEndBase_hist_0 : int(na)
temp_pEndBase_hist = INPUT_HIST_PIVOT > 0 ? _pEndBase_hist_0 : float(na)

temp_iMidPivot2_hist = INPUT_HIST_PIVOT_2 > 0 ? _iMidPivot_hist_1 : int(na)
temp_pMidPivot2_hist = INPUT_HIST_PIVOT_2 > 0 ? _pMidPivot_hist_1 : float(na)
temp_iEndBase2_hist = INPUT_HIST_PIVOT_2 > 0 ? _iEndBase_hist_1 : int(na)
temp_pEndBase2_hist = INPUT_HIST_PIVOT_2 > 0 ? _pEndBase_hist_1 : float(na)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN PIVOT DETECTION AND ZIGZAG CONSTRUCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GLOBAL_zigzag.resetChanged()

if not na(iH)
    if na(GLOBAL_zigzag.ln) and GLOBAL_zigzag.pLast == 0
        GLOBAL_zigzag.initFirst(iH, pH, true)
    else
        float dev = f_calcDev(GLOBAL_zigzag.pLast, pH)
        bool newSegment = GLOBAL_zigzag.processPivot(dev, true, iH, pH, GLOBAL_DEV_THRESHOLD, COLOR_ZZ, INPUT_SHOW_ZIGZAG)
        
        if newSegment
            // New line segment was created - update cached pivot values
            GLOBAL_cachedPivots.iMidPivot := INPUT_HIST_PIVOT > 0 ? temp_iMidPivot_hist : GLOBAL_zigzag.iPrevPivot
            GLOBAL_cachedPivots.pMidPivot := INPUT_HIST_PIVOT > 0 ? temp_pMidPivot_hist : GLOBAL_zigzag.pPrevPivot
            GLOBAL_cachedPivots.iEndBase := INPUT_HIST_PIVOT > 0 ? temp_iEndBase_hist : GLOBAL_zigzag.iLastPivot
            GLOBAL_cachedPivots.pEndBase := INPUT_HIST_PIVOT > 0 ? temp_pEndBase_hist : GLOBAL_zigzag.pLastPivot
            
            GLOBAL_cachedPivots.iMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? temp_iMidPivot2_hist : GLOBAL_zigzag.iPrevPivot
            GLOBAL_cachedPivots.pMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? temp_pMidPivot2_hist : GLOBAL_zigzag.pPrevPivot
            GLOBAL_cachedPivots.iEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? temp_iEndBase2_hist : GLOBAL_zigzag.iLastPivot
            GLOBAL_cachedPivots.pEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? temp_pEndBase2_hist : GLOBAL_zigzag.pLastPivot
        else if not na(GLOBAL_zigzag.ln) and INPUT_HIST_PIVOT == 0
            // Line was extended (same direction) - update endpoint caches
            if GLOBAL_zigzag.isHighLast and pH > (GLOBAL_zigzag[1]).pLast
                GLOBAL_cachedPivots.iEndBase := iH
                GLOBAL_cachedPivots.pEndBase := pH
                GLOBAL_cachedPivots.iEndBase2 := iH
                GLOBAL_cachedPivots.pEndBase2 := pH
                GLOBAL_zigzag.changed := true
else
    if not na(iL)
        if na(GLOBAL_zigzag.ln) and GLOBAL_zigzag.pLast == 0
            GLOBAL_zigzag.initFirst(iL, pL, false)
        else
            float dev = f_calcDev(GLOBAL_zigzag.pLast, pL)
            bool newSegment = GLOBAL_zigzag.processPivot(dev, false, iL, pL, GLOBAL_DEV_THRESHOLD, COLOR_ZZ, INPUT_SHOW_ZIGZAG)
            
            if newSegment
                // New line segment was created - update cached pivot values
                GLOBAL_cachedPivots.iMidPivot := INPUT_HIST_PIVOT > 0 ? temp_iMidPivot_hist : GLOBAL_zigzag.iPrevPivot
                GLOBAL_cachedPivots.pMidPivot := INPUT_HIST_PIVOT > 0 ? temp_pMidPivot_hist : GLOBAL_zigzag.pPrevPivot
                GLOBAL_cachedPivots.iEndBase := INPUT_HIST_PIVOT > 0 ? temp_iEndBase_hist : GLOBAL_zigzag.iLastPivot
                GLOBAL_cachedPivots.pEndBase := INPUT_HIST_PIVOT > 0 ? temp_pEndBase_hist : GLOBAL_zigzag.pLastPivot
                
                GLOBAL_cachedPivots.iMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? temp_iMidPivot2_hist : GLOBAL_zigzag.iPrevPivot
                GLOBAL_cachedPivots.pMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? temp_pMidPivot2_hist : GLOBAL_zigzag.pPrevPivot
                GLOBAL_cachedPivots.iEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? temp_iEndBase2_hist : GLOBAL_zigzag.iLastPivot
                GLOBAL_cachedPivots.pEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? temp_pEndBase2_hist : GLOBAL_zigzag.pLastPivot
            else if not na(GLOBAL_zigzag.ln) and INPUT_HIST_PIVOT == 0
                // Line was extended (same direction) - update endpoint caches
                if not GLOBAL_zigzag.isHighLast and pL < (GLOBAL_zigzag[1]).pLast
                    GLOBAL_cachedPivots.iEndBase := iL
                    GLOBAL_cachedPivots.pEndBase := pL
                    GLOBAL_cachedPivots.iEndBase2 := iL
                    GLOBAL_cachedPivots.pEndBase2 := pL
                    GLOBAL_zigzag.changed := true

// @function Get OHLC values for a higher timeframe
// @param _htf Higher timeframe string (e.g., "240", "D")
// @returns Tuple of [open, high, low, close, open_real, high_real, low_real, close_real]
f_htf_ohlc(string _htf) =>
    var htf_o  = 0.
    var htf_h  = 0.
    var htf_l  = 0.
    htf_c      = close
    
    var htf_ox = 0.
    var htf_hx = 0.
    var htf_lx = 0.
    var htf_cx = 0.

    if ta.change(time(_htf) !=0)
        htf_ox := htf_o
        htf_o  := open
        htf_hx := htf_h
        htf_h  := high
        htf_lx := htf_l
        htf_l  := low
        htf_cx := htf_c[1]
        htf_cx
    else
        htf_h := math.max(high, htf_h)
        htf_l := math.min(low , htf_l)
        htf_l

    [htf_ox, htf_hx, htf_lx, htf_cx, htf_o, htf_h, htf_l, htf_c]

[_, htf_h1, htf_l1, htf_c1, _, _, _, _] = f_htf_ohlc(htf)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PIVOT COORDINATE REFERENCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

iMidPivot  = GLOBAL_cachedPivots.iMidPivot
pMidPivot  = GLOBAL_cachedPivots.pMidPivot
iEndBase   = GLOBAL_cachedPivots.iEndBase
pEndBase   = GLOBAL_cachedPivots.pEndBase
iMidPivot2 = GLOBAL_cachedPivots.iMidPivot2
pMidPivot2 = GLOBAL_cachedPivots.pMidPivot2
iEndBase2  = GLOBAL_cachedPivots.iEndBase2
pEndBase2  = GLOBAL_cachedPivots.pEndBase2

// PivotContext for confirmed pivots (uses cached values)
PivotContext GLOBAL_confirmedPivot = PivotContext.new(GLOBAL_cachedPivots.pMidPivot, GLOBAL_cachedPivots.pEndBase, INPUT_REVERSE)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROJECTION PIVOT INTEGRATION (for Statistical Position Engine)
// UDT: Uses GLOBAL_projection for state management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// When projection mode is active and we have a tentative pivot, use it for earlier Golden Pocket display
// The projection creates a "lookahead" pivot using the current bar as the new EndBase

// Update projection state when tentative pivot detected
if proj_tentative_high or proj_tentative_low
    GLOBAL_projection.activate(proj_tentative_high, proj_tentative_high ? low : high)
else if GLOBAL_zigzag.changed
    GLOBAL_projection.deactivate()

// Effective pivot values: use projection if active, otherwise confirmed
int   effIMidPivot = GLOBAL_projection.isActive() ? GLOBAL_projection.iMidPivot : GLOBAL_cachedPivots.iMidPivot
float effPMidPivot = GLOBAL_projection.isActive() ? GLOBAL_projection.pMidPivot : GLOBAL_cachedPivots.pMidPivot
int   effIEndBase = GLOBAL_projection.isActive() ? GLOBAL_projection.iEndBase : GLOBAL_cachedPivots.iEndBase
float effPEndBase = GLOBAL_projection.isActive() ? GLOBAL_projection.pEndBase : GLOBAL_cachedPivots.pEndBase

// PivotContext for effective pivots (includes projection if active)
PivotContext GLOBAL_effectivePivot = PivotContext.new(effPMidPivot, effPEndBase, INPUT_REVERSE)

// @function Check if price crossed a level
// @param _curret Current price
// @param _level Level price to check against
// @returns True if price crossed the level
f_crossingLevel(float _curret, float _level) =>
    _level > _curret and _level < _curret[1] or _level < _curret and _level > _curret[1]

if ta.change(time) != 0 and array.size(ln) > 0
    for i = 1 to array.size(ln) by 1
        line.delete(array.shift(ln))

if ta.change(time) != 0 and array.size(lb) > 0
    for i = 1 to array.size(lb) by 1
        label.delete(array.shift(lb))

// @function Draw a Time Zone line (thin wrapper with bounds check)
// @param _x1 Start x-coordinate
// @param _y1 Start y-coordinate
// @param _x2 End x-coordinate
// @param _y2 End y-coordinate
// @param _xloc X-location type
// @param _extend Extension type
// @param _c Line color
// @param _s Line style
// @param _w Line width
// @returns void
f_drawLineTZ(int _x1, float _y1, int _x2, float _y2, string _xloc, string _extend, color _c, string _s, int _w) =>
    if _x1 - bar_index < 500
        array.push(ln, line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w))

// @function Draw a Time Zone label (thin wrapper with bounds check)
// @param _x X-coordinate
// @param _y Y-coordinate
// @param _text Label text
// @param _xloc X-location type
// @param _yloc Y-location type
// @param _color Background color
// @param _style Label style
// @param _textcolor Text color
// @param _size Label size
// @param _textalign Text alignment
// @param _tooltip Tooltip text
// @returns void
f_drawLabelTZ(int _x, float _y, string _text, string _xloc, string _yloc, color _color, string _style, color _textcolor, string _size, string _textalign, string _tooltip) =>
    if _x - bar_index < 500
        array.push(lb, label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip))

// @function Draw a Pivot line (thin wrapper with validity check)
// @param _x1 Start x-coordinate
// @param _y1 Start y-coordinate
// @param _x2 End x-coordinate
// @param _y2 End y-coordinate
// @param _xloc X-location type
// @param _extend Extension type
// @param _c Line color
// @param _s Line style
// @param _w Line width
// @returns void
f_drawLinePVT(int _x1, float _y1, int _x2, float _y2, string _xloc, string _extend, color _c, string _s, int _w) =>
    if _y1 > 0
        array.push(ln, line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w))

// @function Draw a Pivot label (thin wrapper with validity check)
// @param _x X-coordinate
// @param _y Y-coordinate
// @param _text Label text
// @param _xloc X-location type
// @param _yloc Y-location type
// @param _color Background color
// @param _style Label style
// @param _textcolor Text color
// @param _size Label size
// @param _textalign Text alignment
// @param _tooltip Tooltip text
// @returns void
f_drawLabelPVT(int _x, float _y, string _text, string _xloc, string _yloc, color _color, string _style, color _textcolor, string _size, string _textalign, string _tooltip) =>
    if _y > 0
        array.push(lb, label.new(_x, _y, INPUT_EXTEND_PVT or INPUT_LEVELS_PVT_POS == "Last Bar" ? _text + '\n\n' : _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip))

// @function Draw or update Fibonacci level line and label
// @param this FibLevel instance
// @param x1 Start bar index
// @param pMid Mid pivot price
// @param x2 End bar index
// @param pEnd End pivot price
// @param forceRedraw True to delete and recreate visuals
// @returns void
method draw(FibLevel this, int x1, float pMid, int x2, float pEnd, bool forceRedraw) =>
    if this.show and not na(x1) and not na(pMid) and not na(pEnd)
        pPivotDiff = math.abs(pMid - pEnd)
        price = 0.
        price := pEnd < pMid ? (INPUT_REVERSE ? pEnd : pMid) - (INPUT_REVERSE ? -1 : 1) * pPivotDiff * this.level : (INPUT_REVERSE ? pEnd : pMid) + (INPUT_REVERSE ? -1 : 1) * pPivotDiff * this.level
        price := math.round_to_mintick(price)
        
        if forceRedraw
            if not na(this.ln)
                line.delete(this.ln)
                this.ln := na
            if not na(this.lb)
                label.delete(this.lb)
                this.lb := na
            if price > 0
                this.ln := line.new(x1, price, x2, price, xloc.bar_index, INPUT_EXTEND_ER ? extend.both : extend.right, this.col, line.style_solid, this.level != 1 ? 1 : 2)
            if INPUT_LEVELS_LABEL != 'None' and price > 0
                bar_pos = INPUT_LEVELS_POS == "Last Bar" ? x2 : x1
                style_lbl = INPUT_LEVELS_POS == "Last Bar" ? label.style_label_left : label.style_label_right
                size_lbl = INPUT_LEVELS_SIZE == 'Small' ? size.small : size.normal
                text_str = (INPUT_LEVELS_LABEL == 'Prices' ? '' : 'RET ' + str.tostring(this.level)) + (INPUT_LEVELS_LABEL == 'Levels + Prices' or INPUT_LEVELS_LABEL == 'Prices' ? ' (' + str.tostring(price, format.mintick) + ')' : '')
                tooltip_str = str.tostring(price, format.mintick)
                this.lb := label.new(bar_pos, price, INPUT_EXTEND_PVT or INPUT_EXTEND_ER or INPUT_LEVELS_POS == 'Last Bar' ? text_str + '\n\n' : text_str, xloc.bar_index, yloc.price, color.new(COLOR_FG_MAIN, 100), style_lbl, color.new(COLOR_FG_MAIN, 0), size_lbl, text.align_right, tooltip_str)
        else
            if not na(this.ln) and price > 0
                line.set_x2(this.ln, x2)
            if INPUT_LEVELS_POS == "Last Bar" and not na(this.lb) and price > 0
                label.set_x(this.lb, x2)
        
        GLOBAL_pivotLevelsLogRetracements.put(this.level, price)
        // Use pre-computed crossing result (computed globally for Pine v6 consistency)
        if this.crossed
            GLOBAL_pivotLevelsLogCrossed.put(this.level, price)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JSON SERIALIZATION HELPERS - Alert Event Payload Construction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Serialize float to JSON (handles na as null)
// @param v Float value
// @returns JSON string representation
f_jsonFloat(float v) =>
    na(v) ? 'null' : str.tostring(v)

// @function Serialize int to JSON (handles na as null)
// @param v Int value
// @returns JSON string representation
f_jsonInt(int v) =>
    na(v) ? 'null' : str.tostring(v)

// @function Serialize bool to JSON
// @param v Bool value
// @returns JSON string representation
f_jsonBool(bool v) =>
    v ? 'true' : 'false'

// @function Serialize string to JSON with quotes
// @param v String value
// @returns JSON string representation
f_jsonStr(string v) =>
    na(v) ? 'null' : '"' + v + '"'

// @function Build common envelope JSON for all events
// @param id Event ID
// @param eventType Event type string
// @returns JSON string with common fields
f_jsonEnvelope(string id, string eventType) =>
    string barstate_json = '{"is_new":' + f_jsonBool(barstate.isnew) + ',"is_first":' + f_jsonBool(barstate.isfirst) + ',"is_last":' + f_jsonBool(barstate.islast) + ',"is_confirmed":' + f_jsonBool(barstate.isconfirmed) + ',"is_history":' + f_jsonBool(barstate.ishistory) + '}'
    string ohlcv_json = '{"open":' + f_jsonFloat(open) + ',"high":' + f_jsonFloat(high) + ',"low":' + f_jsonFloat(low) + ',"close":' + f_jsonFloat(close) + ',"volume":' + f_jsonFloat(volume) + '}'
    string result = '"schema_version":"' + ALERT_SCHEMA_VERSION + '","event_id":"' + id + '","event_type":"' + eventType + '","symbol":"' + syminfo.tickerid + '","timeframe":"' + timeframe.period + '","bar_index":' + str.tostring(bar_index) + ',"last_bar_index":' + str.tostring(last_bar_index) + ',"time":' + str.tostring(time) + ',"time_close":' + str.tostring(time_close) + ',"time_tradingday":' + str.tostring(time_tradingday) + ',"barstate":' + barstate_json + ',"ohlcv":' + ohlcv_json
    result

// @function Serialize pivots context to JSON
// @param confirmedMidBar Confirmed mid pivot bar
// @param confirmedMidPrice Confirmed mid pivot price
// @param confirmedEndBar Confirmed end pivot bar
// @param confirmedEndPrice Confirmed end pivot price
// @param effMidBar Effective mid pivot bar
// @param effMidPrice Effective mid pivot price
// @param effEndBar Effective end pivot bar (na for projection)
// @param effEndPrice Effective end pivot price
// @param projActive Projection active flag
// @returns JSON string for pivots object
f_jsonPivots(int confirmedMidBar, float confirmedMidPrice, int confirmedEndBar, float confirmedEndPrice, int effMidBar, float effMidPrice, int effEndBar, float effEndPrice, bool projActive) =>
    string result = '{"confirmed":{"mid_bar":' + f_jsonInt(confirmedMidBar) + ',"mid_price":' + f_jsonFloat(confirmedMidPrice) + ',"end_bar":' + f_jsonInt(confirmedEndBar) + ',"end_price":' + f_jsonFloat(confirmedEndPrice) + '},"effective":{"mid_bar":' + f_jsonInt(effMidBar) + ',"mid_price":' + f_jsonFloat(effMidPrice) + ',"end_bar":' + f_jsonInt(effEndBar) + ',"end_price":' + f_jsonFloat(effEndPrice) + ',"projection_active":' + f_jsonBool(projActive) + '}}'
    result

// @function Serialize setup state to JSON
// @param isProjection Whether in projection mode
// @param isLong Long direction
// @param zoneTouched Zone was touched
// @param slHit SL hit flag
// @param tpHit TP hit flag
// @returns JSON string for setup object
f_jsonSetup(bool isProjection, bool isLong, bool zoneTouched, bool slHit, bool tpHit) =>
    string state = isProjection ? 'projection' : 'confirmed'
    string labelPrefix = isProjection ? 'âš¡PROJ' : 'âœ“ACTIVE'
    bool isRecordable = not isProjection and zoneTouched
    string result = '{"state":"' + state + '","is_long":' + f_jsonBool(isLong) + ',"label_prefix":"' + labelPrefix + '","is_recordable":' + f_jsonBool(isRecordable) + ',"zone_touched":' + f_jsonBool(zoneTouched) + ',"sl_hit":' + f_jsonBool(slHit) + ',"tp_hit":' + f_jsonBool(tpHit) + '}'
    result

// @function Serialize zone data to JSON
// @param rawTop Raw zone top
// @param rawBottom Raw zone bottom
// @param adjTop Adjusted zone top
// @param adjBottom Adjusted zone bottom
// @param bufferPct Buffer percentage
// @param inZone Currently in zone
// @param zoneEntry Zone entry event
// @param minDistPct Minimum distance percentage
// @returns JSON string for zone object
f_jsonZone(float rawTop, float rawBottom, float adjTop, float adjBottom, float bufferPct, bool inZone, bool zoneEntry, float minDistPct) =>
    float rawMid = (rawTop + rawBottom) / 2
    float adjMid = (adjTop + adjBottom) / 2
    string result = '{"raw":{"top":' + f_jsonFloat(rawTop) + ',"bottom":' + f_jsonFloat(rawBottom) + ',"mid":' + f_jsonFloat(rawMid) + '},"adjusted":{"top":' + f_jsonFloat(adjTop) + ',"bottom":' + f_jsonFloat(adjBottom) + ',"mid":' + f_jsonFloat(adjMid) + ',"buffer_pct":' + f_jsonFloat(bufferPct) + '},"status":{"in_zone":' + f_jsonBool(inZone) + ',"zone_entry":' + f_jsonBool(zoneEntry) + ',"min_distance_pct":' + f_jsonFloat(minDistPct) + '}}'
    result

// @function Serialize position data to JSON
// @param entryMid Entry mid price
// @param slPrice Stop loss price
// @param tpPrice Take profit price
// @param tpCons Conservative TP
// @param tpAggr Aggressive TP
// @param useAggr Using aggressive TP
// @param slMult SL multiplier
// @param atr ATR value
// @param smartSlPrice Smart SL price (na if not available)
// @returns JSON string for position object
f_jsonPosition(float entryMid, float slPrice, float tpPrice, float tpCons, float tpAggr, bool useAggr, float slMult, float atr, float smartSlPrice) =>
    string tpMode = useAggr ? 'aggressive' : 'conservative'
    float risk = math.abs(entryMid - slPrice)
    float reward = math.abs(tpPrice - entryMid)
    float rr = risk > 0 ? reward / risk : 0.0
    string result = '{"entry_mid":' + f_jsonFloat(entryMid) + ',"sl_price":' + f_jsonFloat(slPrice) + ',"tp_price":' + f_jsonFloat(tpPrice) + ',"tp_mode":"' + tpMode + '","tp_cons":' + f_jsonFloat(tpCons) + ',"tp_aggr":' + f_jsonFloat(tpAggr) + ',"sl_mult":' + f_jsonFloat(slMult) + ',"atr":' + f_jsonFloat(atr) + ',"risk_abs":' + f_jsonFloat(risk) + ',"reward_abs":' + f_jsonFloat(reward) + ',"rr":' + f_jsonFloat(rr) + ',"smart_sl":' + f_jsonFloat(smartSlPrice) + '}'
    result

// @function Serialize time decay data to JSON
// @param enabled Time decay enabled
// @param creationBar Creation bar index
// @param barsSince Bars since creation
// @param phase Current phase (0-6)
// @param decayRate Decay rate
// @param expired Whether expired
// @returns JSON string for time_decay object
f_jsonTimeDecay(bool enabled, int creationBar, int barsSince, int phase, float decayRate, bool expired) =>
    string status = phase >= 5 ? 'expired' : (phase >= 3 ? 'stale' : 'fresh')
    string result = '{"enabled":' + f_jsonBool(enabled) + ',"creation_bar":' + f_jsonInt(creationBar) + ',"bars_since":' + f_jsonInt(barsSince) + ',"phase":' + f_jsonInt(phase) + ',"decay_rate":' + f_jsonFloat(decayRate) + ',"status":"' + status + '","expired":' + f_jsonBool(expired) + '}'
    result

// @function Serialize regime data to JSON
// @param rs RegimeState instance
// @returns JSON string for regime object
f_jsonRegime(RegimeState rs) =>
    string entropyStr = rs.entropyRegime == 0 ? 'ordered' : (rs.entropyRegime == 1 ? 'transition' : 'disordered')
    string hurstStr = rs.hurstRegime == 0 ? 'trend' : (rs.hurstRegime == 1 ? 'random' : 'mean_revert')
    string result = '{"entropy":{"value":' + f_jsonFloat(rs.entropyNorm) + ',"regime":"' + entropyStr + '"},"hurst":{"value":' + f_jsonFloat(rs.hurst) + ',"regime":"' + hurstStr + '"},"momentum":{"zscore":' + f_jsonFloat(rs.zscore) + ',"strong":' + f_jsonBool(rs.strongMomentum) + '}}'
    result

// @function Serialize learning metrics to JSON
// @param lm LearningMetrics instance
// @param samples Sample count
// @returns JSON string for learning object
f_jsonLearning(LearningMetrics lm, int samples) =>
    string result = '{"enabled":true,"samples":' + f_jsonInt(samples) + ',"needs_recalc":' + f_jsonBool(lm.needsRecalc) + ',"near_miss_count":' + f_jsonInt(lm.nearMissCount) + ',"total_setups":' + f_jsonInt(lm.totalSetups) + ',"win_rate":' + f_jsonFloat(lm.winRate) + ',"zone_buffer_pct":' + f_jsonFloat(lm.zoneBuffer) + ',"avg_mae":' + f_jsonFloat(lm.avgMae) + ',"avg_mfe":' + f_jsonFloat(lm.avgMfe) + ',"avg_bars":' + f_jsonInt(lm.avgBars) + ',"sl_mult":' + f_jsonFloat(lm.slMult) + ',"confidence":' + f_jsonFloat(lm.confidence) + ',"profit_factor":' + f_jsonFloat(lm.profitFactor) + ',"expectancy":' + f_jsonFloat(lm.expectancy) + ',"wr_long":' + f_jsonFloat(lm.wrLong) + ',"wr_short":' + f_jsonFloat(lm.wrShort) + ',"wr_high_vol":' + f_jsonFloat(lm.wrHighVol) + ',"wr_low_vol":' + f_jsonFloat(lm.wrLowVol) + ',"div_edge":' + f_jsonFloat(lm.divEdge) + ',"rsi_weight":' + f_jsonFloat(lm.rsiWeight) + ',"decay_rate":' + f_jsonFloat(lm.decayRate) + ',"bayes_mean":' + f_jsonFloat(lm.bayesMean) + ',"bayes_lower":' + f_jsonFloat(lm.bayesLowerBound) + ',"sortino":' + f_jsonFloat(lm.sortinoRatio) + ',"is_healthy":' + f_jsonBool(lm.isHealthy) + ',"win_streak":' + f_jsonInt(lm.winStreak) + ',"loss_streak":' + f_jsonInt(lm.lossStreak) + '}'
    result

// @function Serialize backtest stats to JSON
// @param bs BacktestStats instance
// @returns JSON string for backtest object
f_jsonBacktest(BacktestStats bs) =>
    string result = '{"ready":' + f_jsonBool(bs.statsReady) + ',"total_trades":' + f_jsonInt(bs.totalTrades) + ',"win_rate":' + f_jsonFloat(bs.winRate) + ',"winning_trades":' + f_jsonInt(bs.winningTrades) + ',"avg_winning_mae":' + f_jsonFloat(bs.avgWinningMae) + ',"avg_losing_mae":' + f_jsonFloat(bs.avgLosingMae) + ',"smart_sl_offset":' + f_jsonFloat(bs.smartSlOffset) + ',"low_confidence":' + f_jsonBool(bs.lowConfidence) + '}'
    result

// @function Serialize Monte Carlo results to JSON
// @param lm LearningMetrics with MC fields
// @returns JSON string for monte_carlo object
f_jsonMonteCarlo(LearningMetrics lm) =>
    string result = '{"original_dd":' + f_jsonFloat(lm.mcOriginalDD) + ',"mean_shuffled_dd":' + f_jsonFloat(lm.mcMeanShuffledDD) + ',"p_value":' + f_jsonFloat(lm.mcPValue) + ',"sims_run":' + f_jsonInt(lm.mcSimsRun) + ',"significant":' + f_jsonBool(lm.mcSignificant) + '}'
    result

// @function Construct JSON alert message with full state snapshot
// @param id Alert ID string
// @param eventType Event type string for categorization
// @param isProj Projection mode active
// @param isLong Long direction
// @param zoneTouched Zone touched flag
// @param slHit SL hit flag
// @param tpHit TP hit flag
// @param zoneTop Adjusted zone top
// @param zoneBottom Adjusted zone bottom
// @param slPrice Stop loss price
// @param tpPrice Take profit price
// @param tpCons Conservative TP
// @param tpAggr Aggressive TP
// @param useAggr Using aggressive TP mode
// @param slMult SL multiplier
// @param atr ATR value
// @param smartSl Smart SL price
// @param creationBar Creation bar for time decay
// @param barsSince Bars since creation
// @param timePhase Time decay phase
// @param decayRate Decay rate
// @param expired Expired flag
// @returns JSON formatted string with complete state snapshot
f_getAlertMessageFull(string id, string eventType, bool isProj, bool isLong, bool zoneTouched, bool slHit, bool tpHit, float rawZoneTop, float rawZoneBottom, float zoneTop, float zoneBottom, float bufferPct, bool inZone, bool zoneEntry, float minDist, float slPrice, float tpPrice, float tpCons, float tpAggr, bool useAggr, float slMult, float atr, float smartSl, int creationBar, int barsSince, int timePhase, float decayRate, bool expired) =>
    float entryMid = (zoneTop + zoneBottom) / 2
    
    // Build envelope
    string envelope = f_jsonEnvelope(id, eventType)
    
    // Build component JSONs
    string pivots_json = f_jsonPivots(
        GLOBAL_cachedPivots.iMidPivot, GLOBAL_cachedPivots.pMidPivot,
        GLOBAL_cachedPivots.iEndBase, GLOBAL_cachedPivots.pEndBase,
        GLOBAL_projection.isActive() ? GLOBAL_projection.iMidPivot : GLOBAL_cachedPivots.iMidPivot,
        GLOBAL_projection.isActive() ? GLOBAL_projection.pMidPivot : GLOBAL_cachedPivots.pMidPivot,
        GLOBAL_projection.isActive() ? bar_index : GLOBAL_cachedPivots.iEndBase,
        GLOBAL_projection.isActive() ? GLOBAL_projection.pEndBase : GLOBAL_cachedPivots.pEndBase,
        GLOBAL_projection.isActive())
    string setup_json = f_jsonSetup(isProj, isLong, zoneTouched, slHit, tpHit)
    string zone_json = f_jsonZone(rawZoneTop, rawZoneBottom, zoneTop, zoneBottom, bufferPct, inZone, zoneEntry, minDist)
    string position_json = f_jsonPosition(entryMid, slPrice, tpPrice, tpCons, tpAggr, useAggr, slMult, atr, smartSl)
    string time_decay_json = f_jsonTimeDecay(INPUT_POS_TIME_DECAY, creationBar, barsSince, timePhase, decayRate, expired)
    string regime_json = f_jsonRegime(GLOBAL_regime)
    string learning_json = f_jsonLearning(GLOBAL_learning, GLOBAL_setupHistory.size())
    string backtest_json = f_jsonBacktest(GLOBAL_backtest.stats)
    string mc_json = f_jsonMonteCarlo(GLOBAL_learning)
    
    // Assemble full JSON
    string result = '{' + envelope + ',"pivots":' + pivots_json + ',"setup":' + setup_json + ',"zone":' + zone_json + ',"position":' + position_json + ',"time_decay":' + time_decay_json + ',"regime":' + regime_json + ',"learning":' + learning_json + ',"backtest":' + backtest_json + ',"monte_carlo":' + mc_json + ',"retracements":' + GLOBAL_pivotLevelsLogRetracements.toJson() + ',"crossed_retracements":' + GLOBAL_pivotLevelsLogCrossed.toJson() + ',"confluence":{"exhaust_vol":' + f_jsonBool(exhaustVol) + ',"high_volatility":' + f_jsonBool(highVolatility) + '}}'
    result

// @function Construct legacy JSON alert message (backward compatible)
// @param id Alert ID string
// @returns JSON formatted string with alert details
f_getAlertMessage(string id) =>
    string barstate_json = '{"is_new":' + (barstate.isnew ? 'true' : 'false') + ',"is_first":' + (barstate.isfirst ? 'true' : 'false') + ',"is_last":' + (barstate.islast ? 'true' : 'false') + ',"is_confirmed":' + (barstate.isconfirmed ? 'true' : 'false') + ',"is_history":' + (barstate.ishistory ? 'true' : 'false') + '}'
    string ohlcv_json = '{"open":' + str.tostring(open) + ',"high":' + str.tostring(high) + ',"low":' + str.tostring(low) + ',"close":' + str.tostring(close) + ',"hl2":' + str.tostring(hl2) + ',"hlc3":' + str.tostring(hlc3) + ',"hlcc4":' + str.tostring(hlcc4) + ',"ohlc4":' + str.tostring(ohlc4) + ',"volume":' + str.tostring(volume) + '}'
    string base_json = '"schema_version":"' + ALERT_SCHEMA_VERSION + '","event_id":"' + id + '","symbol":"' + syminfo.tickerid + '","timeframe":"' + timeframe.period + '","bar_index":' + str.tostring(bar_index) + ',"last_bar_index":' + str.tostring(last_bar_index) + ',"time_tradingday":' + str.tostring(time_tradingday) + ',"time_close":' + str.tostring(time_close) + ',"session_is_first_bar":' + (session.isfirstbar ? 'true' : 'false') + ',"barstate":' + barstate_json + ',"ohlcv":' + ohlcv_json
    string log = ''
    if id == ALERT_ID_UPDATE
        log := '{' + base_json + ',"retracements":' + GLOBAL_pivotLevelsLogRetracements.toJson() + ',"crossed_retracements":' + GLOBAL_pivotLevelsLogCrossed.toJson() + '}'
    if id == ALERT_ID_EXHAUSTION
        log := '{' + base_json + ',"bull_candle":' + (bullCandle ? 'true' : 'false') + ',"bear_candle":' + (bearCandle ? 'true' : 'false') + ',"exhaust_vol":' + (exhaustVol ? 'true' : 'false') + '}'
    if id == ALERT_ID_VOLATILITY
        log := '{' + base_json + ',"bull_candle":' + (bullCandle ? 'true' : 'false') + ',"bear_candle":' + (bearCandle ? 'true' : 'false') + ',"high_volatility":' + (highVolatility ? 'true' : 'false') + '}'
    if id == ALERT_ID_CROSSING
        log := '{' + base_json + ',"crossed_retracements":' + GLOBAL_pivotLevelsLogCrossed.toJson() + '}'
    log

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOT EXECUTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if INPUT_SHOW_FIB_TIME
    t_lineTZ_style = line.style_dotted
    t_lineTZ_width = 1
    t_lineTZ_color = color.new(COLOR_FG_MAIN, 50)
    referance = math.round(iEndBase2 - iMidPivot2)
    f_drawLineTZ(_x1=iMidPivot2 - referance        , _y1=pEndBase2, _x2=iMidPivot2 - referance       , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2                    , _y1=pEndBase2, _x2=iMidPivot2                   , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=t_lineTZ_color, _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance        , _y1=pEndBase2, _x2=iMidPivot2 + referance       , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=t_lineTZ_color, _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 2    , _y1=pEndBase2, _x2=iMidPivot2 + referance * 2 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 3    , _y1=pEndBase2, _x2=iMidPivot2 + referance * 3 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 5    , _y1=pEndBase2, _x2=iMidPivot2 + referance * 5 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 8    , _y1=pEndBase2, _x2=iMidPivot2 + referance * 8 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 13   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 13, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 21   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 21, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 34   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 34, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 55   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 55, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 89   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 89, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)

    if INPUT_FIB_TZ_LABEL
        t_labelTZ_background = color.new(COLOR_FG_MAIN, 100)
        t_labelTZ_text_align = text.align_center
        t_labelTZ_size = size.small
        t_labelTZ_color = color.new(COLOR_FG_MAIN, 0)
        f_drawLabelTZ(_x=iMidPivot2 + referance * -1, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='-1', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 0 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='0' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=t_labelTZ_color, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 1 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='1' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=t_labelTZ_color, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 2 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='2' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 3 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='3' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 5 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='5' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 8 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='8' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 13, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='13', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 21, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='21', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 34, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='34', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 55, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='55', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 89, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='89', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CACHED COORDINATE INITIALIZATION AND UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if not na(GLOBAL_zigzag.ln)
    currentX1 = line.get_x1(GLOBAL_zigzag.ln)
    currentY1 = line.get_y1(GLOBAL_zigzag.ln)
    currentX2 = line.get_x2(GLOBAL_zigzag.ln)
    currentY2 = line.get_y2(GLOBAL_zigzag.ln)
    
    if na(GLOBAL_cachedPivots.iMidPivot) or GLOBAL_zigzag.changed
        GLOBAL_cachedPivots.iMidPivot := GLOBAL_zigzag.iPrevPivot != 0 ? GLOBAL_zigzag.iPrevPivot : currentX1
        GLOBAL_cachedPivots.pMidPivot := GLOBAL_zigzag.pPrevPivot != 0 ? GLOBAL_zigzag.pPrevPivot : currentY1
        GLOBAL_cachedPivots.iEndBase := GLOBAL_zigzag.iLastPivot != 0 ? GLOBAL_zigzag.iLastPivot : currentX2
        GLOBAL_cachedPivots.pEndBase := GLOBAL_zigzag.pLastPivot != 0 ? GLOBAL_zigzag.pLastPivot : currentY2
        GLOBAL_cachedPivots.iMidPivot2 := GLOBAL_zigzag.iPrevPivot != 0 ? GLOBAL_zigzag.iPrevPivot : currentX1
        GLOBAL_cachedPivots.pMidPivot2 := GLOBAL_zigzag.pPrevPivot != 0 ? GLOBAL_zigzag.pPrevPivot : currentY1
        GLOBAL_cachedPivots.iEndBase2 := GLOBAL_zigzag.iLastPivot != 0 ? GLOBAL_zigzag.iLastPivot : currentX2
        GLOBAL_cachedPivots.pEndBase2 := GLOBAL_zigzag.pLastPivot != 0 ? GLOBAL_zigzag.pLastPivot : currentY2

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRE-COMPUTED RSI DIVERGENCE VALUES (Pine v6 - must be called on every bar)
// These ta.valuewhen calls capture RSI and price at pivot changes for divergence detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float GLOBAL_rsi_at_pivot = ta.valuewhen(GLOBAL_zigzag.changed, GLOBAL_regime.rsi, 0)
float GLOBAL_priceAtPivot = ta.valuewhen(GLOBAL_zigzag.changed, close, 0)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIBONACCI LEVEL DRAWING (Pine v6 - all functions called unconditionally)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pre-compute crossing detection for all fib levels (Pine v6 - must call on every bar)
// f_crossingLevel uses history reference, so we compute it unconditionally for ALL levels
for lvl in fibLevels
    // Always compute the price for this level (even if not shown)
    float pPivotDiff = math.abs(nz(GLOBAL_cachedPivots.pMidPivot) - nz(GLOBAL_cachedPivots.pEndBase))
    float lvl_price = nz(GLOBAL_cachedPivots.pEndBase) < nz(GLOBAL_cachedPivots.pMidPivot) ? 
         (INPUT_REVERSE ? nz(GLOBAL_cachedPivots.pEndBase) : nz(GLOBAL_cachedPivots.pMidPivot)) - (INPUT_REVERSE ? -1 : 1) * pPivotDiff * lvl.level : 
         (INPUT_REVERSE ? nz(GLOBAL_cachedPivots.pEndBase) : nz(GLOBAL_cachedPivots.pMidPivot)) + (INPUT_REVERSE ? -1 : 1) * pPivotDiff * lvl.level
    lvl_price := math.round_to_mintick(lvl_price)
    // Always call f_crossingLevel (uses history reference - must be called on every bar)
    lvl.crossed := f_crossingLevel(close, lvl_price)

// Determine redraw need unconditionally
bool needsFullRedraw = GLOBAL_zigzag.changed or (fibLevels.size() > 0 ? na(array.get(fibLevels, 0).ln) : false)
bool canDrawFibs = not na(GLOBAL_cachedPivots.iMidPivot) and not na(GLOBAL_cachedPivots.pEndBase)

// Always call draw method on every bar (Pine v6 - methods must be called consistently)
for lvl in fibLevels
    lvl.draw(GLOBAL_cachedPivots.iMidPivot, GLOBAL_cachedPivots.pMidPivot, bar_index, GLOBAL_cachedPivots.pEndBase, needsFullRedraw and canDrawFibs)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKTESTING ENGINE - Historical Trade Simulation Loop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This logic runs on EVERY bar to:
// 1. Manage the current simulation (GLOBAL_backtest.current) through its lifecycle
// 2. Spawn new trades when ZigZag pivots are confirmed
// 3. Build GLOBAL_backtest.history with completed trades for learning analysis
// Uses RAW Fib levels (GLOBAL_cachedPivots.pMidPivot, GLOBAL_cachedPivots.pEndBase) - no learned adjustments

// Calculate RAW Golden Pocket levels using confirmed pivots only
float raw_price_618 = GLOBAL_confirmedPivot.getLevel(FIB_GOLDEN_RATIO)
float raw_price_65  = GLOBAL_confirmedPivot.getLevel(FIB_GOLDEN_POCKET_H)
float raw_zone_top = math.max(raw_price_618, raw_price_65)
float raw_zone_btm = math.min(raw_price_618, raw_price_65)
float raw_entry_mid = (raw_zone_top + raw_zone_btm) / 2

// Determine direction from RAW confirmed pivots (not projections)
// EndBase < MidPivot = downswing completed = LONG expected
bool raw_is_long = GLOBAL_cachedPivots.pEndBase < GLOBAL_cachedPivots.pMidPivot
int raw_direction = raw_is_long ? 1 : -1

// Calculate RAW SL/TP using default multipliers (pure data, no learning)
float raw_atr = nz(ta.atr(INPUT_ATR_LENGTH), 1.0)
float raw_sl_buffer = raw_atr * INPUT_POS_SL_MULT
float raw_tp_target = GLOBAL_cachedPivots.pMidPivot  // Conservative TP = back to MidPivot (swing start)

float raw_sl_price = raw_is_long ? GLOBAL_cachedPivots.pEndBase - raw_sl_buffer : GLOBAL_cachedPivots.pEndBase + raw_sl_buffer
float raw_tp_price = raw_tp_target

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PART A: Spawning New Trades (FIRST - before management)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CRITICAL: Spawn BEFORE management so new trades don't get processed on spawn bar
// Only spawn when:
// 1. GLOBAL_zigzag.changed is true (ZigZag confirmed)
// 2. GLOBAL_backtest.current is na (not already in a simulation)
// 3. We have valid cached pivot data
// 4. Entropy regime allows trading (ORDERED or TRANSITION)
// 5. Hurst regime allows trading (if blocking random is enabled)
// 6. Momentum is statistically significant (if Z-score filter enabled)
if GLOBAL_zigzag.changed and na(GLOBAL_backtest.current) and not na(GLOBAL_cachedPivots.iMidPivot) and not na(GLOBAL_cachedPivots.pEndBase) and GLOBAL_regime.entropyOk and GLOBAL_regime.hurstOk and GLOBAL_regime.momentumOk
    // Build initial state_mask: PENDING + direction flag (using arithmetic for raw int)
    int init_state = FLAG_PENDING + (raw_is_long ? FLAG_IS_LONG : 0)
    
    // Create a new BacktestTrade with RAW levels
    GLOBAL_backtest.current := BacktestTrade.new(
        GLOBAL_cachedPivots.iMidPivot,       // id: Pivot bar index
        init_state,            // state_mask: FLAG_PENDING + FLAG_IS_LONG if long
        raw_entry_mid,         // entry_price: mid of Golden Pocket (updated on activation)
        raw_zone_top,          // entry_top: zone upper boundary
        raw_zone_btm,          // entry_btm: zone lower boundary
        raw_sl_price,          // sl_price: initial SL
        raw_tp_price,          // tp_price: initial TP
        0.0,                   // mae: starts at 0
        0.0,                   // mfe: starts at 0
        na,                    // entry_bar: not yet entered
        na                     // exit_bar: not yet exited
    )
    
    // DEBUG: Log trade spawn
    log.info("BACKTEST SPAWN: {0} trade #{1}, Zone=[{2}, {3}], SL={4}, TP={5}", 
             raw_is_long ? "LONG" : "SHORT", GLOBAL_cachedPivots.iMidPivot, 
             raw_zone_btm, raw_zone_top, raw_sl_price, raw_tp_price)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PART B: Managing the Current Simulation (runs every bar AFTER spawn)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CRITICAL: Skip processing on the SAME bar the trade was spawned (GLOBAL_zigzag.changed bar)
// This prevents the trade from being immediately killed or activated on spawn bar
bool skip_this_bar = GLOBAL_zigzag.changed  // Don't process newly spawned trades on their creation bar

if not na(GLOBAL_backtest.current) and not skip_this_bar
    bool sim_is_long = GLOBAL_backtest.current.hasFlag(FLAG_IS_LONG)
    
    // PENDING: Waiting for price to touch the Golden Pocket zone
    if GLOBAL_backtest.current.hasFlag(FLAG_PENDING)
        bool zone_touched = false
        bool sl_breached_before_entry = false
        
        if sim_is_long  // LONG: waiting for price to dip INTO zone
            zone_touched := low <= GLOBAL_backtest.current.entry_top and high >= GLOBAL_backtest.current.entry_btm
            sl_breached_before_entry := low <= GLOBAL_backtest.current.sl_price and not zone_touched
        else  // SHORT: waiting for price to rise INTO zone
            zone_touched := high >= GLOBAL_backtest.current.entry_btm and low <= GLOBAL_backtest.current.entry_top
            sl_breached_before_entry := high >= GLOBAL_backtest.current.sl_price and not zone_touched
        
        // Handle SL breach before entry (trade invalidated)
        if sl_breached_before_entry
            log.info("BACKTEST KILLED: {0} trade #{1} - SL breached before entry", 
                     sim_is_long ? "LONG" : "SHORT", GLOBAL_backtest.current.id)
            GLOBAL_backtest.current := na
        // If zone touched, activate the trade (transition: PENDING -> ACTIVE)
        else if zone_touched
            GLOBAL_backtest.current.setLifecycle(FLAG_ACTIVE).setFlag(FLAG_ZONE_TOUCHED)
            GLOBAL_backtest.current.entry_bar := bar_index
            GLOBAL_backtest.current.entry_price := sim_is_long ? GLOBAL_backtest.current.entry_top : GLOBAL_backtest.current.entry_btm
            GLOBAL_backtest.current.mae := 0.0
            GLOBAL_backtest.current.mfe := 0.0
            log.info("BACKTEST ACTIVATED: {0} trade #{1} at entry={2}", 
                     sim_is_long ? "LONG" : "SHORT", GLOBAL_backtest.current.id, GLOBAL_backtest.current.entry_price)
    
    // ACTIVE: In trade, tracking MAE/MFE and checking for exit
    else if GLOBAL_backtest.current.hasFlag(FLAG_ACTIVE)
        // Update MAE (Max Adverse Excursion) - worst price against us
        if sim_is_long  // LONG: adverse = price going DOWN
            float adverse = GLOBAL_backtest.current.entry_price - low
            GLOBAL_backtest.current.mae := math.max(GLOBAL_backtest.current.mae, adverse)
        else  // SHORT: adverse = price going UP
            float adverse = high - GLOBAL_backtest.current.entry_price
            GLOBAL_backtest.current.mae := math.max(GLOBAL_backtest.current.mae, adverse)
        
        // Update MFE (Max Favorable Excursion) - best price in our favor
        if sim_is_long  // LONG: favorable = price going UP
            float favorable = high - GLOBAL_backtest.current.entry_price
            GLOBAL_backtest.current.mfe := math.max(GLOBAL_backtest.current.mfe, favorable)
        else  // SHORT: favorable = price going DOWN
            float favorable = GLOBAL_backtest.current.entry_price - low
            GLOBAL_backtest.current.mfe := math.max(GLOBAL_backtest.current.mfe, favorable)
        
        // Check for exit conditions (HTF level - used for initial screening)
        bool sl_hit = sim_is_long ? (low <= GLOBAL_backtest.current.sl_price) : (high >= GLOBAL_backtest.current.sl_price)
        bool tp_hit = sim_is_long ? (high >= GLOBAL_backtest.current.tp_price) : (low <= GLOBAL_backtest.current.tp_price)
        
        // Handle exits (transition: ACTIVE -> CLOSED)
        if sl_hit or tp_hit
            GLOBAL_backtest.current.setLifecycle(FLAG_CLOSED)
            GLOBAL_backtest.current.exit_bar := bar_index
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // INTRABAR PRECISION: Resolve TP/SL order chronologically using LTF data
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            bool trade_won = false
            bool used_ltf_resolution = false
            int ltf_hit_idx = -1
            
            if sl_hit and tp_hit
                // Both TP and SL hit in same HTF bar - need to determine which came first
                if INPUT_INTRABAR_ENABLED and array.size(GLOBAL_ltfHighs) > 0
                    // Use intrabar resolution for chronological determination
                    bool conservative = INPUT_INTRABAR_TIEBREAK == "Conservative"
                    [ltf_outcome, ltf_resolved, hit_idx] = f_resolveIntrabar(GLOBAL_ltfHighs, GLOBAL_ltfLows, sim_is_long, GLOBAL_backtest.current.sl_price, GLOBAL_backtest.current.tp_price, conservative)
                    
                    if ltf_resolved
                        trade_won := ltf_outcome == 1  // 1 = TP first, -1 = SL first
                        used_ltf_resolution := true
                        ltf_hit_idx := hit_idx
                        GLOBAL_backtest.current.setFlag(FLAG_LTF_RESOLVED)
                    else
                        // LTF data available but no decisive outcome - use HTF fallback
                        float dist_to_sl = math.abs(open - GLOBAL_backtest.current.sl_price)
                        float dist_to_tp = math.abs(open - GLOBAL_backtest.current.tp_price)
                        trade_won := dist_to_tp < dist_to_sl * 0.5
                else
                    // Intrabar disabled or no LTF data - use HTF heuristic (fallback per FR-7)
                    float dist_to_sl = math.abs(open - GLOBAL_backtest.current.sl_price)
                    float dist_to_tp = math.abs(open - GLOBAL_backtest.current.tp_price)
                    trade_won := dist_to_tp < dist_to_sl * 0.5
            else
                // Only one level hit - straightforward resolution
                trade_won := tp_hit
            
            // Set outcome flags using setOutcome method for mutual exclusion (SL_HIT xor TP_HIT)
            if trade_won
                GLOBAL_backtest.current.setOutcome(FLAG_TP_HIT).setFlag(FLAG_WON)
            else
                GLOBAL_backtest.current.setOutcome(FLAG_SL_HIT)
            
            // Push completed trade to GLOBAL_backtest.history
            array.push(GLOBAL_backtest.history, GLOBAL_backtest.current)
            
            // DEBUG: Log trade completion with intrabar resolution info
            if used_ltf_resolution
                log.info("BACKTEST CLOSED (LTF): {0} #{1}, Won={2}, LTF_idx={3}/{4}, MAE={5}, MFE={6}", 
                         sim_is_long ? "LONG" : "SHORT", GLOBAL_backtest.current.id, trade_won,
                         ltf_hit_idx, array.size(GLOBAL_ltfHighs), GLOBAL_backtest.current.mae, GLOBAL_backtest.current.mfe)
            else
                log.info("BACKTEST CLOSED (HTF): {0} #{1}, Entry={2}, Won={3}, MAE={4}, MFE={5}", 
                         sim_is_long ? "LONG" : "SHORT", 
                         GLOBAL_backtest.current.id, GLOBAL_backtest.current.entry_price, trade_won, 
                         GLOBAL_backtest.current.mae, GLOBAL_backtest.current.mfe)
            
            // Clear current simulation
            GLOBAL_backtest.current := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTIMIZATION ENGINE - Calculate Stats from Backtest History
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if barstate.islast and array.size(GLOBAL_backtest.history) > 0 and not GLOBAL_backtest.stats.statsReady
    int total = array.size(GLOBAL_backtest.history)
    int wins = 0
    float sum_winning_mae = 0.0
    float sum_losing_mae = 0.0
    int losing_count = 0
    
    // Loop through all completed trades
    for i = 0 to total - 1
        BacktestTrade trade = array.get(GLOBAL_backtest.history, i)
        if trade.hasFlag(FLAG_WON)
            wins += 1
            sum_winning_mae += trade.mae
        else
            losing_count += 1
            sum_losing_mae += trade.mae
    
    // Calculate statistics
    GLOBAL_backtest.stats.totalTrades := total
    GLOBAL_backtest.stats.winningTrades := wins
    GLOBAL_backtest.stats.winRate := total > 0 ? float(wins) / float(total) : 0.0
    GLOBAL_backtest.stats.avgWinningMae := wins > 0 ? sum_winning_mae / float(wins) : 0.0
    GLOBAL_backtest.stats.avgLosingMae := losing_count > 0 ? sum_losing_mae / float(losing_count) : 0.0
    
    // Smart SL offset: Avg Winning MAE * 1.1 (give 10% buffer beyond typical drawdown)
    GLOBAL_backtest.stats.smartSlOffset := GLOBAL_backtest.stats.avgWinningMae * 1.1
    
    // Confidence flag: Low confidence if win rate < 40%
    GLOBAL_backtest.stats.lowConfidence := GLOBAL_backtest.stats.winRate < 0.40
    
    // Mark stats as ready
    GLOBAL_backtest.stats.statsReady := true
    
    // Log optimization results
    log.info("BACKTEST OPTIMIZATION: {0} trades, {1}% WR, Avg Winner MAE={2}, Smart SL Offset={3}, LowConf={4}", 
             GLOBAL_backtest.stats.totalTrades, math.round(GLOBAL_backtest.stats.winRate * 100), GLOBAL_backtest.stats.avgWinningMae, GLOBAL_backtest.stats.smartSlOffset, GLOBAL_backtest.stats.lowConfidence)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATISTICAL POSITION ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// UDT: All position visual elements consolidated (see PositionVisual type definition above)
var PositionVisual GLOBAL_posVisual = PositionVisual.new()

// Use effective pivots (projection if active, otherwise confirmed)
if INPUT_SHOW_POS and not na(effIMidPivot) and not na(effPEndBase)
    // Determine if this is a projection update (for visual feedback)
    bool isProjection = GLOBAL_projection.isActive()
    
    // When EndBase > MidPivot, the last swing was UP (upswing completed), so we expect a retracement DOWN into the pocket â†’ SHORT
    // When EndBase < MidPivot, the last swing was DOWN (downswing completed), so we expect a retracement UP into the pocket â†’ LONG
    // GLOBAL_effectivePivot uses effective pivots (projection or confirmed)
    bool is_long_setup = effPEndBase < effPMidPivot  // EndBase < MidPivot = downswing completed = LONG retracement expected
    float price_618 = GLOBAL_effectivePivot.getLevel(FIB_GOLDEN_RATIO)
    float price_65  = GLOBAL_effectivePivot.getLevel(FIB_GOLDEN_POCKET_H)
    
    // Reuse global ATR calculation (i_weightedATR = ta.atr(INPUT_ATR_LENGTH) * INPUT_ATR_MULT)
    float current_atr = GLOBAL_regime.rawAtr
    
    // Dynamic SL: Use ATR percentile to scale SL buffer based on volatility regime
    // Use global pre-computed atr_percentile (C-optimized, called on every bar)
    float atr_percentile = GLOBAL_regime.atrPercentile  // 0 = lowest vol, 100 = highest vol
    // Scale multiplier: at 50th percentile = base mult, at 0 = -50%, at 100 = +50%
    float dynamic_scale = INPUT_POS_SL_DYNAMIC ? (1 + (atr_percentile - 50) / 100) : 1.0
    
    // Phase 2: Use learned SL multiplier if enabled and sufficient data
    // GLOBAL_learning.slMult is computed from: avg MAE of winning trades + SL_BUFFER_ATR buffer
    float base_sl_mult = INPUT_POS_SL_MULT
    bool use_learned = INPUT_USE_LEARNED_SL and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_SL and GLOBAL_learning.slMult > 0
    if use_learned
        base_sl_mult := GLOBAL_learning.slMult
        // Validation: if losing trades had larger MAE, consider widening SL
        // Only if losing MAE is significantly larger than winning MAE (indicating stops too tight)
        if GLOBAL_learning.losingMae > 0 and GLOBAL_learning.losingMae > GLOBAL_learning.avgMae * SL_LOSING_MAE_FACTOR
            // Blend: use midpoint between learned SL and losing MAE to reduce premature stops
            base_sl_mult := (GLOBAL_learning.slMult + GLOBAL_learning.losingMae) / 2
    float effective_sl_mult = base_sl_mult * dynamic_scale
    
    // SL is placed beyond the swing extreme (EndBase) + ATR buffer
    // LONG: EndBase is swing LOW, SL goes below it
    // SHORT: EndBase is swing HIGH, SL goes above it
    float sl_price = is_long_setup ? effPEndBase - (current_atr * effective_sl_mult) : effPEndBase + (current_atr * effective_sl_mult)
    
    // Phase 3: Calculate both TP prices for comparison learning
    // TP targets: Conservative = back to MidPivot (start of swing), Aggressive = 1.272 extension beyond MidPivot
    // LONG: TP is ABOVE entry (toward and beyond MidPivot which is the HIGH)
    // SHORT: TP is BELOW entry (toward and beyond MidPivot which is the LOW)
    float tp_conservative = effPMidPivot
    // Extension goes BEYOND MidPivot (not calculated by f_get_level_eff which only does retracements)
    float swing_range = math.abs(effPMidPivot - effPEndBase)
    float extension_amount = swing_range * (FIB_EXTENSION_1272 - 1.0)  // The amount beyond 100%
    float tp_aggressive = is_long_setup ? effPMidPivot + extension_amount : effPMidPivot - extension_amount
    
    // Calculate distances for MFE comparison
    float cons_dist = math.abs(tp_conservative - (price_618 + price_65) / 2)
    float aggr_dist = math.abs(tp_aggressive - (price_618 + price_65) / 2)
    float mfe_dist = GLOBAL_learning.avgMfe * current_atr  // MFE converted to price distance
    
    // Determine which TP mode to use (Phase 3: can be learned)
    bool use_aggressive_tp = INPUT_POS_TP_MODE == 'Aggressive'
    bool has_learned_tp = INPUT_LEARN_TP and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_learned_tp
        // Prefer learned EV-based decision if available
        if GLOBAL_learning.aggrEv != 0 or GLOBAL_learning.consEv != 0
            use_aggressive_tp := GLOBAL_learning.tpAggressive
        // Fallback: if avg MFE exceeds conservative TP distance, use aggressive
        else if GLOBAL_learning.avgMfe > 0 and mfe_dist > cons_dist * 1.2
            use_aggressive_tp := true
    float tp_price = use_aggressive_tp ? tp_aggressive : tp_conservative
    
    // Zone boundaries
    float box_top = math.max(price_618, price_65)
    float box_bottom = math.min(price_618, price_65)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LEARNING ENGINE: Near-miss detection and adaptive zone buffer
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Calculate adaptive zone buffer based on historical near-misses
    float zone_width = box_top - box_bottom
    // Start with previously learned buffer if available, otherwise base
    float adaptive_buffer = GLOBAL_learning.zoneBuffer > 0 ? GLOBAL_learning.zoneBuffer : INPUT_ZONE_BUFFER_BASE
    
    if INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_BUFFER
        // Count near-misses in recent history
        int near_misses = 0
        int total_valid = 0
        int max_check = math.min(INPUT_LEARNING_SAMPLES - 1, GLOBAL_setupHistory.size() - 1)
        for i = 0 to max_check
            SetupRecord rec = GLOBAL_setupHistory.get(i)
            if na(rec)
                continue
            if rec.closest_approach > 0 and rec.closest_approach < INPUT_NEAR_MISS_THRESH and not rec.hasFlag(FLAG_ZONE_TOUCHED)
                near_misses += 1
            total_valid += 1
        
        // If >NEAR_MISS_RATE_THRESH are near-misses, expand zone proportionally
        float miss_rate = total_valid > 0 ? float(near_misses) / float(total_valid) : 0.0
        // Scale buffer: miss_rate * multiplier, capped at max
        float learned_buffer = 0.0
        if miss_rate > NEAR_MISS_RATE_THRESH
            learned_buffer := math.min(miss_rate * NEAR_MISS_BUFFER_MULT, NEAR_MISS_BUFFER_MAX)
        // Also consider average near-miss distance to determine buffer size
        // If near-misses are very close, expand more aggressively
        if near_misses > 0
            float avg_approach = 0.0
            int approach_count = 0
            for j = 0 to max_check
                SetupRecord rec2 = GLOBAL_setupHistory.get(j)
                if not na(rec2) and rec2.closest_approach > 0 and rec2.closest_approach < INPUT_NEAR_MISS_THRESH and not rec2.hasFlag(FLAG_ZONE_TOUCHED)
                    avg_approach += rec2.closest_approach
                    approach_count += 1
            if approach_count > 0
                avg_approach := avg_approach / float(approach_count)
                // If avg near-miss is < NEAR_MISS_CLOSE_THRESH, add extra buffer
                if avg_approach < NEAR_MISS_CLOSE_THRESH
                    learned_buffer += (NEAR_MISS_CLOSE_THRESH - avg_approach) * 10  // Up to +3% extra
        adaptive_buffer := math.max(INPUT_ZONE_BUFFER_BASE, learned_buffer)
        GLOBAL_learning.zoneBuffer := adaptive_buffer
        GLOBAL_learning.nearMissCount := near_misses
        GLOBAL_learning.totalSetups := total_valid
    
    // Apply adaptive buffer to zone boundaries
    float buffer_amount = zone_width * (adaptive_buffer / 100)
    float adjusted_box_top = box_top + buffer_amount
    float adjusted_box_bottom = box_bottom - buffer_amount
    
    // DEBUG: Log learning engine values on bar confirmation
    if barstate.isconfirmed and INPUT_LEARNING_ENABLED
        int sample_count = GLOBAL_setupHistory.size()
        log.info("LEARNING: samples={0}, zone_buffer={1}%, sl_mult={2}, win_rate={3}%, sl_price={4}, tp_price={5}", 
                 sample_count, adaptive_buffer, effective_sl_mult, GLOBAL_learning.winRate * 100, sl_price, tp_price)
    
    // Near-miss detection: how close did price get to the zone?
    // Distance is positive when price is OUTSIDE the zone, 0 or negative when INSIDE
    float dist_to_zone_pct = 0.0
    bool price_outside_zone = not (low <= adjusted_box_top and high >= adjusted_box_bottom)
    
    if price_outside_zone
        if is_long_setup
            // For longs (after downswing), zone is above current price. Measure how close high got to zone bottom.
            if high < adjusted_box_bottom
                dist_to_zone_pct := ((adjusted_box_bottom - high) / adjusted_box_bottom) * 100
        else
            // For shorts (after upswing), zone is below current price. Measure how close low got to zone top.
            if low > adjusted_box_top
                dist_to_zone_pct := ((low - adjusted_box_top) / adjusted_box_top) * 100
    // else: price is inside zone, distance = 0 (not a near-miss, it's a touch)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIRMED TRADE TRACKING (Learning Engine - NOT for projections)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Track minimum distance for CONFIRMED setup only (not projections)
    if not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        GLOBAL_activeTrade.min_distance := math.min(GLOBAL_activeTrade.min_distance, dist_to_zone_pct)
    
    // Zone activation: price is inside the (adjusted) Golden Pocket
    // For CONFIRMED trades: use stored zone boundaries for consistent tracking
    // For DISPLAY: use current calculated boundaries
    bool in_zone = false
    bool zone_entry = false
    
    // Check against CONFIRMED trade boundaries (for learning)
    bool confirmed_in_zone = false
    bool confirmed_zone_entry = false
    if not na(GLOBAL_activeTrade.setup_bar)
        confirmed_in_zone := low <= GLOBAL_activeTrade.zone_top and high >= GLOBAL_activeTrade.zone_bottom
        confirmed_zone_entry := confirmed_in_zone and not GLOBAL_activeTrade.hasFlag(FLAG_ZONE_TOUCHED)
    
    // Check against CURRENT boundaries (for display)
    in_zone := low <= adjusted_box_top and high >= adjusted_box_bottom
    zone_entry := in_zone and (na(GLOBAL_activeTrade.setup_bar) or not GLOBAL_activeTrade.hasFlag(FLAG_ZONE_TOUCHED))
    
    // Track if zone was touched for CONFIRMED setup only (not projections)
    if confirmed_in_zone and not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        GLOBAL_activeTrade.setFlag(FLAG_ZONE_TOUCHED)
    
    // Track SL/TP hits for CONFIRMED setup only (not projections)
    // CRITICAL: Only track SL/TP AFTER zone is touched (entry occurred)
    // Use STORED sl/tp prices from setup formation for consistent tracking
    // CONSERVATIVE EXECUTION: If bar covers both SL and TP, assume SL hit UNLESS
    //   Open is at least 2x closer to TP than SL (dist_to_tp < dist_to_sl * 0.5)
    if not na(GLOBAL_activeTrade.setup_bar) and GLOBAL_activeTrade.hasFlag(FLAG_ZONE_TOUCHED) and not isProjection
        if GLOBAL_activeTrade.hasFlag(FLAG_IS_LONG)
            bool sl_touched = low <= GLOBAL_activeTrade.sl_price
            bool tp_touched = high >= GLOBAL_activeTrade.tp_price
            
            // Outcome detection with mutual exclusion (first outcome wins, per FR-4 invariant)
            // Skip if outcome already determined
            if not GLOBAL_activeTrade.hasAny(MASK_OUTCOME)
                if sl_touched and tp_touched
                    // Conservative execution: when both hit in same bar, prioritize capital preservation
                    // Check if Open was closer to TP - only then assume TP hit first
                    float dist_to_sl = math.abs(open - GLOBAL_activeTrade.sl_price)
                    float dist_to_tp = math.abs(open - GLOBAL_activeTrade.tp_price)
                    // TP only wins if Open is significantly closer (50%+ closer) to TP
                    if dist_to_tp < dist_to_sl * 0.5
                        GLOBAL_activeTrade.setOutcome(FLAG_TP_HIT).setFlag(FLAG_WON)
                    else
                        GLOBAL_activeTrade.setOutcome(FLAG_SL_HIT)
                else if sl_touched
                    GLOBAL_activeTrade.setOutcome(FLAG_SL_HIT)
                else if tp_touched
                    GLOBAL_activeTrade.setOutcome(FLAG_TP_HIT).setFlag(FLAG_WON)
            
            // Phase 3: Track BOTH TP modes independently (for learning comparison)
            // These are analytics flags, not mutually exclusive with SL/TP outcome
            if high >= GLOBAL_activeTrade.tp_cons
                GLOBAL_activeTrade.setFlag(FLAG_CONS_TP_HIT)
            if high >= GLOBAL_activeTrade.tp_aggr
                GLOBAL_activeTrade.setFlag(FLAG_AGGR_TP_HIT)
        else
            bool sl_touched = high >= GLOBAL_activeTrade.sl_price
            bool tp_touched = low <= GLOBAL_activeTrade.tp_price
            
            // Outcome detection with mutual exclusion (first outcome wins, per FR-4 invariant)
            // Skip if outcome already determined
            if not GLOBAL_activeTrade.hasAny(MASK_OUTCOME)
                if sl_touched and tp_touched
                    // Conservative execution: when both hit in same bar, prioritize capital preservation
                    float dist_to_sl = math.abs(open - GLOBAL_activeTrade.sl_price)
                    float dist_to_tp = math.abs(open - GLOBAL_activeTrade.tp_price)
                    if dist_to_tp < dist_to_sl * 0.5
                        GLOBAL_activeTrade.setOutcome(FLAG_TP_HIT).setFlag(FLAG_WON)
                    else
                        GLOBAL_activeTrade.setOutcome(FLAG_SL_HIT)
                else if sl_touched
                    GLOBAL_activeTrade.setOutcome(FLAG_SL_HIT)
                else if tp_touched
                    GLOBAL_activeTrade.setOutcome(FLAG_TP_HIT).setFlag(FLAG_WON)
            
            // Phase 3: Track BOTH TP modes independently (for learning comparison)
            // These are analytics flags, not mutually exclusive with SL/TP outcome
            if low <= GLOBAL_activeTrade.tp_cons
                GLOBAL_activeTrade.setFlag(FLAG_CONS_TP_HIT)
            if low <= GLOBAL_activeTrade.tp_aggr
                GLOBAL_activeTrade.setFlag(FLAG_AGGR_TP_HIT)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXTENDED LEARNING: MAE/MFE Tracking (Phase 1) - CONFIRMED TRADES ONLY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Track entry when zone is first touched (CONFIRMED trades only, not projections)
    if confirmed_zone_entry and not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        if na(GLOBAL_activeTrade.entry_bar)
            GLOBAL_activeTrade.entry_bar := bar_index
            GLOBAL_activeTrade.entry_price := close
            GLOBAL_activeTrade.rsi_at_entry := GLOBAL_regime.rsi
    
    // Track MAE/MFE from entry (only after zone touched, CONFIRMED trades only)
    if not na(GLOBAL_activeTrade.entry_bar) and not na(GLOBAL_activeTrade.entry_price) and not na(GLOBAL_activeTrade.atr_at_setup) and not isProjection
        if not GLOBAL_activeTrade.hasAny(MASK_OUTCOME)
            if GLOBAL_activeTrade.hasFlag(FLAG_IS_LONG)
                // MAE: How much price moved against us (low - entry, negative is adverse)
                float adverse = (GLOBAL_activeTrade.entry_price - low) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_adverse := math.max(GLOBAL_activeTrade.max_adverse, adverse)
                // MFE: How much price moved in our favor (high - entry)
                float favorable = (high - GLOBAL_activeTrade.entry_price) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_favorable := math.max(GLOBAL_activeTrade.max_favorable, favorable)
            else
                // Short: adverse is when price goes up, favorable is when price goes down
                float adverse = (high - GLOBAL_activeTrade.entry_price) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_adverse := math.max(GLOBAL_activeTrade.max_adverse, adverse)
                float favorable = (GLOBAL_activeTrade.entry_price - low) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_favorable := math.max(GLOBAL_activeTrade.max_favorable, favorable)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TASK 3 FIX: Time Decay Calculation
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PROBLEM: Previously used effIMidPivot which causes decay to "jump" when projection becomes confirmed.
    //          When projection mode: pivot is "now" (bar_index), decay = 0 (Fresh)
    //          When confirmed: pivot bar jumps back by pivotLength, decay jumps to Stale instantly
    //
    // SOLUTION: Use creation_bar for confirmed trades (tracks when WE created the setup)
    //           For projections: decay = 0 (always Fresh since we're projecting in real-time)
    //           For confirmed: decay = bar_index - creation_bar (smooth progression)
    //
    // NOTE: creation_bar is set to bar_index when GLOBAL_zigzag.changed fires, so the FIRST bar after
    //       confirmation starts at 0 bars since creation, then increments smoothly.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    int bars_since_creation = 0
    if isProjection
        // Projection mode: decay is always 0 (Fresh) since we're projecting in real-time
        bars_since_creation := 0
    else if not na(GLOBAL_activeTrade.creation_bar)
        // Confirmed mode: use stored creation_bar for smooth decay progression
        bars_since_creation := bar_index - GLOBAL_activeTrade.creation_bar
    else
        // Fallback: use effIMidPivot if no active trade (shouldn't happen often)
        bars_since_creation := bar_index - effIMidPivot
    
    // Dynamic time thresholds: scale Fib sequence by learned avg_bars if available
    float time_scale = 1.0
    bool has_learned_time = INPUT_LEARN_DECAY and INPUT_LEARNING_ENABLED and GLOBAL_learning.avgBars > 0
    if has_learned_time
        // Reference: default assumes TIME_DECAY_REFERENCE_BARS is "mid" point (Fib threshold 2)
        time_scale := math.max(TIME_DECAY_SCALE_MIN, math.min(TIME_DECAY_SCALE_MAX, float(GLOBAL_learning.avgBars) / TIME_DECAY_REFERENCE_BARS))
    
    // Fibonacci time thresholds and decay calculation (scaled by learned timing)
    // Each threshold passed reduces confidence by decay rate
    int t1 = int(TIME_DECAY_T1 * time_scale)
    int t2 = int(TIME_DECAY_T2 * time_scale)
    int t3 = int(TIME_DECAY_T3 * time_scale)
    int t4 = int(TIME_DECAY_T4 * time_scale)
    int t5 = int(TIME_DECAY_T5 * time_scale)
    int t6 = int(89 * time_scale)
    
    int time_phase = bars_since_creation >= t6 ? 6 : 
                     bars_since_creation >= t5 ? 5 : 
                     bars_since_creation >= t4 ? 4 : 
                     bars_since_creation >= t3 ? 3 : 
                     bars_since_creation >= t2 ? 2 : 
                     bars_since_creation >= t1 ? 1 : 0
    
    // Phase 3: Use learned decay rate if enabled and sufficient data
    float decay_rate = TIME_DECAY_DEFAULT_RATE
    bool has_learned_decay = INPUT_LEARN_DECAY and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_learned_decay and GLOBAL_learning.decayRate > 0
        decay_rate := GLOBAL_learning.decayRate
    float time_decay = INPUT_POS_TIME_DECAY ? math.pow(decay_rate, time_phase) : 1.0
    bool zone_expired = INPUT_POS_TIME_DECAY and time_phase >= 5  // Expired after t5+ bars
    
    // Time decay indicator for display (show learned rate if different)
    string decay_indicator = has_learned_decay ? ICON_HOURGLASS + "*" : ICON_HOURGLASS
    string time_status = not INPUT_POS_TIME_DECAY ? "" : 
                         time_phase == 0 ? " " + decay_indicator + TEXT_FRESH : 
                         time_phase <= 2 ? " " + decay_indicator + str.tostring(int(time_decay * 100)) + "%" : 
                         time_phase <= 4 ? " " + decay_indicator + TEXT_STALE : " " + decay_indicator + "EXPIRED"
    
    // SL breach invalidation (also invalidate on zone expiration)
    // Use CONFIRMED trade direction and SL for consistency (not projection)
    bool sl_check_long = not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.hasFlag(FLAG_IS_LONG) : is_long_setup
    float sl_check_price = not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.sl_price : sl_price
    bool sl_breached = sl_check_long ? close < sl_check_price : close > sl_check_price
    bool is_invalid = sl_breached or zone_expired
    
    // Volume confluence
    bool vol_confirm = exhaustVol or crossover_exhaustion
    
    // RSI Divergence Confluence - Use global pre-computed values (Pine v6 best practice)
    float rsi = GLOBAL_regime.rsi
    float rsi_at_pivot = GLOBAL_rsi_at_pivot
    float price_at_pivot = GLOBAL_priceAtPivot
    
    // Use CONFIRMED trade direction for divergence check (for learning consistency)
    bool check_long = not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.hasFlag(FLAG_IS_LONG) : is_long_setup
    // Bullish divergence: price made lower low but RSI made higher low (momentum building)
    bool bullish_div = check_long and close < price_at_pivot and rsi > rsi_at_pivot
    // Bearish divergence: price made higher high but RSI made lower high (momentum fading)
    bool bearish_div = not check_long and close > price_at_pivot and rsi < rsi_at_pivot
    bool rsi_confirm = INPUT_POS_RSI_DIV ? ((check_long and bullish_div) or (not check_long and bearish_div)) : false
    
    // Capture RSI divergence flag for learning (CONFIRMED trades only, not projections)
    if confirmed_zone_entry and not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        if bullish_div or bearish_div
            GLOBAL_activeTrade.setFlag(FLAG_HAD_RSI_DIV)
    
    // Combined confluence: volume OR RSI divergence
    bool full_confirm = vol_confirm or rsi_confirm
    
    // Determine box color based on state (apply time decay to transparency)
    // Use current calculation for display (projection or confirmed)
    bool active_is_long = isProjection ? is_long_setup : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.hasFlag(FLAG_IS_LONG) : is_long_setup)
    color base_color = active_is_long ? COLOR_BLUE : COLOR_RED
    int decay_trans_add = int((1 - time_decay) * 20)  // Add 0-20 transparency based on decay
    int bg_trans = is_invalid ? 90 : (in_zone ? (full_confirm ? 45 : (vol_confirm or rsi_confirm ? 55 : 65)) : 75) + decay_trans_add
    int border_trans = is_invalid ? 80 : (rsi_confirm ? 10 : 25) + decay_trans_add
    color bg_col = is_invalid ? color.new(COLOR_GRAY, math.min(bg_trans, 95)) : color.new(base_color, math.min(bg_trans, 95))
    color border_col = is_invalid ? color.new(COLOR_GRAY, math.min(border_trans, 90)) : color.new(base_color, math.min(border_trans, 90))
    
    // R:R calculation - use current calculated values (with learning adjustments)
    float mid_entry = (price_618 + price_65) / 2
    float risk = math.abs(mid_entry - sl_price)
    float reward = math.abs(tp_price - mid_entry)
    float rr_ratio = risk > 0 ? reward / risk : 0
    
    // Kelly Criterion: f* = (p * b - q) / b where p = win rate, q = 1-p, b = R:R ratio
    // This gives optimal fraction of bankroll to risk for geometric growth maximization
    // Apply time decay to win rate (stale setups have lower probability)
    float p_base = INPUT_POS_WIN_RATE / 100  // Convert percentage to decimal
    
    // Calculate empirical win rate from learning history
    // OPTIMIZATION: Only recalculate when new trade was recorded (flag set in should_record block)
    float p_empirical = p_base
    if INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_SL and GLOBAL_learning.needsRecalc
        // Reset flag - we're about to recalculate
        GLOBAL_learning.needsRecalc := false
        
        // Phase 1 counters
        int wins = 0
        int losses = 0
        float total_mae = 0.0
        float total_mfe = 0.0
        int total_bars = 0
        int outcome_count = 0
        // Phase 2 counters: RSI divergence effectiveness
        int wins_with_div = 0
        int losses_with_div = 0
        int wins_without_div = 0
        int losses_without_div = 0
        // Phase 2 counters: Direction-specific win rates
        int wins_long = 0
        int losses_long = 0
        int wins_short = 0
        int losses_short = 0
        // Phase 2: Losing trade MAE (to find where SL should have been)
        float losing_mae_total = 0.0
        int losing_count = 0
        // Phase 3: TP mode comparison counters
        int cons_tp_wins = 0       // Setups where Conservative TP was hit (without SL hit)
        int cons_tp_total = 0      // Total setups with valid Conservative TP tracking
        int aggr_tp_wins = 0       // Setups where Aggressive TP was hit (without SL hit)
        int aggr_tp_total = 0      // Total setups with valid Aggressive TP tracking
        // Phase 3: Time decay learning (bars_to_outcome distribution)
        int early_wins = 0         // Wins within first TIME_DECAY_T2 bars
        int late_wins = 0          // Wins after TIME_DECAY_T3 bars
        // Phase 4: Regime detection and performance metrics
        int wins_high_vol = 0      // Wins in high volatility regime (>VOL_REGIME_HIGH_THRESH percentile)
        int losses_high_vol = 0    // Losses in high volatility regime
        int wins_low_vol = 0       // Wins in low volatility regime (<40 percentile)
        int losses_low_vol = 0     // Losses in low volatility regime
        float total_r_won = 0.0    // Total R won (1R per win = TP hit)
        float total_r_lost = 0.0   // Total R lost (1R per loss = SL hit)
        int consecutive_wins = 0   // Consecutive wins from most recent
        int consecutive_losses = 0 // Consecutive losses from most recent
        int max_win_streak = 0     // Maximum winning streak found
        int max_loss_streak = 0    // Maximum losing streak found
        int streak_state = 0       // 0=unknown, 1=in_win_streak, -1=in_loss_streak
        bool streak_frozen = false // Once streak is broken, stop updating current streak
        // Entropy regime counters
        int wins_ordered = 0       // Wins in ordered (low entropy) regime
        int losses_ordered = 0     // Losses in ordered regime
        int wins_disordered = 0    // Wins in disordered (high entropy) regime
        int losses_disordered = 0  // Losses in disordered regime
        // Hurst regime counters
        int wins_trend = 0         // Wins in trending (persistent) regime
        int losses_trend = 0       // Losses in trending regime
        int wins_meanrev = 0       // Wins in mean-reverting regime
        int losses_meanrev = 0     // Losses in mean-reverting regime
        int wins_random = 0        // Wins in random walk regime
        int losses_random = 0      // Losses in random walk regime
        // Z-score momentum counters
        int wins_strong_mom = 0    // Wins with strong momentum
        int losses_strong_mom = 0  // Losses with strong momentum
        int wins_weak_mom = 0      // Wins with weak momentum
        int losses_weak_mom = 0    // Losses with weak momentum
        
        // Iterate from NEWEST to OLDEST using CircularBuffer (get(0) = newest)
        int history_size = GLOBAL_setupHistory.size()
        int samples_to_check = math.min(INPUT_LEARNING_SAMPLES, history_size)
        for idx = 0 to samples_to_check - 1
            // CircularBuffer: idx=0 is newest, idx=samples_to_check-1 is oldest in window
            SetupRecord rec = GLOBAL_setupHistory.get(idx)
            // Skip if na (buffer not yet full at this index)
            if na(rec)
                continue
            // Setups where zone was never touched are "no trade" - don't affect win rate
            if not rec.hasFlag(FLAG_ZONE_TOUCHED)
                continue  // Skip - no entry, no trade
            
            if rec.hasFlag(FLAG_TP_HIT) and not rec.hasFlag(FLAG_SL_HIT)
                wins += 1
                // Aggregate winning trade metrics for MAE/MFE analysis
                total_mae += rec.max_adverse
                total_mfe += rec.max_favorable
                total_bars += rec.bars_to_outcome
                outcome_count += 1
                // Phase 2: RSI divergence stratification
                if rec.hasFlag(FLAG_HAD_RSI_DIV)
                    wins_with_div += 1
                else
                    wins_without_div += 1
                // Phase 2: Direction stratification
                if rec.hasFlag(FLAG_IS_LONG)
                    wins_long += 1
                else
                    wins_short += 1
                // Phase 3: Time decay learning (when do wins happen?)
                if rec.bars_to_outcome <= TIME_DECAY_T2
                    early_wins += 1
                else if rec.bars_to_outcome > TIME_DECAY_T3
                    late_wins += 1
                // Phase 4: Volatility regime stratification
                if rec.vol_percentile >= VOL_REGIME_HIGH_THRESH
                    wins_high_vol += 1
                else if rec.vol_percentile <= VOL_REGIME_LOW_THRESH
                    wins_low_vol += 1
                // Entropy regime stratification
                if rec.entropy_regime == ENTROPY_REGIME_ORDERED
                    wins_ordered += 1
                else if rec.entropy_regime == ENTROPY_REGIME_DISORDERED
                    wins_disordered += 1
                // Hurst regime stratification
                if rec.hurst_regime == HURST_REGIME_TREND
                    wins_trend += 1
                else if rec.hurst_regime == HURST_REGIME_MEANREV
                    wins_meanrev += 1
                else if rec.hurst_regime == HURST_REGIME_RANDOM
                    wins_random += 1
                // Z-score momentum stratification
                if rec.strong_momentum
                    wins_strong_mom += 1
                else
                    wins_weak_mom += 1
                // Phase 4: Profit factor tracking (1R per win since TP was hit)
                total_r_won += 1.0
                // Phase 4: Streak tracking (newest to oldest, freeze after break)
                if not streak_frozen
                    if streak_state == 0
                        streak_state := 1  // Start win streak
                        consecutive_wins := 1
                    else if streak_state == 1
                        consecutive_wins += 1  // Continue win streak
                    else
                        // Was in loss streak, this win breaks it
                        streak_frozen := true
            else if rec.hasFlag(FLAG_SL_HIT)
                losses += 1
                // Phase 2: Track losing trade MAE
                losing_mae_total += rec.max_adverse
                losing_count += 1
                // Phase 2: RSI divergence stratification
                if rec.hasFlag(FLAG_HAD_RSI_DIV)
                    losses_with_div += 1
                else
                    losses_without_div += 1
                // Phase 2: Direction stratification
                if rec.hasFlag(FLAG_IS_LONG)
                    losses_long += 1
                else
                    losses_short += 1
                // Phase 4: Volatility regime stratification
                if rec.vol_percentile >= VOL_REGIME_HIGH_THRESH
                    losses_high_vol += 1
                else if rec.vol_percentile <= VOL_REGIME_LOW_THRESH
                    losses_low_vol += 1
                // Entropy regime stratification
                if rec.entropy_regime == ENTROPY_REGIME_ORDERED
                    losses_ordered += 1
                else if rec.entropy_regime == ENTROPY_REGIME_DISORDERED
                    losses_disordered += 1
                // Hurst regime stratification
                if rec.hurst_regime == HURST_REGIME_TREND
                    losses_trend += 1
                else if rec.hurst_regime == HURST_REGIME_MEANREV
                    losses_meanrev += 1
                else if rec.hurst_regime == HURST_REGIME_RANDOM
                    losses_random += 1
                // Z-score momentum stratification
                if rec.strong_momentum
                    losses_strong_mom += 1
                else
                    losses_weak_mom += 1
                // Phase 4: Profit factor tracking (1R per loss since SL was hit)
                total_r_lost += 1.0
                // Phase 4: Streak tracking (newest to oldest, freeze after break)
                if not streak_frozen
                    if streak_state == 0
                        streak_state := -1  // Start loss streak
                        consecutive_losses := 1
                    else if streak_state == -1
                        consecutive_losses += 1  // Continue loss streak
                    else
                        // Was in win streak, this loss breaks it
                        streak_frozen := true
            
            // Phase 3: TP mode comparison (track both modes regardless of which was used)
            // Only count if SL wasn't hit first
            if not rec.hasFlag(FLAG_SL_HIT)
                cons_tp_total += 1
                aggr_tp_total += 1
                if rec.hasFlag(FLAG_CONS_TP_HIT)
                    cons_tp_wins += 1
                if rec.hasFlag(FLAG_AGGR_TP_HIT)
                    aggr_tp_wins += 1
        
        int total_outcomes = wins + losses
        if total_outcomes >= LEARN_MIN_SAMPLES_WR and total_outcomes > 0
            p_empirical := float(wins) / float(total_outcomes)
            // Clamp win rate to prevent Kelly from returning wild values during streaks
            GLOBAL_learning.winRate := math.max(0.30, math.min(0.70, p_empirical))
        
        // Extended learning: compute averages from winning trades
        if outcome_count >= LEARN_MIN_SAMPLES_MAE
            GLOBAL_learning.avgMae := total_mae / float(outcome_count)
            GLOBAL_learning.avgMfe := total_mfe / float(outcome_count)
            GLOBAL_learning.avgBars := int(float(total_bars) / float(outcome_count))
            // Optimal SL = average MAE of winners + SL_BUFFER_ATR ATR buffer
            // This allows for typical drawdowns while avoiding premature stopouts
            GLOBAL_learning.slMult := math.max(1.0, GLOBAL_learning.avgMae + SL_BUFFER_ATR)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 2: Advanced Learning Analytics
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // RSI Divergence Effectiveness: Compare win rates with/without divergence
        int total_with_div = wins_with_div + losses_with_div
        int total_without_div = wins_without_div + losses_without_div
        if total_with_div >= LEARN_MIN_SAMPLES_DIV
            GLOBAL_learning.wrWithDiv := float(wins_with_div) / float(total_with_div)
        if total_without_div >= LEARN_MIN_SAMPLES_DIV
            GLOBAL_learning.wrWithoutDiv := float(wins_without_div) / float(total_without_div)
        // Edge from divergence = difference in win rates
        if total_with_div >= LEARN_MIN_SAMPLES_DIV and total_without_div >= LEARN_MIN_SAMPLES_DIV
            GLOBAL_learning.divEdge := GLOBAL_learning.wrWithDiv - GLOBAL_learning.wrWithoutDiv
        
        // Direction-Specific Win Rates
        int total_long = wins_long + losses_long
        int total_short = wins_short + losses_short
        if total_long >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrLong := float(wins_long) / float(total_long)
        if total_short >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrShort := float(wins_short) / float(total_short)
        
        // Losing Trade MAE Analysis: Where should SL have been?
        if losing_count >= LEARN_MIN_SAMPLES_LOSING
            GLOBAL_learning.losingMae := losing_mae_total / float(losing_count)
        
        // Optimal Holding Period: Use average bars to outcome
        if outcome_count >= LEARN_MIN_SAMPLES_MAE
            GLOBAL_learning.optimalHold := GLOBAL_learning.avgBars
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 3: Advanced Learning - TP Mode, Decay Rate, RSI Weight
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // TP Mode Comparison: Which mode has better expected value?
        if cons_tp_total >= LEARN_MIN_SAMPLES_TP_COMP and aggr_tp_total >= LEARN_MIN_SAMPLES_TP_COMP
            GLOBAL_learning.consWr := float(cons_tp_wins) / float(cons_tp_total)
            GLOBAL_learning.aggrWr := float(aggr_tp_wins) / float(aggr_tp_total)
            // Calculate R:R for each mode (approximate using zone mid as entry)
            float cons_reward = math.abs(tp_conservative - mid_entry)
            float aggr_reward = math.abs(tp_aggressive - mid_entry)
            float cons_rr = risk > 0 ? cons_reward / risk : 0
            float aggr_rr = risk > 0 ? aggr_reward / risk : 0
            // Expected Value = (WinRate * Reward) - ((1-WinRate) * Risk) per unit risk
            GLOBAL_learning.consEv := GLOBAL_learning.consWr * cons_rr - (1 - GLOBAL_learning.consWr)
            GLOBAL_learning.aggrEv := GLOBAL_learning.aggrWr * aggr_rr - (1 - GLOBAL_learning.aggrWr)
            // Choose mode with higher EV
            GLOBAL_learning.tpAggressive := GLOBAL_learning.aggrEv > GLOBAL_learning.consEv
        
        // Time Decay Rate Learning: Based on when wins happen
        // If most wins are early, accelerate decay. If wins persist late, slow decay.
        int total_timed_wins = early_wins + late_wins
        if total_timed_wins >= LEARN_MIN_SAMPLES_TIME
            float early_ratio = float(early_wins) / float(total_timed_wins)
            // early_ratio > 0.6 means most wins are early â†’ accelerate decay (lower rate)
            // early_ratio < 0.4 means wins persist late â†’ slow decay (higher rate)
            // Map: early_ratio 0.3-0.7 â†’ decay_rate DECAY_RATE_MAX-DECAY_RATE_MIN
            GLOBAL_learning.decayRate := DEFAULT_DECAY_RATE + (0.5 - early_ratio) * DECAY_RATE_ADJUST
            // Clamp to reasonable range [DECAY_RATE_MIN, DECAY_RATE_MAX]
            GLOBAL_learning.decayRate := math.max(DECAY_RATE_MIN, math.min(DECAY_RATE_MAX, GLOBAL_learning.decayRate))
        
        // RSI Weight Learning: How much edge does divergence provide?
        // Weight = normalized edge (0 if no edge, 1 if huge edge)
        if total_with_div >= LEARN_MIN_SAMPLES_DIV and total_without_div >= LEARN_MIN_SAMPLES_DIV
            // GLOBAL_learning.divEdge is already computed above
            // Convert edge to weight: +20% edge â†’ weight 1.0, 0% edge â†’ weight 0.0
            GLOBAL_learning.rsiWeight := math.max(0, math.min(1.0, GLOBAL_learning.divEdge * 5))
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 4: Confidence Scoring & Regime-Aware Analytics
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // 4.1 Volatility Regime Win Rates
        int total_high_vol = wins_high_vol + losses_high_vol
        int total_low_vol = wins_low_vol + losses_low_vol
        if total_high_vol >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrHighVol := float(wins_high_vol) / float(total_high_vol)
        if total_low_vol >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrLowVol := float(wins_low_vol) / float(total_low_vol)
        
        // 4.1b Entropy Regime Win Rates
        int total_ordered = wins_ordered + losses_ordered
        int total_disordered = wins_disordered + losses_disordered
        if total_ordered >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrOrdered := float(wins_ordered) / float(total_ordered)
        if total_disordered >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrDisordered := float(wins_disordered) / float(total_disordered)
        // Entropy edge: ordered WR - disordered WR (positive = ordered is better)
        if total_ordered >= LEARN_MIN_SAMPLES_DIR and total_disordered >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.entropyEdge := GLOBAL_learning.wrOrdered - GLOBAL_learning.wrDisordered
        
        // 4.1c Hurst Regime Win Rates
        int total_trend = wins_trend + losses_trend
        int total_meanrev = wins_meanrev + losses_meanrev
        int total_random = wins_random + losses_random
        if total_trend >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrTrend := float(wins_trend) / float(total_trend)
        if total_meanrev >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrMeanRev := float(wins_meanrev) / float(total_meanrev)
        if total_random >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrRandom := float(wins_random) / float(total_random)
        // Hurst edge: trend WR - meanrev WR (positive = trend is better for this strategy)
        if total_trend >= LEARN_MIN_SAMPLES_DIR and total_meanrev >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.hurstEdge := GLOBAL_learning.wrTrend - GLOBAL_learning.wrMeanRev
        
        // 4.1d Z-Score Momentum Win Rates
        int total_strong_mom = wins_strong_mom + losses_strong_mom
        int total_weak_mom = wins_weak_mom + losses_weak_mom
        if total_strong_mom >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrStrongMom := float(wins_strong_mom) / float(total_strong_mom)
        if total_weak_mom >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.wrWeakMom := float(wins_weak_mom) / float(total_weak_mom)
        // Momentum edge: strong WR - weak WR (positive = strong momentum is better)
        if total_strong_mom >= LEARN_MIN_SAMPLES_DIR and total_weak_mom >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learning.momentumEdge := GLOBAL_learning.wrStrongMom - GLOBAL_learning.wrWeakMom
        
        // 4.2 Profit Factor: Total R won / Total R lost (>1 = profitable)
        if total_r_lost > 0
            GLOBAL_learning.profitFactor := total_r_won / total_r_lost
        else if total_r_won > 0
            GLOBAL_learning.profitFactor := 10.0  // Cap at 10 if no losses
        
        // 4.3 Expectancy: (WR Ã— avg win) - ((1-WR) Ã— avg loss) per trade
        if total_outcomes >= LEARN_MIN_SAMPLES_WR
            float avg_win_r = wins > 0 ? total_r_won / float(wins) : 0
            float avg_loss_r = losses > 0 ? total_r_lost / float(losses) : 0
            GLOBAL_learning.expectancy := (p_empirical * avg_win_r) - ((1 - p_empirical) * avg_loss_r)
        
        // 4.4 Streak Recording (consecutive from most recent + max historical)
        max_win_streak := math.max(max_win_streak, consecutive_wins)
        max_loss_streak := math.max(max_loss_streak, consecutive_losses)
        GLOBAL_learning.winStreak := consecutive_wins
        GLOBAL_learning.lossStreak := consecutive_losses
        
        // 4.5 Log-Return Performance Metrics
        if total_outcomes >= LEARN_MIN_SAMPLES_WR
            float avg_win_r = wins > 0 ? total_r_won / float(wins) : 0
            float avg_loss_r = losses > 0 ? total_r_lost / float(losses) : 0
            float sum_log_returns = 0.0
            float sum_log_sq = 0.0
            for i = 0 to samples_to_check - 1
                SetupRecord rec = GLOBAL_setupHistory.get(i)
                if not na(rec) and rec.hasFlag(MASK_CLOSED)
                    float trade_r = rec.hasFlag(FLAG_WON) ? avg_win_r : -avg_loss_r
                    float log_r = f_logReturn(1.0 + trade_r, 1.0)
                    sum_log_returns += log_r
                    sum_log_sq += log_r * log_r
            GLOBAL_learning.cumLogReturn := sum_log_returns
            GLOBAL_learning.avgLogReturn := sum_log_returns / float(total_outcomes)
            float variance = (sum_log_sq / float(total_outcomes)) - (GLOBAL_learning.avgLogReturn * GLOBAL_learning.avgLogReturn)
            GLOBAL_learning.logReturnStdev := math.sqrt(math.max(0, variance))
            if GLOBAL_learning.logReturnStdev > 0
                GLOBAL_learning.sharpeRatio := GLOBAL_learning.avgLogReturn / GLOBAL_learning.logReturnStdev
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 5: Bayesian Win-Rate & Sortino Ratio
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // 5.1 Bayesian Win-Rate (Beta-Binomial Model)
        if INPUT_BAYES_ENABLED
            // Update posterior: Î± = prior + wins, Î² = prior + losses
            GLOBAL_learning.bayesAlpha := INPUT_BAYES_ALPHA_PRIOR + float(wins)
            GLOBAL_learning.bayesBeta := INPUT_BAYES_BETA_PRIOR + float(losses)
            // Posterior mean: E[Î¸] = Î± / (Î± + Î²)
            GLOBAL_learning.bayesMean := f_betaMean(GLOBAL_learning.bayesAlpha, GLOBAL_learning.bayesBeta)
            // Lower credible bound (sample-size penalized)
            float percentile = 1.0 - INPUT_BAYES_CONFIDENCE
            GLOBAL_learning.bayesLowerBound := f_betaLowerBound(GLOBAL_learning.bayesAlpha, GLOBAL_learning.bayesBeta, percentile)
        
        // 5.2 Sortino Ratio (Downside-Risk Adjusted)
        if INPUT_SORTINO_ENABLED and total_outcomes >= LEARN_MIN_SAMPLES_WR
            // Build return array from SetupRecord log_return field
            array<float> trade_returns = array.new_float(0)
            float sum_returns = 0.0
            float sum_sq_downside = 0.0
            int downside_count = 0
            
            for i = 0 to samples_to_check - 1
                SetupRecord rec = GLOBAL_setupHistory.get(i)
                if not na(rec) and rec.hasFlag(FLAG_ZONE_TOUCHED)
                    float ret = rec.log_return
                    array.push(trade_returns, ret)
                    sum_returns += ret
                    // Track downside deviation (returns below MAR)
                    if ret < INPUT_SORTINO_MAR
                        float diff = ret - INPUT_SORTINO_MAR
                        sum_sq_downside += diff * diff
                        downside_count += 1
            
            int n_returns = array.size(trade_returns)
            if n_returns >= 2
                GLOBAL_learning.meanTradeReturn := sum_returns / float(n_returns)
                // Downside deviation = sqrt(mean of squared downside deviations over ALL trades)
                GLOBAL_learning.downsideDev := math.sqrt(sum_sq_downside / float(n_returns))
                // Sortino = (mean - rf) / downside_dev
                if GLOBAL_learning.downsideDev > 1e-10
                    GLOBAL_learning.sortinoRatio := GLOBAL_learning.meanTradeReturn / GLOBAL_learning.downsideDev
                else
                    // No downside: cap at max if profitable, 0 otherwise
                    GLOBAL_learning.sortinoRatio := GLOBAL_learning.meanTradeReturn > 0 ? SORTINO_MAX_CAP : 0.0
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 6: Monte Carlo Permutation Test
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // 6.1 Monte Carlo Permutation Test for Timing Edge Validation
        if INPUT_MC_ENABLED and total_outcomes >= MC_MIN_TRADES
            array<float> mc_returns = array.new_float(0)
            for i = 0 to samples_to_check - 1
                SetupRecord rec = GLOBAL_setupHistory.get(i)
                if not na(rec) and rec.hasFlag(FLAG_ZONE_TOUCHED)
                    array.push(mc_returns, rec.log_return)
            
            if array.size(mc_returns) >= MC_MIN_TRADES
                [orig_dd, mean_shuf_dd, p_val, sims] = f_monteCarloDD(mc_returns, INPUT_MC_SIMS, MC_SEED_BASE)
                GLOBAL_learning.mcOriginalDD := orig_dd
                GLOBAL_learning.mcMeanShuffledDD := mean_shuf_dd
                GLOBAL_learning.mcPValue := p_val
                GLOBAL_learning.mcSimsRun := sims
                GLOBAL_learning.mcSignificant := p_val < INPUT_MC_PVALUE
        
        // 4.6 Learning Health Check
        int bars_since_outcome = bar_index - GLOBAL_learning.lastOutcomeBar
        bool is_stale = bars_since_outcome > HEALTH_STALE_BARS and GLOBAL_learning.lastOutcomeBar > 0
        // Sanity check: WR should be HEALTH_WR_MIN-HEALTH_WR_MAX, profit factor > HEALTH_PF_MIN
        bool sane_wr = GLOBAL_learning.winRate >= HEALTH_WR_MIN and GLOBAL_learning.winRate <= HEALTH_WR_MAX
        bool sane_pf = GLOBAL_learning.profitFactor >= HEALTH_PF_MIN or GLOBAL_learning.profitFactor == 0.0
        GLOBAL_learning.isHealthy := not is_stale and sane_wr and sane_pf
        
        // 4.6 Unified Confidence Score (0-100) - Computed at analysis time
        // NOTE: Direction alignment and time decay will be recalculated in display section
        //       using current bar context. Here we compute the "base" confidence from learning data.
        // Components: WR (35%), RSI Edge (20%), Profit Factor (15%), Streak Status (15%), Health (15%)
        float conf_base = 0.0
        // WR Component: CONF_WR_WEIGHT% weight - map CONF_WR_MIN_MAP-CONF_WR_MAX_MAP â†’ 0-35
        conf_base += math.max(0, math.min(CONF_WR_WEIGHT, (GLOBAL_learning.winRate - CONF_WR_MIN_MAP) * 70))
        // RSI Edge: CONF_RSI_WEIGHT% weight - map 0-0.2 edge â†’ 0-20
        conf_base += math.max(0, math.min(CONF_RSI_WEIGHT, GLOBAL_learning.divEdge * 100))
        // Profit Factor: CONF_PF_WEIGHT% weight - map CONF_PF_MIN_MAP-CONF_PF_MAX_MAP â†’ 0-15
        float pf_norm = math.max(0, math.min(CONF_PF_WEIGHT, (GLOBAL_learning.profitFactor - CONF_PF_MIN_MAP) * 10))
        conf_base += pf_norm
        // Streak Penalty: -15% if on losing streak of STREAK_LOSS_PENALTY_THRESH+, bonus for win streak
        float streak_adj = 0.0
        if consecutive_losses >= STREAK_LOSS_PENALTY_THRESH
            streak_adj := -math.min(STREAK_PENALTY_MAX, (consecutive_losses - STREAK_LOSS_PENALTY_BASE) * STREAK_PENALTY_RATE)
        else if consecutive_wins >= STREAK_WIN_BONUS_THRESH
            streak_adj := math.min(STREAK_BONUS_MAX, (consecutive_wins - STREAK_WIN_BONUS_BASE) * STREAK_BONUS_RATE)  // Smaller bonus than penalty
        conf_base += streak_adj
        // Health Component: CONF_HEALTH_WEIGHT% - full points if healthy, 0 if not
        bool is_healthy = not is_stale and sane_wr and sane_pf
        conf_base += is_healthy ? CONF_HEALTH_WEIGHT : 0
        // Final base confidence clamped to 0-100 (direction/decay adjustments done per-bar)
        GLOBAL_learning.confidence := math.max(0, math.min(100, conf_base))
    
    // Use empirical win rate if learning enabled and sufficient data, otherwise use input
    // Phase 2: Use direction-specific win rate for more accurate Kelly sizing
    // NOTE: GLOBAL_learning.winRate is already clamped to 0.30-0.70 above
    float p_effective = p_base
    if INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_SL
        // Use direction-specific win rate if we have enough samples per direction
        // Also clamp direction-specific rates to prevent wild Kelly values
        bool has_dir_data = (is_long_setup and GLOBAL_learning.wrLong != DEFAULT_WIN_RATE) or (not is_long_setup and GLOBAL_learning.wrShort != DEFAULT_WIN_RATE)
        if has_dir_data
            float raw_dir_wr = is_long_setup ? GLOBAL_learning.wrLong : GLOBAL_learning.wrShort
            p_effective := math.max(0.30, math.min(0.70, raw_dir_wr))
        else
            // Use clamped GLOBAL_learning.winRate (already clamped during calculation)
            p_effective := na(GLOBAL_learning.winRate) ? p_base : GLOBAL_learning.winRate
    
    // Phase 4: Apply regime-specific win rate adjustment based on current volatility
    // If we have enough regime-specific data, blend towards the regime WR
    float p_regime_adjusted = p_effective
    float current_regime_percentile = GLOBAL_regime.atrPercentile
    bool is_high_vol_regime = current_regime_percentile >= VOL_REGIME_HIGH_THRESH
    bool is_low_vol_regime = current_regime_percentile <= VOL_REGIME_LOW_THRESH
    bool has_regime_data = INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_regime_data
        if is_high_vol_regime and GLOBAL_learning.wrHighVol != DEFAULT_WIN_RATE
            // Blend: 70% direction WR + 30% regime WR for stability
            p_regime_adjusted := p_effective * 0.7 + GLOBAL_learning.wrHighVol * 0.3
        else if is_low_vol_regime and GLOBAL_learning.wrLowVol != DEFAULT_WIN_RATE
            p_regime_adjusted := p_effective * 0.7 + GLOBAL_learning.wrLowVol * 0.3
    
    // Phase 3: Apply learned RSI weight to boost probability when divergence is present
    // This adjusts the effective win rate based on the edge RSI divergence provides
    float p_rsi_adjusted = p_regime_adjusted
    bool has_learned_rsi_weight = INPUT_LEARN_RSI_WEIGHT and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_learned_rsi_weight and rsi_confirm and GLOBAL_learning.rsiWeight > 0
        // Boost win rate by learned edge: p + (edge * weight * (1-p)) to stay bounded
        float boost = GLOBAL_learning.divEdge * GLOBAL_learning.rsiWeight * (1 - p_regime_adjusted)
        p_rsi_adjusted := math.min(0.95, p_regime_adjusted + boost)  // Cap at 95%
    
    float p = p_rsi_adjusted * time_decay  // Time-decayed win probability
    float q = 1 - p
    float b = rr_ratio
    float kelly_full = b > 0 ? (p * b - q) / b : 0  // Full Kelly fraction
    
    // Phase 4: Apply confidence-based Kelly scaling
    // High confidence (>70) = full fraction, low confidence (<40) = reduced fraction
    float conf_scale = 1.0
    bool has_conf_data = INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_conf_data
        // Map confidence 30-80 â†’ scale 0.5-1.0
        conf_scale := math.max(0.5, math.min(1.0, (GLOBAL_learning.confidence - 30) / 50))
    
    float kelly_adj = math.max(0, kelly_full) * INPUT_POS_KELLY_FRAC * conf_scale  // Apply fractional Kelly + confidence
    float kelly_pct = math.min(kelly_adj * 100, 25)  // Cap at 25% max risk per trade
    
    // Expected Value (EV) Calculation
    // EV = (P_win Ã— Reward) - (P_loss Ã— Risk) per unit risked
    float ev_absolute = (p * reward) - (q * risk)  // Absolute EV in price units (time-decay adjusted)
    float ev_per_risk = risk > 0 ? ev_absolute / risk : 0  // EV per unit of risk (normalized)
    float ev_percent = ev_per_risk * 100  // As percentage
    
    // Confidence interval using standard error approximation
    // Standard deviation of Bernoulli outcome scaled by payoff
    float variance = p * math.pow(reward, 2) + q * math.pow(risk, 2) - math.pow(ev_absolute, 2)
    float std_dev = math.sqrt(math.max(0, variance))
    // 95% confidence interval (1.96 standard errors) assuming ~20 trade sample
    float margin_of_error = 1.96 * std_dev / math.sqrt(20)
    float ev_lower_95 = ev_absolute - margin_of_error
    bool ev_significant = ev_lower_95 > 0  // True if 95% confident EV is positive
    
    // EV quality indicator
    string ev_grade = ev_percent <= 0 ? "âˆ’EV" : ev_percent < 10 ? "marginal" : ev_percent < 25 ? "decent" : ev_percent < 50 ? "strong" : "exceptional"
    string ev_conf = ev_significant ? "âœ“" : "?"
    
    // Kelly edge quality indicator
    string kelly_grade = kelly_pct <= 0 ? "NO EDGE" : kelly_pct < 5 ? "weak" : kelly_pct < 10 ? "decent" : kelly_pct < 15 ? "strong" : "excellent"
    
    // Confluence indicators for display
    string div_icon = rsi_confirm ? " âœ“DIV" : ""
    string vol_icon = vol_confirm ? " âœ“VOL" : ""
    
    // Status text (include time decay status)
    string invalid_reason = sl_breached ? TEXT_SL_HIT : (zone_expired ? TEXT_EXPIRED : "")
    string status = is_invalid ? invalid_reason : (in_zone ? TEXT_ACTIVE + div_icon + vol_icon + time_status : time_status)
    string kelly_text = kelly_pct > 0 ? "\nKelly: " + str.tostring(kelly_pct, "#.#") + "% (" + kelly_grade + ")" : "\nKelly: " + kelly_grade
    string ev_text = "\nEV: " + str.tostring(ev_percent, "#.#") + "% " + ev_conf + " (" + ev_grade + ")"
    
    // Learning stats for display
    string learn_text = ""
    if INPUT_LEARNING_ENABLED
        int sample_count = GLOBAL_setupHistory.size()
        if sample_count >= 10
            learn_text := "\nğŸ“Š " + str.tostring(sample_count) + " samples"
            if GLOBAL_learning.zoneBuffer > 0
                learn_text += " | Buf:+" + str.tostring(GLOBAL_learning.zoneBuffer, "#.##") + "%"
            if sample_count >= 20
                learn_text += " | WR:" + str.tostring(GLOBAL_learning.winRate * 100, "#.#") + "%"
                // Extended metrics display (Phase 1)
                if GLOBAL_learning.avgMae > 0
                    learn_text += "\n   MAE:" + str.tostring(GLOBAL_learning.avgMae, "#.#") + "R"
                    learn_text += " MFE:" + str.tostring(GLOBAL_learning.avgMfe, "#.#") + "R"
                    learn_text += " SL*:" + str.tostring(GLOBAL_learning.slMult, "#.#") + "x"
                if GLOBAL_learning.avgBars > 0
                    learn_text += " Ï„:" + str.tostring(GLOBAL_learning.avgBars) + "bars"
                // Phase 2: Advanced analytics display
                // RSI Divergence Edge
                if GLOBAL_learning.divEdge != 0
                    string div_sign = GLOBAL_learning.divEdge > 0 ? "+" : ""
                    learn_text += "\n   DIV:" + div_sign + str.tostring(GLOBAL_learning.divEdge * 100, "#.#") + "% edge"
                // Direction-specific win rates (show if significant difference)
                float dir_diff = math.abs(GLOBAL_learning.wrLong - GLOBAL_learning.wrShort)
                if dir_diff > 0.05  // >5% difference
                    learn_text += "\n   L:" + str.tostring(GLOBAL_learning.wrLong * 100, "#") + "% S:" + str.tostring(GLOBAL_learning.wrShort * 100, "#") + "%"
                // Losing MAE (informative: where trades went wrong)
                if GLOBAL_learning.losingMae > 0
                    learn_text += " âœ—MAE:" + str.tostring(GLOBAL_learning.losingMae, "#.#") + "R"
                // Phase 3: Show learned parameters
                if sample_count >= INPUT_LEARN_MIN_SAMPLES
                    string p3_text = ""
                    // Show learned TP mode recommendation
                    if INPUT_LEARN_TP and (GLOBAL_learning.consEv != 0 or GLOBAL_learning.aggrEv != 0)
                        string tp_rec = GLOBAL_learning.tpAggressive ? "Aggr" : "Cons"
                        p3_text += "\n   ğŸ§  TP:" + tp_rec + "âœ“"
                    // Show learned decay rate if different from default
                    if INPUT_LEARN_DECAY and math.abs(GLOBAL_learning.decayRate - DEFAULT_DECAY_RATE) > 0.02
                        p3_text += " Decay:" + str.tostring(GLOBAL_learning.decayRate, "#.##")
                    // Show learned RSI weight if significant
                    if INPUT_LEARN_RSI_WEIGHT and GLOBAL_learning.rsiWeight > 0.1
                        p3_text += " RSIwt:" + str.tostring(GLOBAL_learning.rsiWeight, "#.#")
                    if str.length(p3_text) > 0
                        learn_text += p3_text
                    // Phase 4: Confidence scoring and regime analytics
                    string p4_text = ""
                    // Calculate per-bar adjusted confidence (add direction alignment + time decay + regime)
                    float adjusted_conf = GLOBAL_learning.confidence
                    // Direction Alignment Adjustment: Â±10% based on current direction's relative WR
                    float dir_wr = is_long_setup ? GLOBAL_learning.wrLong : GLOBAL_learning.wrShort
                    float opp_wr = is_long_setup ? GLOBAL_learning.wrShort : GLOBAL_learning.wrLong
                    float dir_edge = dir_wr - opp_wr
                    adjusted_conf += dir_edge * 50  // Â±10% edge â†’ Â±5 points
                    // Time Decay Adjustment: Â±10% (fresh setup = +10, expired = -10)
                    adjusted_conf += (time_decay - 0.5) * 20  // 1.0â†’+10, 0.5â†’0, 0â†’-10
                    // Regime Adjustment: Â±5% based on current vol regime performance
                    float regime_wr = current_regime_percentile >= VOL_REGIME_HIGH_THRESH ? GLOBAL_learning.wrHighVol : 
                                      current_regime_percentile <= VOL_REGIME_LOW_THRESH ? GLOBAL_learning.wrLowVol : GLOBAL_learning.winRate
                    if regime_wr != DEFAULT_WIN_RATE  // Only if we have regime data
                        float regime_edge = regime_wr - GLOBAL_learning.winRate
                        adjusted_conf += regime_edge * 50  // Â±10% edge â†’ Â±5 points
                    adjusted_conf := math.max(0, math.min(100, adjusted_conf))
                    // Unified Confidence Score with grade
                    string conf_grade = adjusted_conf < CONF_GRADE_D_THRESH ? "D" : adjusted_conf < CONF_GRADE_C_THRESH ? "C" : adjusted_conf < CONF_GRADE_B_THRESH ? "B" : adjusted_conf < CONF_GRADE_A_THRESH ? "A" : "A+"
                    string health_icon = GLOBAL_learning.isHealthy ? "âœ“" : "âš "
                    p4_text += "\n   ğŸ¯ Conf:" + str.tostring(adjusted_conf, "#") + "% " + conf_grade + " " + health_icon
                    // Profit Factor (only show if meaningful)
                    if GLOBAL_learning.profitFactor > 0
                        string pf_rating = GLOBAL_learning.profitFactor < 1.0 ? "âˆ’" : GLOBAL_learning.profitFactor < 1.5 ? "â—‹" : GLOBAL_learning.profitFactor < 2.0 ? "+" : "++"
                        p4_text += "\n   PF:" + str.tostring(GLOBAL_learning.profitFactor, "#.##") + pf_rating
                    // Expectancy per trade
                    if GLOBAL_learning.expectancy != 0
                        string exp_sign = GLOBAL_learning.expectancy > 0 ? "+" : ""
                        p4_text += " Exp:" + exp_sign + str.tostring(GLOBAL_learning.expectancy, "#.##") + "R"
                    // Regime indicator: Show if we're in favorable/unfavorable vol regime (use real-time percentile)
                    if current_regime_percentile >= VOL_REGIME_HIGH_THRESH and GLOBAL_learning.wrHighVol != DEFAULT_WIN_RATE
                        string vol_edge = GLOBAL_learning.wrHighVol > GLOBAL_learning.winRate ? "â–²" : GLOBAL_learning.wrHighVol < GLOBAL_learning.winRate ? "â–¼" : "="
                        p4_text += "\n   âš¡HighVol" + vol_edge + " " + str.tostring(GLOBAL_learning.wrHighVol * 100, "#") + "%"
                    else if current_regime_percentile <= VOL_REGIME_LOW_THRESH and GLOBAL_learning.wrLowVol != DEFAULT_WIN_RATE
                        string vol_edge = GLOBAL_learning.wrLowVol > GLOBAL_learning.winRate ? "â–²" : GLOBAL_learning.wrLowVol < GLOBAL_learning.winRate ? "â–¼" : "="
                        p4_text += "\n   ğŸŒŠ LowVol" + vol_edge + " " + str.tostring(GLOBAL_learning.wrLowVol * 100, "#") + "%"
                    // Sharpe Ratio (risk-adjusted return)
                    if GLOBAL_learning.sharpeRatio != 0
                        string sr_rating = GLOBAL_learning.sharpeRatio < 0 ? "âˆ’" : GLOBAL_learning.sharpeRatio < 1 ? "â—‹" : GLOBAL_learning.sharpeRatio < 2 ? "+" : "++"
                        p4_text += "\n   SR:" + str.tostring(GLOBAL_learning.sharpeRatio, "#.##") + sr_rating
                    // Streak warning (show win streak as positive indicator too)
                    if GLOBAL_learning.lossStreak >= STREAK_LOSS_PENALTY_THRESH
                        p4_text += "\n   âš  " + str.tostring(GLOBAL_learning.lossStreak) + "L streak"
                    else if GLOBAL_learning.winStreak >= STREAK_WIN_BONUS_THRESH
                        p4_text += "\n   ğŸ”¥ " + str.tostring(GLOBAL_learning.winStreak) + "W streak"
                    if str.length(p4_text) > 0
                        learn_text += p4_text
        else
            learn_text := "\nğŸ“Š Learning... (" + str.tostring(sample_count) + "/" + str.tostring(INPUT_LEARNING_SAMPLES) + ")"
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TASK 4: Status Label - Distinguish Confirmed vs Projected
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Use stored values when setup is active for display consistency with tracking
    // BUT show current calculated values (with learning) so user sees adjusted prices
    float display_tp_text = tp_price  // Always show current calculation with learning
    float display_sl_text = sl_price  // Always show current calculation with learning
    // Use current calculation for display (projection shows current direction)
    bool display_is_long = isProjection ? is_long_setup : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.hasFlag(FLAG_IS_LONG) : is_long_setup)
    
    // Status prefix: clearly distinguish between Confirmed Active and Projected trades
    // âš¡PROJ = Projection (tentative, not recorded to learning)
    // âœ“ACTIVE = Confirmed Active (tracked, will be recorded)
    string trade_state_indicator = isProjection ? " âš¡PROJ" : (not na(GLOBAL_activeTrade.setup_bar) ? " âœ“ACTIVE" : "")
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BACKTEST STATS DISPLAY - Show optimization results on the dashboard
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    string backtest_text = ""
    if GLOBAL_backtest.stats.statsReady and GLOBAL_backtest.stats.totalTrades > 0
        // Low confidence warning
        string conf_warning = GLOBAL_backtest.stats.lowConfidence ? " âš ï¸LOW" : ""
        backtest_text := "\nğŸ“ˆ Backtested " + str.tostring(GLOBAL_backtest.stats.totalTrades) + " Trades: " + str.tostring(math.round(GLOBAL_backtest.stats.winRate * 100)) + "% WR" + conf_warning
        // Show Smart SL if available
        if GLOBAL_backtest.stats.smartSlOffset > 0
            float smart_sl_price = display_is_long ? mid_entry - GLOBAL_backtest.stats.smartSlOffset : mid_entry + GLOBAL_backtest.stats.smartSlOffset
            backtest_text += "\n   ğŸ¯ Smart SL: " + str.tostring(smart_sl_price, format.mintick)
    else if GLOBAL_backtest.stats.totalTrades == 0
        backtest_text := "\nğŸ“ˆ Backtesting... (0 trades)"
    
    string pos_text = (display_is_long ? TEXT_LONG : TEXT_SHORT) + TEXT_SETUP + trade_state_indicator + status + "\nğŸ¯ TP: " + str.tostring(display_tp_text, format.mintick) + "\nğŸ›‘ SL: " + str.tostring(display_sl_text, format.mintick) + "\nâš–ï¸ R:R " + str.tostring(rr_ratio, "#.##") + ev_text + kelly_text + learn_text + backtest_text
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LEARNING ENGINE: Record CONFIRMED setup outcome on pivot change (NEVER projections)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Record previous CONFIRMED setup BEFORE resetting state (order matters!)
    // CRITICAL: Only record from GLOBAL_activeTrade - NEVER from projection data
    bool should_record = INPUT_LEARNING_ENABLED and GLOBAL_zigzag.changed and not na(GLOBAL_activeTrade.setup_bar)
    if should_record
        // Calculate bars to outcome (0 if neither SL nor TP hit)
        int bars_to_out = GLOBAL_activeTrade.hasAny(MASK_OUTCOME) and not na(GLOBAL_activeTrade.entry_bar) ? 
                          (bar_index - GLOBAL_activeTrade.entry_bar) : 0
        
        // Compute trade log return for Sortino calculation
        // Win: positive R (TP hit), Loss: negative R (SL hit)
        float trade_entry = nz(GLOBAL_activeTrade.entry_price, (GLOBAL_activeTrade.zone_top + GLOBAL_activeTrade.zone_bottom) / 2)
        float trade_log_ret = 0.0
        if GLOBAL_activeTrade.hasFlag(FLAG_TP_HIT) and not GLOBAL_activeTrade.hasFlag(FLAG_SL_HIT)
            // Win: log return from entry to TP
            trade_log_ret := f_logReturn(GLOBAL_activeTrade.tp_price, trade_entry)
            // Ensure sign matches direction (longs profit when price rises, shorts when price falls)
            if not GLOBAL_activeTrade.hasFlag(FLAG_IS_LONG)
                trade_log_ret := -trade_log_ret
        else if GLOBAL_activeTrade.hasFlag(FLAG_SL_HIT)
            // Loss: log return from entry to SL (negative)
            trade_log_ret := f_logReturn(GLOBAL_activeTrade.sl_price, trade_entry)
            if not GLOBAL_activeTrade.hasFlag(FLAG_IS_LONG)
                trade_log_ret := -trade_log_ret
        
        // Record the previous CONFIRMED setup's outcome before it changes
        SetupRecord completed_setup = SetupRecord.new(
            GLOBAL_activeTrade.setup_bar,           // setup_bar
            GLOBAL_activeTrade.state_mask,          // state_mask (copy all flags directly)
            GLOBAL_activeTrade.zone_top,            // zone_top
            GLOBAL_activeTrade.zone_bottom,         // zone_bottom
            GLOBAL_activeTrade.sl_price,            // sl_level
            GLOBAL_activeTrade.tp_price,            // tp_level
            GLOBAL_activeTrade.min_distance,        // closest_approach
            bars_to_out,                            // bars_to_outcome
            GLOBAL_activeTrade.max_adverse,         // max_adverse (ATR units)
            GLOBAL_activeTrade.max_favorable,       // max_favorable (ATR units)
            trade_entry,                            // entry_price
            nz(GLOBAL_activeTrade.atr_at_setup, 1.0),        // atr_at_setup
            nz(GLOBAL_activeTrade.rsi_at_entry, 50.0),       // rsi_at_entry
            GLOBAL_activeTrade.tp_cons,             // tp_conservative
            GLOBAL_activeTrade.tp_aggr,             // tp_aggressive
            GLOBAL_activeTrade.vol_percentile,      // vol_percentile
            GLOBAL_regime.entropyRegime,            // entropy_regime
            GLOBAL_regime.entropyNorm,              // entropy_norm
            GLOBAL_regime.hurstRegime,              // hurst_regime
            GLOBAL_regime.hurst,                    // hurst_value
            GLOBAL_regime.zscore,                   // zscore_value
            GLOBAL_regime.strongMomentum,           // strong_momentum
            trade_log_ret                           // log_return
        )
        
        // Phase 4: Record last outcome bar for staleness detection
        GLOBAL_learning.lastOutcomeBar := bar_index
        
        // Add to circular buffer (O(1) operation, auto-overwrites oldest when full)
        GLOBAL_setupHistory.push(completed_setup)
        
        // OPTIMIZATION: Set flag to trigger learning recalculation (only on new trade)
        GLOBAL_learning.needsRecalc := true
        
        // DEBUG: Log when setup is recorded (using state_mask flags)
        log.info("RECORDED: bar={0}, mask={1}, samples={2}, long={3}, touched={4}, sl={5}, tp={6}, won={7}", 
                 GLOBAL_activeTrade.setup_bar, GLOBAL_activeTrade.state_mask, GLOBAL_setupHistory.size(),
                 GLOBAL_activeTrade.hasFlag(FLAG_IS_LONG),
                 GLOBAL_activeTrade.hasFlag(FLAG_ZONE_TOUCHED),
                 GLOBAL_activeTrade.hasFlag(FLAG_SL_HIT),
                 GLOBAL_activeTrade.hasFlag(FLAG_TP_HIT),
                 GLOBAL_activeTrade.hasFlag(FLAG_WON))
    
    // Initialize CONFIRMED trade tracking - ONLY reset on GLOBAL_zigzag.changed (never for projections)
    // This ensures Learning Engine data is ONLY from confirmed ZigZag pivots
    if GLOBAL_zigzag.changed
        // Use CONFIRMED pivot (GLOBAL_cachedPivots.iMidPivot), NOT effective pivot (which includes projections)
        GLOBAL_activeTrade.setup_bar := GLOBAL_cachedPivots.iMidPivot
        // TASK 3 FIX: Store creation_bar = current bar_index for proper time decay
        // Confirmed pivots are detected pivotLength bars AFTER they occur
        // So GLOBAL_cachedPivots.iMidPivot is typically bar_index - pivotLength
        // creation_bar tracks when WE created the setup, not when the pivot occurred
        GLOBAL_activeTrade.creation_bar := bar_index
        // Build initial state_mask: direction + TP mode (using arithmetic for raw int)
        int new_state = (is_long_setup ? FLAG_IS_LONG : 0) + (use_aggressive_tp ? FLAG_TP_AGGRESSIVE : 0)
        GLOBAL_activeTrade.state_mask := new_state
        GLOBAL_activeTrade.zone_top := adjusted_box_top
        GLOBAL_activeTrade.zone_bottom := adjusted_box_bottom
        GLOBAL_activeTrade.sl_price := sl_price
        GLOBAL_activeTrade.tp_price := tp_price
        GLOBAL_activeTrade.tp_cons := tp_conservative
        GLOBAL_activeTrade.tp_aggr := tp_aggressive
        GLOBAL_activeTrade.min_distance := DEFAULT_MIN_DISTANCE
        // Extended tracking reset (Phase 1)
        GLOBAL_activeTrade.entry_bar := na
        GLOBAL_activeTrade.entry_price := na
        GLOBAL_activeTrade.max_adverse := 0.0
        GLOBAL_activeTrade.max_favorable := 0.0
        GLOBAL_activeTrade.atr_at_setup := nz(GLOBAL_regime.rawAtr, 1.0)
        GLOBAL_activeTrade.rsi_at_entry := na
        // Phase 4: Regime tracking reset
        GLOBAL_activeTrade.vol_percentile := atr_percentile  // Capture current volatility regime

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TASK 4: Visual Styling - Confirmed vs Projection
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIRMED (GLOBAL_activeTrade valid): Solid/dotted lines with full opacity
    // PROJECTION (tentative preview):    Dashed lines with higher transparency
    // This provides clear visual distinction between actionable vs tentative setups
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Determine which state we're displaying
    bool hasConfirmedTrade = not na(GLOBAL_activeTrade.setup_bar)
    bool showingProjection = isProjection
    
    // Visual style settings based on state
    // Confirmed: dotted (standard), Projection: dashed (tentative)
    var string box_style = line.style_dotted
    box_style := showingProjection ? line.style_dotted : line.style_solid
    
    // Transparency: Scale by INPUT_PROJ_SENSITIVITY for projections
    // Lower sensitivity (more stable) = more opaque. Higher sensitivity (more volatile) = more transparent.
    // Formula: 80 - (sensitivity * 40) â†’ at 0.5 sens = 60 trans, at 1.0 sens = 40 trans, at 0.1 sens = 76 trans
    int sl_tp_transparency = showingProjection ? int(80 - INPUT_PROJ_SENSITIVITY * 40) : 5
    color sl_line_col = is_invalid ? color.new(COLOR_GRAY, 60) : color.new(COLOR_RED, sl_tp_transparency)
    color tp_line_col = is_invalid ? color.new(COLOR_GRAY, 60) : color.new(COLOR_GREEN, sl_tp_transparency)
    
    // Display current calculated values (with learning) for SL/TP lines
    // Zone boundaries: for projection mode, use current calculated; otherwise use confirmed trade values
    float display_sl = sl_price  // Show learning-adjusted SL
    float display_tp = tp_price  // Show learning-adjusted TP
    float display_zone_top = isProjection ? adjusted_box_top : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.zone_top : adjusted_box_top)
    float display_zone_bottom = isProjection ? adjusted_box_bottom : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.zone_bottom : adjusted_box_bottom)
    
    // Calculate Smart SL price based on backtest optimization
    float smart_sl_price = na
    bool show_smart_sl = GLOBAL_backtest.stats.statsReady and GLOBAL_backtest.stats.smartSlOffset > 0
    if show_smart_sl
        smart_sl_price := is_long_setup ? mid_entry - GLOBAL_backtest.stats.smartSlOffset : mid_entry + GLOBAL_backtest.stats.smartSlOffset
    color smart_sl_col = color.new(color.orange, 20)  // Orange for Smart SL (distinct from red structural SL)
    
    // Track projection state changes for object recreation
    var bool wasProjection = false
    bool projectionStateChanged = isProjection != wasProjection
    wasProjection := isProjection
    
    // Determine line style: solid for confirmed, dotted for projection
    string lineStyleStr = showingProjection ? "dotted" : "solid"
    
    // Calculate Smart SL for method calls
    float smartSlForMethod = show_smart_sl ? smart_sl_price : na
    
    // On pivot change OR projection state change, delete old objects and create fresh ones
    bool needsRecreate = GLOBAL_zigzag.changed or projectionStateChanged or (isProjection and (proj_tentative_high or proj_tentative_low))
    if needsRecreate
        GLOBAL_posVisual.deleteAll()
        GLOBAL_posVisual.create(display_zone_top, display_zone_bottom, display_sl, display_tp, mid_entry, pos_text, bg_col, border_col, sl_line_col, tp_line_col, lineStyleStr, smartSlForMethod, smart_sl_col, COLOR_FG_MAIN)
    else if not GLOBAL_posVisual.exists()
        // First time creation (no pivot change yet) - always dotted
        GLOBAL_posVisual.create(display_zone_top, display_zone_bottom, display_sl, display_tp, mid_entry, pos_text, bg_col, border_col, sl_line_col, tp_line_col, "dotted", smartSlForMethod, smart_sl_col, COLOR_FG_MAIN)
    else
        // Update existing objects with current values (dynamic learning adjustments)
        GLOBAL_posVisual.update(display_zone_top, display_zone_bottom, display_sl, display_tp, mid_entry, pos_text, bg_col, border_col, sl_line_col, tp_line_col, smartSlForMethod, smart_sl_col)
    
    // Populate global alert state for use in ALERTS section
    bool as_zone_touched = not na(GLOBAL_activeTrade.setup_bar) and GLOBAL_activeTrade.hasFlag(FLAG_ZONE_TOUCHED)
    bool as_sl_hit = not na(GLOBAL_activeTrade.setup_bar) and GLOBAL_activeTrade.hasFlag(FLAG_SL_HIT)
    bool as_tp_hit = not na(GLOBAL_activeTrade.setup_bar) and GLOBAL_activeTrade.hasFlag(FLAG_TP_HIT)
    int as_creation_bar = isProjection ? bar_index : nz(GLOBAL_activeTrade.creation_bar, bar_index)
    GLOBAL_alertState.populate(
        isProjection, is_long_setup, as_zone_touched, as_sl_hit, as_tp_hit,
        in_zone, zone_entry, use_aggressive_tp, zone_expired,
        box_top, box_bottom, adjusted_box_top, adjusted_box_bottom, adaptive_buffer,
        nz(GLOBAL_activeTrade.min_distance, DEFAULT_MIN_DISTANCE),
        sl_price, tp_price, tp_conservative, tp_aggressive, effective_sl_mult, current_atr,
        smart_sl_price, as_creation_bar, bars_since_creation, time_phase, decay_rate)
    
    // Alert on zone entry with full JSON context
    if zone_entry and INPUT_ALERT_ENABLED
        string entry_msg = f_getAlertMessageFull(ALERT_ID_ENTRY, "zone_entry",
            GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
            GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
            GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
            GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
            GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
            GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
            GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
            GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
            GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
        alert(entry_msg, alert.freq_once_per_bar)

// AddOns
plotchar(INPUT_SHOW_VOL_SPIKE and nzVolume != 0 ? exhaustVol : false, 'Exhaustion Bar', 'ğŸš¦', location.abovebar, size=size.tiny, display = display.pane)
plotchar(INPUT_SHOW_HIGH_ATR ? highVolatility : false, 'High Volatile Bar', 'âš¡', location.belowbar, size=size.tiny, display = display.pane)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATUS LINE VALUES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

v_start = GLOBAL_cachedPivots.pMidPivot
v_end   = GLOBAL_cachedPivots.pEndBase
v_50    = GLOBAL_confirmedPivot.getLevel(0.5)
v_618   = GLOBAL_confirmedPivot.getLevel(FIB_GOLDEN_RATIO)

plot(v_start, "Pivot Start", color = color.new(color.gray, 0), display = display.data_window + display.status_line)
plot(v_end,   "Pivot End",   color = color.new(color.white, 0), display = display.data_window + display.status_line)
plot(v_50,    "Fib 0.50",    color = color.new(color.yellow, 0), display = display.data_window + display.status_line)
plot(v_618,   "Fib 0.618",   color = color.new(color.orange, 0), display = display.data_window + display.status_line)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if INPUT_ALERT_ENABLED
    // Event-based alert routing
    if INPUT_ALERT_MODE == 'calculateAlertUpdates'
        // FBU: Full state snapshot on bar confirmation
        if barstate.isconfirmed
            string fbu_msg = f_getAlertMessageFull(ALERT_ID_UPDATE, "fib_update",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(fbu_msg, alert.freq_once_per_bar)
        
        // SCT: Setup created on pivot change
        if GLOBAL_zigzag.changed and barstate.isconfirmed
            string sct_msg = f_getAlertMessageFull(ALERT_ID_SETUP, "setup_created",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(sct_msg, alert.freq_once_per_bar)
        
        // EXH: Volume exhaustion signal
        if exhaustVol and barstate.isconfirmed
            string exh_msg = f_getAlertMessageFull(ALERT_ID_EXHAUSTION, "vol_exhaustion",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(exh_msg, alert.freq_once_per_bar)
        
        // HVO: High volatility signal
        if highVolatility and barstate.isconfirmed
            string hvo_msg = f_getAlertMessageFull(ALERT_ID_VOLATILITY, "high_volatility",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(hvo_msg, alert.freq_once_per_bar)
        
        // LRN: Learning recalculated
        if GLOBAL_learning.needsRecalc and barstate.isconfirmed
            string lrn_msg = f_getAlertMessageFull(ALERT_ID_LEARNING, "learning_recalc",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(lrn_msg, alert.freq_once_per_bar)
    
    else if INPUT_ALERT_MODE == 'calculateAlertData'
        // Full snapshot on every confirmed bar
        if barstate.isconfirmed
            string full_msg = f_getAlertMessageFull(ALERT_ID_UPDATE, "fib_update",
                GLOBAL_alertState.isProjection, GLOBAL_alertState.isLong, GLOBAL_alertState.zoneTouched,
                GLOBAL_alertState.slHit, GLOBAL_alertState.tpHit, GLOBAL_alertState.rawZoneTop,
                GLOBAL_alertState.rawZoneBottom, GLOBAL_alertState.adjustedZoneTop, GLOBAL_alertState.adjustedZoneBottom,
                GLOBAL_alertState.bufferPct, GLOBAL_alertState.inZone, GLOBAL_alertState.zoneEntry,
                GLOBAL_alertState.minDistance, GLOBAL_alertState.slPrice, GLOBAL_alertState.tpPrice,
                GLOBAL_alertState.tpCons, GLOBAL_alertState.tpAggr, GLOBAL_alertState.useAggressiveTp,
                GLOBAL_alertState.slMult, GLOBAL_alertState.atr, GLOBAL_alertState.smartSl,
                GLOBAL_alertState.creationBar, GLOBAL_alertState.barsSinceCreation, GLOBAL_alertState.timePhase,
                GLOBAL_alertState.decayRate, GLOBAL_alertState.expired)
            alert(full_msg, alert.freq_once_per_bar)
    
    // Clear logs on history for performance
    if barstate.ishistory
        GLOBAL_pivotLevelsLogRetracements.clear()
        GLOBAL_pivotLevelsLogCrossed.clear()