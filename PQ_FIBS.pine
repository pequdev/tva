//@version=6
indicator(title = 'Shox Fibonacci Pivots [PQ_MOD]', shorttitle = 'FIBS0.3.3', overlay = true, max_lines_count=500, max_labels_count=500, max_boxes_count=500, max_polylines_count=100, max_bars_back=5000, dynamic_requests=true)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS & THEME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Colors
color COLOR_FG_MAIN     = chart.fg_color
color COLOR_RED         = #f44336
color COLOR_GREEN       = #4caf50
color COLOR_TEAL        = #009688
color COLOR_BLUE        = #2196f3
color COLOR_PURPLE      = #9c27b0
color COLOR_PINK        = #e91e63
color COLOR_GRAY        = #a2a2a2
color COLOR_LIGHT_GREEN = #81c784
color COLOR_LIGHT_BLUE  = #64b5f6

// Theme Transparencies
int TRANS_MAIN          = 25
int TRANS_SUPP          = 70

// Static Colors
color COLOR_TZ          = color.new(COLOR_FG_MAIN, 80)
color COLOR_ZZ          = color.new(COLOR_FG_MAIN, 75)
color COLOR_TEXT        = color.new(COLOR_FG_MAIN, 0)

// Configuration Constants
int LEVELS_COUNT        = 22

// Alert IDs
string ALERT_ID_UPDATE     = 'FBU'
string ALERT_ID_EXHAUSTION = 'EXH'
string ALERT_ID_VOLATILITY = 'HVO'
string ALERT_ID_CROSSING   = 'RCL'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIBONACCI CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float FIB_GOLDEN_RATIO    = 0.618
float FIB_GOLDEN_POCKET_H = 0.65
float FIB_EXTENSION_1272  = 1.272
float FIB_EXTENSION_1618  = 1.618

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE FLAGS - Bitwise Trade/Setup State Representation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Direction Flag (Bit 0)
int FLAG_IS_LONG        = 1

// Entry State (Bit 1)
int FLAG_ZONE_TOUCHED   = 2

// Exit States (Bits 2-3) - Mutually exclusive
int FLAG_SL_HIT         = 4
int FLAG_TP_HIT         = 8

// Confluence Flags (Bit 4)
int FLAG_HAD_RSI_DIV    = 16

// TP Mode (Bit 5)
int FLAG_TP_AGGRESSIVE  = 32

// Analytics Tracking (Bits 6-7)
int FLAG_CONS_TP_HIT    = 64
int FLAG_AGGR_TP_HIT    = 128

// Lifecycle States (Bits 8-10) - Mutually exclusive
int FLAG_PENDING        = 256
int FLAG_ACTIVE         = 512
int FLAG_CLOSED         = 1024

// Outcome (Bit 11)
int FLAG_WON            = 2048

// Intrabar Resolution (Bit 12)
int FLAG_LTF_RESOLVED   = 4096

// Composite Masks
int MASK_OUTCOME        = 12
int MASK_CLOSED         = 1024
int MASK_LIFECYCLE      = 1792
int MASK_TP_TRACKING    = 192

// Max bit index
int STATE_MAX_BIT       = 12

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE FLAGS API - Arithmetic-Based Bit Operations for State Management
// Pine Script v6 does not have native bitwise operators, so we simulate them using arithmetic.
// Flags must be powers of 2: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048...
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @function Check if a specific flag (single power-of-2) is set in state
// @param state Current state mask
// @param flag Flag to check (must be a power of 2)
// @returns True if flag is set
f_hasFlag(int state, int flag) =>
    math.floor(state / flag) % 2 == 1

// @function Set a flag in the state mask (idempotent - safe to call multiple times)
// @param state Current state mask
// @param flag Flag to set (power-of-two constant)
// @returns Updated state mask with flag set
f_setFlag(int state, int flag) =>
    f_hasFlag(state, flag) ? state : state + flag

// @function Clear a flag from the state mask (idempotent - safe to call if already clear)
// @param state Current state mask
// @param flag Flag to clear (power-of-two constant)
// @returns Updated state mask with flag cleared
f_clearFlag(int state, int flag) =>
    f_hasFlag(state, flag) ? state - flag : state

// @function Check if ANY of the flags in a composite mask are set
// @param state Current state mask
// @param mask Composite mask (sum of multiple power-of-2 flags)
// @returns True if at least one flag in mask is set
f_hasAny(int state, int mask) =>
    // Check each possible flag in the mask
    bool result = false
    int testBit = 1
    for i = 0 to STATE_MAX_BIT  // Iterate through bits 0 to STATE_MAX_BIT (inclusive)
        if math.floor(mask / testBit) % 2 == 1  // This bit is in the mask
            if f_hasFlag(state, testBit)
                result := true
                break
        testBit := testBit * 2
    result

// @function Check if ALL flags in a composite mask are set
// @param state Current state mask
// @param mask Composite mask (sum of multiple power-of-2 flags)
// @returns True if all flags in mask are set
f_hasAll(int state, int mask) =>
    // Check each possible flag in the mask
    bool result = true
    int testBit = 1
    for i = 0 to STATE_MAX_BIT  // Iterate through bits 0 to STATE_MAX_BIT (inclusive)
        if math.floor(mask / testBit) % 2 == 1  // This bit is in the mask
            if not f_hasFlag(state, testBit)
                result := false
                break
        testBit := testBit * 2
    result

// @function Set lifecycle phase with mutual exclusion (clears other lifecycle flags first)
// @param state Current state mask
// @param phase Lifecycle flag (FLAG_PENDING, FLAG_ACTIVE, or FLAG_CLOSED)
// @returns Updated state mask with only the specified lifecycle phase set
f_setLifecycle(int state, int phase) =>
    // Clear all lifecycle flags first
    int cleared = f_clearFlag(state, FLAG_PENDING)
    cleared := f_clearFlag(cleared, FLAG_ACTIVE)
    cleared := f_clearFlag(cleared, FLAG_CLOSED)
    // Set the new phase
    f_setFlag(cleared, phase)

// @function Set outcome with mutual exclusion (only one of SL_HIT or TP_HIT can be set)
// @param state Current state mask
// @param outcome Outcome flag (FLAG_SL_HIT or FLAG_TP_HIT)
// @returns Updated state mask with only the specified outcome set (clears the other)
f_setOutcome(int state, int outcome) =>
    // Clear both outcome flags first to enforce mutual exclusion
    int cleared = f_clearFlag(state, FLAG_SL_HIT)
    cleared := f_clearFlag(cleared, FLAG_TP_HIT)
    // Set the new outcome
    f_setFlag(cleared, outcome)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTRABAR RESOLUTION - Chronological TP/SL Resolution Using LTF Data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Resolves which outcome (TP or SL) occurred first when both are hit in the same HTF bar
// by iterating through LTF bars chronologically. Returns: 1 = TP first, -1 = SL first, 0 = neither/undetermined

// @function Resolve TP/SL outcome chronologically using LTF intrabar data
// @param ltf_highs Array of LTF high values within current HTF bar
// @param ltf_lows Array of LTF low values within current HTF bar
// @param is_long True if this is a long trade (affects TP/SL direction checks)
// @param sl_price Stop loss price level
// @param tp_price Take profit price level
// @param conservative_tiebreak True = assume SL first on same-bar conflict, False = assume TP first
// @returns Tuple: [outcome, ltf_resolved, hit_index]
//          outcome: 1 = TP hit first, -1 = SL hit first, 0 = neither hit
//          ltf_resolved: true if resolved via LTF data, false if fallback used
//          hit_index: LTF bar index where outcome was determined (-1 if none)
f_resolveIntrabar(array<float> ltf_highs, array<float> ltf_lows, bool is_long, float sl_price, float tp_price, bool conservative_tiebreak) =>
    int outcome = 0          // 0 = undetermined, 1 = TP first, -1 = SL first
    bool ltf_resolved = false
    int hit_index = -1
    
    // Check if LTF data is available
    int ltf_count = array.size(ltf_highs)
    
    if ltf_count > 0
        // Iterate LTF bars chronologically (index 0 = earliest in HTF bar)
        for i = 0 to ltf_count - 1
            float ltf_high = array.get(ltf_highs, i)
            float ltf_low = array.get(ltf_lows, i)
            
            // Check TP/SL hits for this LTF bar
            bool sl_hit = is_long ? (ltf_low <= sl_price) : (ltf_high >= sl_price)
            bool tp_hit = is_long ? (ltf_high >= tp_price) : (ltf_low <= tp_price)
            
            // Resolve outcome for this intrabar
            if sl_hit and tp_hit
                // Both hit in same LTF bar - apply tie-break policy
                outcome := conservative_tiebreak ? -1 : 1  // -1 = SL, 1 = TP
                ltf_resolved := true
                hit_index := i
                break
            else if sl_hit
                outcome := -1  // SL hit first
                ltf_resolved := true
                hit_index := i
                break
            else if tp_hit
                outcome := 1   // TP hit first
                ltf_resolved := true
                hit_index := i
                break
    
    [outcome, ltf_resolved, hit_index]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEARNING ENGINE CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Minimum sample thresholds
int   LEARN_MIN_SAMPLES_SL      = 20
int   LEARN_MIN_SAMPLES_BUFFER  = 10
int   LEARN_MIN_SAMPLES_WR      = 10
int   LEARN_MIN_SAMPLES_MAE     = 5
int   LEARN_MIN_SAMPLES_DIV     = 5
int   LEARN_MIN_SAMPLES_DIR     = 5
int   LEARN_MIN_SAMPLES_LOSING  = 3
int   LEARN_MIN_SAMPLES_TP_COMP = 10
int   LEARN_MIN_SAMPLES_TIME    = 10

// Volatility regime thresholds
int   VOL_REGIME_HIGH_THRESH    = 60
int   VOL_REGIME_LOW_THRESH     = 40

// Near-miss detection
float NEAR_MISS_RATE_THRESH     = 0.10
float NEAR_MISS_BUFFER_MULT     = 5.0
float NEAR_MISS_BUFFER_MAX      = 5.0
float NEAR_MISS_CLOSE_THRESH    = 0.3

// Time decay Fibonacci thresholds
int   TIME_DECAY_T1             = 8
int   TIME_DECAY_T2             = 13
int   TIME_DECAY_T3             = 21
int   TIME_DECAY_T4             = 34
int   TIME_DECAY_T5             = 55
float TIME_DECAY_DEFAULT_RATE   = 0.85
float TIME_DECAY_SCALE_MIN      = 0.5
float TIME_DECAY_SCALE_MAX      = 2.0
int   TIME_DECAY_REFERENCE_BARS = 13

// SL learning
float SL_BUFFER_ATR             = 0.5
float SL_LOSING_MAE_FACTOR      = 1.5

// Confidence scoring thresholds
int   CONF_GRADE_D_THRESH       = 25
int   CONF_GRADE_C_THRESH       = 50
int   CONF_GRADE_B_THRESH       = 70
int   CONF_GRADE_A_THRESH       = 85

// Streak tracking
int   STREAK_WIN_BONUS_THRESH   = 3
int   STREAK_LOSS_PENALTY_THRESH = 3
int   STREAK_PENALTY_MAX        = 15
float STREAK_PENALTY_RATE       = 5.0
int   STREAK_LOSS_PENALTY_BASE  = 2
int   STREAK_BONUS_MAX          = 10
float STREAK_BONUS_RATE         = 3.33
int   STREAK_WIN_BONUS_BASE     = 2

// Health check thresholds
int   HEALTH_STALE_BARS         = 100
float HEALTH_WR_MIN             = 0.25
float HEALTH_WR_MAX             = 0.85
float HEALTH_PF_MIN             = 0.7

// Kelly calculation
float KELLY_MIN_EDGE            = 0.01

// Decay rate learning
float DECAY_RATE_MIN            = 0.75
float DECAY_RATE_MAX            = 0.95
float DECAY_RATE_ADJUST         = 0.14

// Confidence scoring weights
int   CONF_WR_WEIGHT            = 35
float CONF_WR_MIN_MAP           = 0.3
float CONF_WR_MAX_MAP           = 0.8
int   CONF_RSI_WEIGHT           = 20
int   CONF_PF_WEIGHT            = 15
int   CONF_HEALTH_WEIGHT        = 15
float CONF_PF_MIN_MAP           = 0.5
float CONF_PF_MAX_MAP           = 2.0

// Default initial values
float DEFAULT_WIN_RATE          = 0.618
float DEFAULT_DECAY_RATE        = 0.85
float DEFAULT_CONFIDENCE        = 50.0
float DEFAULT_MIN_DISTANCE      = 100.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI TEXT CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string TEXT_LONG        = "LONG"
string TEXT_SHORT       = "SHORT"
string TEXT_SETUP       = " SETUP"
string TEXT_ACTIVE      = " [ACTIVE]"
string TEXT_SL_HIT      = " [SL HIT]"
string TEXT_TP_HIT      = " [TP HIT]"
string TEXT_EXPIRED     = " [EXPIRED]"
string TEXT_FRESH       = "FRESH"
string TEXT_STALE       = "STALE"
string TEXT_LEARNING    = "ğŸ“Š Learning..."
string TEXT_SAMPLES     = " samples"

// UI Icons
string ICON_BRAIN       = "ğŸ§ "
string ICON_CHART       = "ğŸ“Š"
string ICON_TARGET      = "ğŸ¯"
string ICON_FIRE        = "ğŸ”¥"
string ICON_ICE         = "â„ï¸"
string ICON_LIGHTNING   = "âš¡"
string ICON_WAVE        = "ğŸŒŠ"
string ICON_CHECK       = "âœ“"
string ICON_WARNING     = "âš "
string ICON_HOURGLASS   = "â³"

// Tooltips
string TOOLTIP_THRESHOLD   = 'Deviation is a multiplier that affects how much the price should deviate from the previous pivot in order for the bar to become a new pivot\n\nDepth affects the minimum number of bars that will be taken into account when building'
string TOOLTIP_PIVOT_POINT = 'A pivot point is a technical analysis indicator used to determine the overall trend of the market over different time frames'
string TOOLTIP_ZIGZAG      = 'The Zig Zag indicator is used to identify price trends then connected by straight lines that help the trader visual the price action.'
string TOOLTIP_VOL_EXHAUST = 'Moments where huge volume detected'
string TOOLTIP_HIGH_VOL    = 'Moments where price range of the current bar is greater than average true range'
string TOOLTIP_STAT_POS    = 'Calculates the Statistical "Golden Pocket" (0.618-0.65) entry zone.\n\nStop Loss is placed at the Pivot Start (Invalidation) adjusted by an ATR variance to prevent Stop Hunting.\n\nTake Profit targets the Pivot End (Conservative) or 1.272 Extension (Aggressive).'

// Groups
string GROUP_PICK       = 'Pick a Fibonacci Tool'
string GROUP_PIVOT      = 'Fibonacci Pivot Points Settings'
string GROUP_THRESH_SEC = 'Threshold (sec)'
string GROUP_THRESH_MIN = 'Threshold (minutes)'
string GROUP_THRESH_H   = 'Threshold (hours)'
string GROUP_THRESH_D   = 'Threshold (days)'
string GROUP_THRESH_W   = 'Threshold (weeks)'
string GROUP_THRESH_M   = 'Threshold (months)'
string GROUP_DEPTH_SEC  = 'Depth (seconds)'
string GROUP_DEPTH_MIN  = 'Depth (minutes)'
string GROUP_DEPTH_H    = 'Depth (hours)'
string GROUP_DEPTH_D    = 'Depth (days)'
string GROUP_DEPTH_W    = 'Depth (weeks)'
string GROUP_DEPTH_M    = 'Depth (months)'
string GROUP_FIB_TOOL   = 'Fibonacci Extention / Retracement / TimeZone Settings'
string GROUP_FIB_LEVELS = 'Fibonacci Levels'
string GROUP_ZIGZAG     = 'ZigZag Settings'
string GROUP_VOL_VOL    = 'Volume / Volatility AddOns'
string GROUP_ALERTS     = 'Alerts'
string GROUP_STAT_POS   = 'Statistical Position Engine'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INPUT_SHOW_FIB_TIME     = input.bool(true, 'Fib Time Zones', inline='TZ', group=GROUP_PICK)
INPUT_CUSTOM_THRESHOLD  = input.bool(true, 'Custom thresholds', inline='C')
INPUT_CUSTOM_DEPTH      = input.bool(true, 'Custom depths', inline='C')

// Pivot Settings
INPUT_HTF_MODE          = input.string('Auto', 'Pivot Points TimeFrame', options=['Auto', 'User Defined'], inline='HTF', group=GROUP_PIVOT, tooltip=TOOLTIP_PIVOT_POINT)
INPUT_HTF_USER_RAW      = input.string('15 Min', 'â€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒor User Defined', options=['15 Min', '1 Hour', '4 Hour', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Yearly'], inline='HTF1', group=GROUP_PIVOT)

// Parse HTF input
htf_user_parsed = INPUT_HTF_USER_RAW == '15 Min'? '15' : 
                  INPUT_HTF_USER_RAW == '1 Hour'? '60' : 
                  INPUT_HTF_USER_RAW == '4 Hour'? '240' : 
                  INPUT_HTF_USER_RAW == 'Daily'? 'D' : 
                  INPUT_HTF_USER_RAW == 'Weekly'? 'W' : 
                  INPUT_HTF_USER_RAW == 'Monthly'? 'M' : 
                  INPUT_HTF_USER_RAW == 'Quarterly'? '3M' : '12M'

INPUT_LEVELS_PVT        = input.string('Prices', 'Level Labels', options=['Levels', 'Prices', 'Levels + Prices', 'None'], inline='pvt', group=GROUP_PIVOT)
INPUT_LEVELS_PVT_POS    = input.string('Pivot End', '', options=['Last Bar', 'Pivot End'], inline='pvt', group=GROUP_PIVOT)
INPUT_LEVELS_PVT_SIZE   = input.string('Small', '', options=['Small', 'Normal'], inline='pvt', group=GROUP_PIVOT)
INPUT_EXTEND_PVT        = input.bool(false, 'Extend Pivot Point Lines', inline='fLines', group=GROUP_PIVOT)

// Deviation Thresholds
dev_treshold(float dev_treshold) => ta.atr(2) / close * 100 * dev_treshold
INPUT_DEV_THRESH_DEFAULT = dev_treshold(input.float(2.0, 'Deviation (default)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC, tooltip=TOOLTIP_THRESHOLD))
INPUT_DEV_THRESH_1S     = dev_treshold(input.float(2.0, 'Deviation (1S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC))
INPUT_DEV_THRESH_5S     = dev_treshold(input.float(2.0, 'Deviation (5S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC))
INPUT_DEV_THRESH_10S    = dev_treshold(input.float(2.0, 'Deviation (10S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC))
INPUT_DEV_THRESH_15S    = dev_treshold(input.float(2.0, 'Deviation (15S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC))
INPUT_DEV_THRESH_30S    = dev_treshold(input.float(2.0, 'Deviation (30S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC))
INPUT_DEV_THRESH_45S    = dev_treshold(input.float(2.0, 'Deviation (45S)', minval=0, inline='Pivots', group=GROUP_THRESH_SEC))
INPUT_DEV_THRESH_1M     = dev_treshold(input.float(2.0, 'Deviation (1M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN))
INPUT_DEV_THRESH_2M     = dev_treshold(input.float(2.0, 'Deviation (2M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN))
INPUT_DEV_THRESH_3M     = dev_treshold(input.float(2.0, 'Deviation (3M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN))
INPUT_DEV_THRESH_5M     = dev_treshold(input.float(2.0, 'Deviation (5M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN))
INPUT_DEV_THRESH_10M    = dev_treshold(input.float(2.0, 'Deviation (10M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN))
INPUT_DEV_THRESH_15M    = dev_treshold(input.float(2.0, 'Deviation (15M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN))
INPUT_DEV_THRESH_30M    = dev_treshold(input.float(2.0, 'Deviation (30M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN))
INPUT_DEV_THRESH_45M    = dev_treshold(input.float(2.0, 'Deviation (45M)', minval=0, inline='Pivots', group=GROUP_THRESH_MIN))
INPUT_DEV_THRESH_1H     = dev_treshold(input.float(2.0, 'Deviation (1H)', minval=0, inline='Pivots', group=GROUP_THRESH_H))
INPUT_DEV_THRESH_2H     = dev_treshold(input.float(2.0, 'Deviation (2H)', minval=0, inline='Pivots', group=GROUP_THRESH_H))
INPUT_DEV_THRESH_3H     = dev_treshold(input.float(2.0, 'Deviation (3H)', minval=0, inline='Pivots', group=GROUP_THRESH_H))
INPUT_DEV_THRESH_4H     = dev_treshold(input.float(2.0, 'Deviation (4H)', minval=0, inline='Pivots', group=GROUP_THRESH_H))
INPUT_DEV_THRESH_1D     = dev_treshold(input.float(2.0, 'Deviation (1D)', minval=0, inline='Pivots', group=GROUP_THRESH_D))
INPUT_DEV_THRESH_7D     = dev_treshold(input.float(2.0, 'Deviation (7D)', minval=0, inline='Pivots', group=GROUP_THRESH_D))
INPUT_DEV_THRESH_4W     = dev_treshold(input.float(2.0, 'Deviation (4W)', minval=0, inline='Pivots', group=GROUP_THRESH_W))
INPUT_DEV_THRESH_3MO    = dev_treshold(input.float(2.0, 'Deviation (3M)', minval=0, inline='Pivots', group=GROUP_THRESH_M))
INPUT_DEV_THRESH_6MO    = dev_treshold(input.float(2.0, 'Deviation (6M)', minval=0, inline='Pivots', group=GROUP_THRESH_M))
INPUT_DEV_THRESH_12MO   = dev_treshold(input.float(2.0, 'Deviation (12M)', minval=0, inline='Pivots', group=GROUP_THRESH_M))

// Depths
INPUT_DEPTH_DEFAULT     = input.int(10, 'Depth (default)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC)
INPUT_DEPTH_1S          = input.int(10, 'Depth (1S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC)
INPUT_DEPTH_5S          = input.int(10, 'Depth (5S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC)
INPUT_DEPTH_10S         = input.int(10, 'Depth (10S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC)
INPUT_DEPTH_15S         = input.int(10, 'Depth (15S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC)
INPUT_DEPTH_30S         = input.int(10, 'Depth (30S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC)
INPUT_DEPTH_45S         = input.int(10, 'Depth (45S)', minval=1, inline='Pivots', group=GROUP_DEPTH_SEC)
INPUT_DEPTH_1M          = input.int(10, 'Depth (1M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN)
INPUT_DEPTH_2M          = input.int(10, 'Depth (2M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN)
INPUT_DEPTH_3M          = input.int(10, 'Depth (3M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN)
INPUT_DEPTH_5M          = input.int(10, 'Depth (5M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN)
INPUT_DEPTH_10M         = input.int(10, 'Depth (10M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN)
INPUT_DEPTH_15M         = input.int(10, 'Depth (15M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN)
INPUT_DEPTH_30M         = input.int(10, 'Depth (30M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN)
INPUT_DEPTH_45M         = input.int(10, 'Depth (45M)', minval=1, inline='Pivots', group=GROUP_DEPTH_MIN)
INPUT_DEPTH_1H          = input.int(10, 'Depth (1H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H)
INPUT_DEPTH_2H          = input.int(10, 'Depth (2H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H)
INPUT_DEPTH_3H          = input.int(10, 'Depth (3H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H)
INPUT_DEPTH_4H          = input.int(10, 'Depth (4H)', minval=1, inline='Pivots', group=GROUP_DEPTH_H)
INPUT_DEPTH_1D          = input.int(10, 'Depth (1D)', minval=1, inline='Pivots', group=GROUP_DEPTH_D)
INPUT_DEPTH_7D          = input.int(10, 'Depth (7D)', minval=1, inline='Pivots', group=GROUP_DEPTH_D)
INPUT_DEPTH_4W          = input.int(10, 'Depth (4W)', minval=1, inline='Pivots', group=GROUP_DEPTH_W)
INPUT_DEPTH_3MO         = input.int(10, 'Depth (3M)', minval=1, inline='Pivots', group=GROUP_DEPTH_M)
INPUT_DEPTH_6MO         = input.int(10, 'Depth (6M)', minval=1, inline='Pivots', group=GROUP_DEPTH_M)
INPUT_DEPTH_12MO        = input.int(10, 'Depth (12M)', minval=1, inline='Pivots', group=GROUP_DEPTH_M)

// Fibonacci Tools
INPUT_LEVELS_LABEL      = input.string('Prices', 'Level Labels', options=['Levels', 'Prices', 'Levels + Prices', 'None'], inline='fLines', group=GROUP_FIB_TOOL)
INPUT_LEVELS_POS        = input.string('Pivot Start', '', options=['Last Bar', 'Pivot Start'], inline='fLines', group=GROUP_FIB_TOOL)
INPUT_LEVELS_SIZE       = input.string('Small', '', options=['Small', 'Normal'], inline='fLines', group=GROUP_FIB_TOOL)
INPUT_REVERSE           = input.bool(false, 'Reverse Extention / Retracement Levels', group=GROUP_FIB_TOOL)
INPUT_EXTEND_ER         = input.bool(false, 'Extend Extention / Retracement Lines', inline='fLine', group=GROUP_FIB_TOOL)
INPUT_HIST_PIVOT        = input.int (0, 'Historical Extention / Retracement Levels', minval=0, group=GROUP_FIB_TOOL)
INPUT_HIST_PIVOT_2      = input.int(0, 'Historical Time Zones', minval=0, group=GROUP_FIB_TOOL)
INPUT_FIB_TZ_LABEL      = input.bool(false, 'Time Zone Lables', inline='tz poz', group=GROUP_FIB_TOOL)
INPUT_FIB_TZ_POS_X      = input.string('Left', '', options=['Right', 'Left'], inline='tz poz', group=GROUP_FIB_TOOL)
fib_tzlp                = INPUT_FIB_TZ_POS_X == 'Left' ? label.style_label_left : label.style_label_right
INPUT_FIB_TZ_POS_Y      = input.string('Bottom', '', options=['Bottom', 'Top'], inline='tz poz', group=GROUP_FIB_TOOL)

// --- STATISTICAL POSITION ENGINE INPUTS ---
INPUT_SHOW_POS          = input.bool(true, 'Show Stat Position Preview', group=GROUP_STAT_POS, tooltip=TOOLTIP_STAT_POS)
INPUT_POS_SL_MULT       = input.float(1.5, 'Stop Loss Variance (ATR Mult)', minval=0.1, step=0.1, group=GROUP_STAT_POS, tooltip="Buffer added to the Structural Invalidation Point (Pivot Start) to prevent Stop Hunts.")
INPUT_POS_SL_DYNAMIC    = input.bool(true, 'Dynamic SL (Volatility-Adjusted)', group=GROUP_STAT_POS, tooltip="Automatically widens SL during high-volatility regimes and tightens during low-volatility.\nUses ATR percentile ranking over 100 bars to scale the SL multiplier Â±50%.")
INPUT_POS_RSI_DIV       = input.bool(true, 'RSI Divergence Filter', group=GROUP_STAT_POS, tooltip="Adds momentum confluence by detecting RSI divergence at the Golden Pocket.\nBullish div: price lower but RSI higher (for longs).\nBearish div: price higher but RSI lower (for shorts).\nBoosts confidence when divergence confirms the setup.")
INPUT_POS_RSI_LEN       = input.int(14, 'RSI Length', minval=2, maxval=50, group=GROUP_STAT_POS, tooltip="Period for RSI calculation. Default 14 is standard.")
INPUT_POS_TIME_DECAY    = input.bool(true, 'Fib Time Decay', group=GROUP_STAT_POS, tooltip="Applies time-based decay to zone validity using Fibonacci sequence thresholds (8, 13, 21, 34, 55, 89 bars).\nZone fades 15% at each Fib threshold, reducing win probability and visual opacity.\nCrypto moves fastâ€”stale setups lose edge.")
INPUT_POS_TP_MODE       = input.string('Conservative', 'Take Profit Mode', options=['Conservative', 'Aggressive'], group=GROUP_STAT_POS, tooltip="Conservative: Targets Pivot End (0.0).\nAggressive: Targets 1.272 Extension.")
INPUT_POS_WIN_RATE      = input.float(61.8, 'Assumed Win Rate %', minval=1.0, maxval=99.0, step=1.0, group=GROUP_STAT_POS, tooltip="Estimated win probability for Kelly Criterion sizing.\nDefault 61.8% aligns with Golden Ratio confluence.\nAdjust based on your backtested strategy performance.")
INPUT_POS_KELLY_FRAC    = input.float(0.5, 'Kelly Fraction', minval=0.1, maxval=1.0, step=0.1, group=GROUP_STAT_POS, tooltip="Fraction of Kelly to use (Half-Kelly = 0.5 is standard for reduced variance).\n1.0 = Full Kelly (aggressive), 0.25 = Quarter Kelly (conservative).")
// --- LEARNING ENGINE INPUTS ---
INPUT_LEARNING_ENABLED  = input.bool(true, 'ğŸ“Š Adaptive Learning', group=GROUP_STAT_POS, tooltip="Enables backtesting-based learning.\nTracks setup outcomes over historical bars to:\nâ€¢ Adapt zone buffer based on near-misses\nâ€¢ Calculate empirical win rate\nâ€¢ Optimize parameters automatically.")
INPUT_LEARNING_SAMPLES  = input.int(50, 'Learning Sample Size', minval=10, maxval=500, group=GROUP_STAT_POS, tooltip="Number of past setups to analyze for learning.\nMore samples = more stable estimates but slower adaptation.")
INPUT_ZONE_BUFFER_BASE  = input.float(0.0, 'Zone Buffer % (Base)', minval=0.0, maxval=100.0, step=0.05, group=GROUP_STAT_POS, tooltip="Manual buffer added to Golden Pocket boundaries.\nLearning engine may increase this if near-misses detected.")
INPUT_NEAR_MISS_THRESH  = input.float(0.5, 'Near-Miss Threshold %', minval=0.1, maxval=100.0, step=0.1, group=GROUP_STAT_POS, tooltip="Distance threshold for detecting near-misses.\nIf price comes within this % of zone but doesn't enter, it's a near-miss.")
INPUT_USE_LEARNED_SL    = input.bool(true, 'ğŸ§  Use Learned SL (Phase 2)', group=GROUP_STAT_POS, tooltip="When enabled, uses the learned optimal SL multiplier from MAE analysis.\nRequires 20+ samples with 5+ winning trades.\nThe learned SL is based on: avg MAE of winners + 0.5 ATR buffer.")
// --- PHASE 3: ADVANCED LEARNING CONTROLS ---
INPUT_LEARN_TP          = input.bool(true, 'ğŸ§  Learn Optimal TP Mode', group=GROUP_STAT_POS, tooltip="Learns whether Conservative or Aggressive TP mode has better expected value.\nCompares hit rates and R:R of each mode from historical data.")
INPUT_LEARN_DECAY       = input.bool(true, 'ğŸ§  Learn Time Decay Rate', group=GROUP_STAT_POS, tooltip="Learns optimal time decay rate from bars_to_outcome distribution.\nIf most wins happen early, accelerates decay. If wins persist, slows decay.")
INPUT_LEARN_RSI_WEIGHT  = input.bool(true, 'ğŸ§  Learn RSI Weight', group=GROUP_STAT_POS, tooltip="Learns how much to weight RSI divergence in Kelly calculation.\nBased on the edge gained from divergence-confirmed vs non-confirmed setups.")
INPUT_LEARN_MIN_SAMPLES = input.int(30, 'Min Samples for Learning', minval=10, maxval=100, group=GROUP_STAT_POS, tooltip="Minimum number of samples required before applying learned parameters.\nHigher = more stable but slower adaptation.")
// --- PROJECTION MODE ---
INPUT_PROJECTION_MODE   = input.bool(true, 'âš¡ Projection Mode (Early Pivot)', group=GROUP_STAT_POS, tooltip="Shows tentative Golden Pocket in real-time when price retraces by deviation threshold from local high/low.\nDoes not wait for full depth confirmation.\nAllows earlier entry signals but may repaint.")
INPUT_PROJ_SENSITIVITY  = input.float(0.5, '   â†³ Sensitivity', minval=0.1, maxval=1.0, step=0.1, group=GROUP_STAT_POS, tooltip="Scalar for deviation threshold. < 1.0 reduces lag for tentative setups but increases false positive rate.\n0.5 = 50% of normal threshold (faster signals).\n1.0 = same as confirmed ZigZag (no early warning).")
// --- INTRABAR PRECISION (Backtest Engine) ---
INPUT_INTRABAR_ENABLED  = input.bool(true, 'ğŸ”¬ Intrabar Precision', group=GROUP_STAT_POS, tooltip="Uses lower timeframe data to resolve TP/SL order when both are hit in the same HTF bar.\nEliminates look-ahead bias and improves backtest accuracy.\nRequires dynamic_requests=true in indicator declaration.")
INPUT_INTRABAR_TF       = input.string('5', '   â†³ LTF Resolution', options=['1', '5', '15'], group=GROUP_STAT_POS, tooltip="Lower timeframe for intrabar inspection.\n1 = 1 minute (most precise, higher overhead)\n5 = 5 minutes (balanced, recommended)\n15 = 15 minutes (fastest, less precise)")
INPUT_INTRABAR_TIEBREAK = input.string('Conservative', '   â†³ Tie-Break Policy', options=['Conservative', 'Optimistic'], group=GROUP_STAT_POS, tooltip="When TP and SL are hit in the same LTF bar:\nConservative: Assume SL hit first (capital preservation)\nOptimistic: Assume TP hit first (best case)")
// ------------------------------------------

// Fibonacci Levels
INPUT_SHOW_0            = input.bool(true, '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_VAL_0             = input.float(0., '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_COL_0             = input.color(color.new(COLOR_GRAY, TRANS_MAIN), '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_236        = input.bool(true, '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_236         = input.float(0.236, '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_COL_0_236         = input.color(color.new(COLOR_RED, TRANS_MAIN), '', inline='Level0', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_382        = input.bool(true, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_382         = input.float(0.382, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_COL_0_382         = input.color(color.new(COLOR_LIGHT_GREEN, TRANS_MAIN), '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_5          = input.bool(true, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_5           = input.float(0.5, '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_COL_0_5           = input.color(color.new(COLOR_GREEN, TRANS_MAIN), '', inline='Level1', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_618        = input.bool(true, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_618         = input.float(0.618, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_COL_0_618         = input.color(color.new(COLOR_TEAL, TRANS_MAIN), '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_65         = input.bool(true, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_65          = input.float(0.65, '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_COL_0_65          = input.color(color.new(COLOR_TEAL, TRANS_SUPP), '', inline='Level2', group=GROUP_FIB_LEVELS)
INPUT_SHOW_0_786        = input.bool(true, '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_VAL_0_786         = input.float(0.786, '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_COL_0_786         = input.color(color.new(COLOR_LIGHT_BLUE, TRANS_MAIN), '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1            = input.bool(true, '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_VAL_1             = input.float(1., '', inline='Level3', group=GROUP_FIB_LEVELS)
INPUT_COL_1             = input.color(color.new(#787b86, 15), '', inline='Level3', group=GROUP_FIB_LEVELS) 
INPUT_SHOW_1_272        = input.bool(true, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_272         = input.float(1.272, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_COL_1_272         = input.color(color.new(COLOR_LIGHT_GREEN, TRANS_MAIN), '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1_414        = input.bool(false, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_414         = input.float(1.414, '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_COL_1_414         = input.color(color.new(COLOR_RED, TRANS_SUPP), '', inline='Level4', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1_618        = input.bool(true, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_618         = input.float(1.618, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_COL_1_618         = input.color(color.new(COLOR_BLUE, TRANS_MAIN), '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_SHOW_1_65         = input.bool(false, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_VAL_1_65          = input.float(1.65, '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_COL_1_65          = input.color(color.new(COLOR_BLUE, TRANS_SUPP), '', inline='Level5', group=GROUP_FIB_LEVELS)
INPUT_SHOW_2_618        = input.bool(false, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_VAL_2_618         = input.float(2.618, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_COL_2_618         = input.color(color.new(COLOR_RED, TRANS_SUPP), '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_SHOW_2_65         = input.bool(true, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_VAL_2_65          = input.float(2.65, '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_COL_2_65          = input.color(color.new(COLOR_RED, TRANS_SUPP), '', inline='Level6', group=GROUP_FIB_LEVELS)
INPUT_SHOW_3_618        = input.bool(false, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_VAL_3_618         = input.float(3.618, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_COL_3_618         = input.color(color.new(COLOR_PURPLE, TRANS_SUPP), '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_SHOW_3_65         = input.bool(true, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_VAL_3_65          = input.float(3.65, '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_COL_3_65          = input.color(color.new(COLOR_PURPLE, TRANS_SUPP), '', inline='Level7', group=GROUP_FIB_LEVELS)
INPUT_SHOW_4_236        = input.bool(true, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_VAL_4_236         = input.float(4.236, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_COL_4_236         = input.color(color.new(COLOR_PINK, TRANS_SUPP), '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_SHOW_4_618        = input.bool(true, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_VAL_4_618         = input.float(4.669, '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_COL_4_618         = input.color(color.new(COLOR_LIGHT_GREEN, TRANS_SUPP) , '', inline='Level8', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_236    = input.bool(true, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_236     = input.float(-0.236, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_236     = input.color(color.new(COLOR_RED, TRANS_SUPP), '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_382    = input.bool(true, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_382     = input.float(-0.382, '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_382     = input.color(color.new(COLOR_LIGHT_GREEN, TRANS_SUPP), '', inline='Level9', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_618    = input.bool(false, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_618     = input.float(-0.618, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_618     = input.color(color.new(COLOR_TEAL, TRANS_SUPP), '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_SHOW_NEG_0_65     = input.bool(true, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_VAL_NEG_0_65      = input.float(-0.65, '', inline='Level10', group=GROUP_FIB_LEVELS)
INPUT_COL_NEG_0_65      = input.color(color.new(COLOR_TEAL, TRANS_SUPP), '', inline='Level10', group=GROUP_FIB_LEVELS)

// ZigZag
INPUT_SHOW_ZIGZAG       = input.bool(true, 'Zig Zagâ€‡â€‡', inline='ZZ', group=GROUP_ZIGZAG, tooltip=TOOLTIP_ZIGZAG)

// Alerts
INPUT_ALERT_ENABLED     = input.bool(false, 'Enable Alerts', group=GROUP_ALERTS)
INPUT_ALERT_MODE        = input.string('calculateAlertUpdates', 'Alert data collection mode', options=['calculateAlertData', 'calculateAlertUpdates'], group = GROUP_ALERTS)
INPUT_ALERT_SEPARATOR   = input.string('|', 'Alert data separator', group = GROUP_ALERTS)

// Volatility & Volume AddOns
INPUT_SHOW_HIGH_ATR     = input.bool(false, 'âš¡', inline='ATR', group=GROUP_VOL_VOL, tooltip=TOOLTIP_HIGH_VOL)
INPUT_ATR_LENGTH        = input.int(7, 'ATR : Length', inline='ATR', group=GROUP_VOL_VOL)
INPUT_ATR_MULT          = input.float(2.0, 'Mult', minval=.1, step=.1, inline='ATR', group=GROUP_VOL_VOL)
INPUT_VOL_SMA_LEN       = input.int(89, 'Volume Moving Average Length', group=GROUP_VOL_VOL)
INPUT_SHOW_VOL_SPIKE    = input.bool(false, 'ğŸš¦', inline='SRS1', group=GROUP_VOL_VOL, tooltip=TOOLTIP_VOL_EXHAUST)
INPUT_VOL_SPIKE_THRESH  = input.float(2.5, 'Volume Spike Thesholdâ€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡â€‡', minval=.1, step=.1, inline='SRS1', group=GROUP_VOL_VOL)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULATIONS & LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Data Structures
var map<float, float> GLOBAL_pivotLevelsLogRetracements = map.new<float, float>()
var map<float, float> GLOBAL_pivotLevelsLogCrossed = map.new<float, float>()

type FibLevel
    float level
    color col
    bool show
    line ln = na
    label lb = na
    bool crossed = false  // Pre-computed crossing flag (Pine v6 best practice)

var array<FibLevel> fibLevels = array.new<FibLevel>()
if barstate.isfirst
    fibLevels.push(FibLevel.new(INPUT_VAL_0, INPUT_COL_0, INPUT_SHOW_0))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_236, INPUT_COL_0_236, INPUT_SHOW_0_236))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_382, INPUT_COL_0_382, INPUT_SHOW_0_382))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_5, INPUT_COL_0_5, INPUT_SHOW_0_5))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_618, INPUT_COL_0_618, INPUT_SHOW_0_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_65, INPUT_COL_0_65, INPUT_SHOW_0_65))
    fibLevels.push(FibLevel.new(INPUT_VAL_0_786, INPUT_COL_0_786, INPUT_SHOW_0_786))
    fibLevels.push(FibLevel.new(INPUT_VAL_1, INPUT_COL_1, INPUT_SHOW_1))
    fibLevels.push(FibLevel.new(INPUT_VAL_1_272, INPUT_COL_1_272, INPUT_SHOW_1_272))
    fibLevels.push(FibLevel.new(INPUT_VAL_1_414, INPUT_COL_1_414, INPUT_SHOW_1_414))
    fibLevels.push(FibLevel.new(INPUT_VAL_1_618, INPUT_COL_1_618, INPUT_SHOW_1_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_1_65, INPUT_COL_1_65, INPUT_SHOW_1_65))
    fibLevels.push(FibLevel.new(INPUT_VAL_2_618, INPUT_COL_2_618, INPUT_SHOW_2_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_2_65, INPUT_COL_2_65, INPUT_SHOW_2_65))
    fibLevels.push(FibLevel.new(INPUT_VAL_3_618, INPUT_COL_3_618, INPUT_SHOW_3_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_3_65, INPUT_COL_3_65, INPUT_SHOW_3_65))
    fibLevels.push(FibLevel.new(INPUT_VAL_4_236, INPUT_COL_4_236, INPUT_SHOW_4_236))
    fibLevels.push(FibLevel.new(INPUT_VAL_4_618, INPUT_COL_4_618, INPUT_SHOW_4_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_236, INPUT_COL_NEG_0_236, INPUT_SHOW_NEG_0_236))
    fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_382, INPUT_COL_NEG_0_382, INPUT_SHOW_NEG_0_382))
    fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_618, INPUT_COL_NEG_0_618, INPUT_SHOW_NEG_0_618))
    fibLevels.push(FibLevel.new(INPUT_VAL_NEG_0_65, INPUT_COL_NEG_0_65, INPUT_SHOW_NEG_0_65))

int decimalsCount = math.round(math.abs(math.log(1 / syminfo.mintick) / math.log(10)))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTRABAR DATA REQUEST - Lower Timeframe Arrays for Chronological TP/SL Resolution
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTE: request.security_lower_tf MUST be called at global scope (not inside conditionals)
// Returns arrays of LTF values contained within each HTF bar
// These arrays are iterated chronologically when resolving TP/SL outcomes

// Fetch LTF high/low arrays for intrabar resolution (uses configured timeframe)
// The arrays contain all LTF bars that fall within the current HTF bar
array<float> GLOBAL_ltfHighs = request.security_lower_tf(syminfo.tickerid, INPUT_INTRABAR_TF, high)
array<float> GLOBAL_ltfLows  = request.security_lower_tf(syminfo.tickerid, INPUT_INTRABAR_TF, low)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEARNING ENGINE DATA STRUCTURES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @type SetupRecord - Tracks outcome of each Golden Pocket setup for backtesting learning
// @field setup_bar Bar index when setup formed
// @field state_mask Bitwise flags for boolean states (see FLAG_* constants)
// @field zone_top Golden Pocket upper boundary
// @field zone_bottom Golden Pocket lower boundary
// @field sl_level Stop loss price
// @field tp_level Take profit price
// @field closest_approach Closest distance to zone (% of zone width)
// @field bars_to_outcome Bars from setup to SL/TP hit (0 if neither)
// @field max_adverse Maximum Adverse Excursion (ATR multiple)
// @field max_favorable Maximum Favorable Excursion (ATR multiple)
// @field entry_price Price when zone was first touched
// @field atr_at_setup ATR value when setup formed
// @field rsi_at_entry RSI when zone was touched
// @field tp_conservative Conservative TP price (Pivot End)
// @field tp_aggressive Aggressive TP price (1.272 Extension)
// @field vol_percentile ATR percentile at setup (0-100)
// NOTE: Must be declared before CircularBufferSetupRecord which references it
type SetupRecord
    int    setup_bar
    int    state_mask = 0
    float  zone_top
    float  zone_bottom
    float  sl_level
    float  tp_level
    float  closest_approach
    int    bars_to_outcome
    float  max_adverse
    float  max_favorable
    float  entry_price
    float  atr_at_setup
    float  rsi_at_entry
    float  tp_conservative
    float  tp_aggressive
    float  vol_percentile

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CIRCULAR BUFFER - O(1) Fixed-Size Ring Buffer for Historical Data
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// @type CircularBuffer - Fixed-size ring buffer with O(1) operations
// @field data Preallocated array of SetupRecord (size = capacity)
// @field head Index of next write position (0 to capacity-1)
// @field count Number of valid entries (0 to capacity)
// @field capacity Maximum buffer size (fixed at initialization)
type CircularBufferSetupRecord
    array<SetupRecord> data
    int head = 0
    int count = 0
    int capacity = 50

// @function Initialize a CircularBuffer with preallocated capacity
// @param this CircularBuffer instance
// @param _capacity Maximum number of elements to store
// @returns Initialized CircularBuffer
method init(CircularBufferSetupRecord this, int _capacity) =>
    this.capacity := _capacity
    this.head := 0
    this.count := 0
    this.data := array.new<SetupRecord>(_capacity)
    this

// @function Push a new value into the buffer (overwrites oldest when full)
// @param this CircularBuffer instance
// @param value SetupRecord to push
// @returns The CircularBuffer instance (for chaining)
method push(CircularBufferSetupRecord this, SetupRecord value) =>
    array.set(this.data, this.head, value)
    this.head := (this.head + 1) % this.capacity
    this.count := math.min(this.count + 1, this.capacity)
    this

// @function Get value at lookback index (0 = newest, count-1 = oldest valid)
// @param this CircularBuffer instance
// @param lookback Lookback index (0 = most recent push)
// @returns SetupRecord at that position, or na if out of bounds
method get(CircularBufferSetupRecord this, int lookback) =>
    if lookback < 0 or lookback >= this.count
        na
    else
        int physicalIndex = (this.head - 1 - lookback + this.capacity) % this.capacity
        array.get(this.data, physicalIndex)

// @function Get the number of valid entries in the buffer
// @param this CircularBuffer instance
// @returns Number of entries (0 to capacity)
method size(CircularBufferSetupRecord this) =>
    this.count

// @function Check if buffer has any valid entries
// @param this CircularBuffer instance
// @returns True if count > 0
method isEmpty(CircularBufferSetupRecord this) =>
    this.count == 0

// @function Check if buffer is at capacity
// @param this CircularBuffer instance
// @returns True if count == capacity
method isFull(CircularBufferSetupRecord this) =>
    this.count == this.capacity

var CircularBufferSetupRecord GLOBAL_setupHistory = CircularBufferSetupRecord.new()

// Initialize the circular buffer on first bar
if barstate.isfirst
    GLOBAL_setupHistory.init(INPUT_LEARNING_SAMPLES)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKTESTING ENGINE - Trade Mining System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This engine "mines" historical trades as the script loads, building a complete trade history
// bar-by-bar. Uses RAW Fib levels (no learned adjustments) to keep data pure for learning.

// @type BacktestTrade - Represents a single simulated trade position
// @field id Pivot Bar Index (unique identifier)
// @field state_mask Bitwise flags: FLAG_IS_LONG for direction, FLAG_PENDING/ACTIVE/CLOSED for lifecycle, FLAG_WON for outcome
//                   NOTE: Must be initialized via BacktestTrade.new() with proper flags (see lines ~1470-1485)
// @field entry_price Calculated Golden Pocket entry level (mid of zone)
// @field entry_top Golden Pocket upper boundary
// @field entry_btm Golden Pocket lower boundary
// @field sl_price Initial Stop Loss price
// @field tp_price Initial Take Profit price
// @field mae Max Adverse Excursion (worst drawdown from entry, in price)
// @field mfe Max Favorable Excursion (best unrealized profit from entry, in price)
// @field entry_bar Bar index when position became Active
// @field exit_bar Bar index when position was Closed
type BacktestTrade
    int    id
    int    state_mask  // No default - must be initialized with proper flags
    float  entry_price
    float  entry_top
    float  entry_btm
    float  sl_price
    float  tp_price
    float  mae
    float  mfe
    int    entry_bar
    int    exit_bar

// Global Storage for Backtesting Engine
var array<BacktestTrade> history_log = array.new<BacktestTrade>()  // Completed trade history
var BacktestTrade current_sim = na  // Single trade currently being simulated in the loop

// Optimization Results (calculated from history_log on barstate.islast)
var float bt_avg_winning_mae = 0.0     // Average MAE of winning trades
var float bt_avg_losing_mae = 0.0      // Average MAE of losing trades  
var float bt_win_rate = 0.0            // Win rate from backtest
var int   bt_total_trades = 0          // Total completed trades
var int   bt_winning_trades = 0        // Number of winning trades
var float bt_smart_sl_offset = 0.0     // Smart SL = Entry - (Avg Winning MAE * 1.1)
var bool  bt_low_confidence = false    // True if win rate < 40%
var bool  bt_stats_ready = false       // True once stats have been calculated

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SetupState UDT: Tracks LIVE state of a Golden Pocket setup
// Used to separate CONFIRMED trade tracking (for learning) from PROJECTION preview (visual only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// @type SetupState - Tracks live state of a Golden Pocket setup
// @field setup_bar Bar index when setup formed (pivot bar)
// @field creation_bar Bar index when this setup was CREATED (for time decay)
// @field state_mask Bitwise flags for boolean states (see FLAG_* constants)
// @field zone_top Golden Pocket upper boundary (with buffer)
// @field zone_bottom Golden Pocket lower boundary (with buffer)
// @field sl_price Stop loss price
// @field tp_price Take profit price (active mode)
// @field tp_cons Conservative TP price (MidPivot)
// @field tp_aggr Aggressive TP price (1.272 extension)
// @field min_distance Closest approach to zone (% of zone width)
// @field entry_bar Bar when zone was first touched
// @field entry_price Price at zone entry
// @field max_adverse Worst drawdown from entry (ATR units)
// @field max_favorable Best unrealized profit (ATR units)
// @field atr_at_setup ATR at setup formation
// @field rsi_at_entry RSI when zone touched
// @field vol_percentile ATR percentile at setup (0-100)
type SetupState
    int    setup_bar
    int    creation_bar
    int    state_mask = 0
    float  zone_top
    float  zone_bottom
    float  sl_price
    float  tp_price
    float  tp_cons
    float  tp_aggr
    float  min_distance
    int    entry_bar
    float  entry_price
    float  max_adverse
    float  max_favorable
    float  atr_at_setup
    float  rsi_at_entry
    float  vol_percentile

// @function Create a fresh SetupState with default values
// @returns New SetupState with state_mask = 0 (no flags set)
f_new_setup_state() =>
    SetupState.new(
        na,                    // setup_bar
        na,                    // creation_bar
        0,                     // state_mask (no flags)
        na,                    // zone_top
        na,                    // zone_bottom
        na,                    // sl_price
        na,                    // tp_price
        na,                    // tp_cons
        na,                    // tp_aggr
        DEFAULT_MIN_DISTANCE,  // min_distance
        na,                    // entry_bar
        na,                    // entry_price
        0.0,                   // max_adverse
        0.0,                   // max_favorable
        na,                    // atr_at_setup
        na,                    // rsi_at_entry
        DEFAULT_CONFIDENCE     // vol_percentile
    )

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE SEPARATION: Active Trade vs Projection Preview
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL_activeTrade: ONLY updated on pivotChanged (confirmed ZigZag pivots)
//                 Learning Engine reads/writes ONLY this state
//                 Recorded to GLOBAL_setupHistory when next pivot confirms
//                 Used for SOLID visual elements (confirmed state)
var SetupState GLOBAL_activeTrade = f_new_setup_state()

// GLOBAL_projectionPreview: Recalculated EVERY bar when projection mode is active
//                       Used for VISUAL display only - NEVER recorded to history
//                       Does NOT affect learning engine calculations
//                       Used for DASHED visual elements (tentative state)
// Note: Not persistent (no var) - recalculated fresh each bar
SetupState GLOBAL_projectionPreview = f_new_setup_state()

// Learning engine computed values (updated only when new trade recorded)
var float  GLOBAL_learnedZoneBuffer = 0.0
var float  GLOBAL_learnedWinRate = DEFAULT_WIN_RATE
var int    GLOBAL_nearMissCount = 0
var int    GLOBAL_totalSetups = 0
// Flag to track when learning recalculation is needed (only after new trade recorded)
var bool   GLOBAL_learningNeedsRecalc = false
// Extended learned values (Phase 1)
var float  GLOBAL_learnedSlMult = 1.5        // Optimal SL multiplier from MAE analysis
var float  GLOBAL_learnedAvgMae = 0.0        // Average MAE of winning trades
var float  GLOBAL_learnedAvgMfe = 0.0        // Average MFE before outcome
var int    GLOBAL_learnedAvgBars = 0         // Average bars to outcome
// Phase 2: Advanced Learning Analytics
var float  GLOBAL_learnedWrWithDiv = DEFAULT_WIN_RATE    // Win rate when RSI divergence present
var float  GLOBAL_learnedWrWithoutDiv = 0.5   // Win rate when no RSI divergence
var float  GLOBAL_learnedWrLong = DEFAULT_WIN_RATE        // Win rate for LONG setups
var float  GLOBAL_learnedWrShort = DEFAULT_WIN_RATE       // Win rate for SHORT setups
var float  GLOBAL_learnedLosingMae = 0.0       // Average MAE of losing trades (informative)
var float  GLOBAL_learnedDivEdge = 0.0         // Edge gained from RSI divergence (wr_with - wr_without)
var int    GLOBAL_learnedOptimalHold = 0       // Optimal holding period (bars) based on MFE peak
// Phase 3: Advanced Learned Parameters
var bool   GLOBAL_learnedTpAggressive = false  // Should we use Aggressive TP mode? (learned)
var float  GLOBAL_learnedDecayRate = DEFAULT_DECAY_RATE      // Learned decay rate per Fib threshold
var float  GLOBAL_learnedRsiWeight = 0.0       // Weight for RSI divergence in Kelly (0 = ignore, 1 = full weight)
var float  GLOBAL_learnedConsWr = 0.0          // Win rate for Conservative TP mode
var float  GLOBAL_learnedAggrWr = 0.0          // Win rate for Aggressive TP mode
var float  GLOBAL_learnedConsEv = 0.0          // Expected value for Conservative TP mode
var float  GLOBAL_learnedAggrEv = 0.0          // Expected value for Aggressive TP mode
// Phase 4: Confidence Scoring & Performance Metrics
var float  GLOBAL_learnedConfidence = DEFAULT_CONFIDENCE      // Unified confidence score (0-100)
var float  GLOBAL_learnedProfitFactor = 1.0    // Total R won / Total R lost
var float  GLOBAL_learnedExpectancy = 0.0       // Average R per trade (expectancy)
var int    GLOBAL_learnedWinStreak = 0         // Current/max winning streak
var int    GLOBAL_learnedLossStreak = 0        // Current/max losing streak
var float  GLOBAL_learnedWrHighVol = DEFAULT_WIN_RATE    // Win rate in high volatility regime
var float  GLOBAL_learnedWrLowVol = DEFAULT_WIN_RATE     // Win rate in low volatility regime
var int    GLOBAL_learnedLastOutcomeBar = 0   // Bar index of last recorded outcome (staleness detection)
var bool   GLOBAL_learnedIsHealthy = true      // Learning system health status

// AddOn Logic: Volatility & Volume
float i_weightedATR = ta.atr(INPUT_ATR_LENGTH) * INPUT_ATR_MULT
float i_vSMA = ta.sma(nz(volume), INPUT_VOL_SMA_LEN)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRE-COMPUTED TA VALUES - Called on every bar for consistency (Pine v6 best practice)
// These values are used in conditional blocks but must be computed globally for proper internal state
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float GLOBAL_rawAtr = i_weightedATR / INPUT_ATR_MULT                    // Raw ATR without multiplier
float GLOBAL_atrPercentile = ta.percentrank(GLOBAL_rawAtr, 100)             // ATR percentile for volatility regime
float GLOBAL_rsi = ta.rsi(close, INPUT_POS_RSI_LEN)                      // RSI for divergence detection

float nzVolume = nz(volume)
bool bullCandle = close > open
bool bearCandle = close < open
float range_1 = math.abs(high - low)
bool exhaustVol = nzVolume > INPUT_VOL_SPIKE_THRESH * i_vSMA
bool crossover_exhaustion = ta.crossover(nzVolume, i_vSMA * INPUT_VOL_SPIKE_THRESH)
bool highVolatility = range_1 > i_weightedATR
bool crossover_volatility = ta.crossover(range_1, i_weightedATR)

// Variable Declarations
var line lineLast = na
var int iLast = 0
var int iPrev = 0
var float pLast = 0.0
var bool isHighLast = false 
var int iPrevPivot = 0
var float pPrevPivot = 0.0
var int iLastPivot = 0
var float pLastPivot = 0.0

// Track pivot changes to optimize drawing
var bool pivotChanged = false

// Cached pivot coordinates for stable Fibonacci drawing
var int cachedIMidPivot = na
var float cachedPMidPivot = na
var int cachedIEndBase = na
var float cachedPEndBase = na
var int cachedIMidPivot2 = na
var float cachedPMidPivot2 = na
var int cachedIEndBase2 = na
var float cachedPEndBase2 = na

// Determine Global Deviation Threshold based on Timeframe
float GLOBAL_DEV_THRESHOLD = switch
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "1S" => INPUT_DEV_THRESH_1S
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "5S" => INPUT_DEV_THRESH_5S
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "10S" => INPUT_DEV_THRESH_10S
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "15S" => INPUT_DEV_THRESH_15S
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "30S" => INPUT_DEV_THRESH_30S
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "45S" => INPUT_DEV_THRESH_45S
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "1" => INPUT_DEV_THRESH_1M
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "2" => INPUT_DEV_THRESH_2M
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "3" => INPUT_DEV_THRESH_3M
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "5" => INPUT_DEV_THRESH_5M
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "10" => INPUT_DEV_THRESH_10M
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "15" => INPUT_DEV_THRESH_15M
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "30" => INPUT_DEV_THRESH_30M
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "45" => INPUT_DEV_THRESH_45M
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "60" => INPUT_DEV_THRESH_1H
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "120" => INPUT_DEV_THRESH_2H
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "180" => INPUT_DEV_THRESH_3H
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "240" => INPUT_DEV_THRESH_4H
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "1D" => INPUT_DEV_THRESH_1D
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "7D" => INPUT_DEV_THRESH_7D
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "4W" => INPUT_DEV_THRESH_4W
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "3M" => INPUT_DEV_THRESH_3MO
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "6M" => INPUT_DEV_THRESH_6MO
    INPUT_CUSTOM_THRESHOLD and timeframe.period == "12M" => INPUT_DEV_THRESH_12MO
    => INPUT_DEV_THRESH_DEFAULT

// Determine Depth based on Timeframe
int i_depth = switch
    INPUT_CUSTOM_DEPTH and timeframe.period == "1S" => INPUT_DEPTH_1S
    INPUT_CUSTOM_DEPTH and timeframe.period == "5S" => INPUT_DEPTH_5S
    INPUT_CUSTOM_DEPTH and timeframe.period == "10S" => INPUT_DEPTH_10S
    INPUT_CUSTOM_DEPTH and timeframe.period == "15S" => INPUT_DEPTH_15S
    INPUT_CUSTOM_DEPTH and timeframe.period == "30S" => INPUT_DEPTH_30S
    INPUT_CUSTOM_DEPTH and timeframe.period == "45S" => INPUT_DEPTH_45S
    INPUT_CUSTOM_DEPTH and timeframe.period == "1" => INPUT_DEPTH_1M
    INPUT_CUSTOM_DEPTH and timeframe.period == "2" => INPUT_DEPTH_2M
    INPUT_CUSTOM_DEPTH and timeframe.period == "3" => INPUT_DEPTH_3M
    INPUT_CUSTOM_DEPTH and timeframe.period == "5" => INPUT_DEPTH_5M
    INPUT_CUSTOM_DEPTH and timeframe.period == "10" => INPUT_DEPTH_10M
    INPUT_CUSTOM_DEPTH and timeframe.period == "15" => INPUT_DEPTH_15M
    INPUT_CUSTOM_DEPTH and timeframe.period == "30" => INPUT_DEPTH_30M
    INPUT_CUSTOM_DEPTH and timeframe.period == "45" => INPUT_DEPTH_45M
    INPUT_CUSTOM_DEPTH and timeframe.period == "60" => INPUT_DEPTH_1H
    INPUT_CUSTOM_DEPTH and timeframe.period == "120" => INPUT_DEPTH_2H
    INPUT_CUSTOM_DEPTH and timeframe.period == "180" => INPUT_DEPTH_3H
    INPUT_CUSTOM_DEPTH and timeframe.period == "240" => INPUT_DEPTH_4H
    INPUT_CUSTOM_DEPTH and timeframe.period == "1D" => INPUT_DEPTH_1D
    INPUT_CUSTOM_DEPTH and timeframe.period == "7D" => INPUT_DEPTH_7D
    INPUT_CUSTOM_DEPTH and timeframe.period == "4W" => INPUT_DEPTH_4W
    INPUT_CUSTOM_DEPTH and timeframe.period == "3M" => INPUT_DEPTH_3MO
    INPUT_CUSTOM_DEPTH and timeframe.period == "6M" => INPUT_DEPTH_6MO
    INPUT_CUSTOM_DEPTH and timeframe.period == "12M" => INPUT_DEPTH_12MO
    => INPUT_DEPTH_DEFAULT

// Determine HTF
htf_auto = timeframe.period == '1'   ? '240' : 
           timeframe.period == '3'   ? '240' : 
           timeframe.period == '5'   ? '240' : 
           timeframe.period == '15'  ? 'D'   : 
           timeframe.period == '30'  ? 'D'   : 
           timeframe.period == '45'  ? 'D'   : 
           timeframe.period == '60'  ? 'W'   : 
           timeframe.period == '120' ? 'W'   : 
           timeframe.period == '180' ? 'W'   : 
           timeframe.period == '240' ? 'W'   : 
           timeframe.period == 'D'   ? 'M'   : 
           timeframe.period == 'W'   ? '3M'  : '12M'

htf = INPUT_HTF_MODE == 'Auto' ? htf_auto : htf_user_parsed

// Time Calculations
time_x10 = ta.valuewhen(ta.change(time(htf)) != 0, time, 1)
time_x11 = ta.valuewhen(ta.change(time(htf)) != 0, time, 0)
time_x21 = 2 * time_x11 - time_x10

var ln = array.new<line>()
var lb = array.new<label>()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pivotLength = math.max(1, int(math.round(i_depth / 2)))
pH = ta.pivothigh(high, pivotLength, pivotLength)
pL = ta.pivotlow(low, pivotLength, pivotLength)
iH = not na(pH) ? bar_index[pivotLength] : int(na)
iL = not na(pL) ? bar_index[pivotLength] : int(na)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROJECTION MODE: Tentative Pivot Detection (real-time, before depth confirmation)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Track local high/low since last confirmed pivot
var float proj_local_high = na
var int   proj_local_high_bar = na
var float proj_local_low = na
var int   proj_local_low_bar = na
var bool  proj_is_high_last = true  // Was last confirmed pivot a high?

// Reset local tracking on confirmed pivot
if not na(pH) or not na(pL)
    proj_local_high := high
    proj_local_high_bar := bar_index
    proj_local_low := low
    proj_local_low_bar := bar_index
    proj_is_high_last := not na(pH)
else
    // Track running local high/low
    if high > nz(proj_local_high, high)
        proj_local_high := high
        proj_local_high_bar := bar_index
    if low < nz(proj_local_low, low)
        proj_local_low := low
        proj_local_low_bar := bar_index

// Detect tentative pivot via deviation from local extremes
float proj_dev_from_high = proj_local_high > 0 ? 100 * (proj_local_high - close) / proj_local_high : 0
float proj_dev_from_low = proj_local_low > 0 ? 100 * (close - proj_local_low) / proj_local_low : 0

// Scaled threshold for projection: INPUT_PROJ_SENSITIVITY < 1.0 reduces lag (earlier signals)
float proj_scaled_threshold = GLOBAL_DEV_THRESHOLD * INPUT_PROJ_SENSITIVITY

// Tentative HIGH pivot: price retraced down from local high by scaled threshold
bool proj_tentative_high = INPUT_PROJECTION_MODE and proj_dev_from_high > proj_scaled_threshold and not proj_is_high_last
// Tentative LOW pivot: price retraced up from local low by scaled threshold  
bool proj_tentative_low = INPUT_PROJECTION_MODE and proj_dev_from_low > proj_scaled_threshold and proj_is_high_last

// Projection pivot values (use local extreme as tentative pivot)
float proj_pivot_price = proj_tentative_high ? proj_local_high : (proj_tentative_low ? proj_local_low : na)
int   proj_pivot_bar = proj_tentative_high ? proj_local_high_bar : (proj_tentative_low ? proj_local_low_bar : int(na))
bool  proj_pivot_is_high = proj_tentative_high

calc_dev(float base_price, float price) =>
    100 * (price - base_price) / price
    
pivotFound(float dev, bool isHigh, int index, float price) =>
    float dev_threshold = GLOBAL_DEV_THRESHOLD
    if isHighLast == isHigh and not na(lineLast)
        if isHighLast ? price > pLast : price < pLast
            line.set_xy2(lineLast, index, price)
            [lineLast, isHighLast]
        else
            [line(na), bool(na)]
    else
        if na(lineLast)
            id = line.new(iLast, pLast, index, price, color=COLOR_ZZ, width=2, style=line.style_solid)
            [id, isHigh]
        else if math.abs(dev) > dev_threshold
            id = line.new(iLast, pLast, index, price, color=COLOR_ZZ, width=2, style=line.style_solid)
            [id, isHigh]
        else
            [line(na), bool(na)]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRE-CALCULATION OF HISTORICAL PIVOT VALUES (Pine v6 - call ta.valuewhen unconditionally)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pre-compute all ta.valuewhen calls unconditionally (Pine v6 best practice)
// These maintain internal state and must be called on every bar
bool _pivotChange_iPrev = ta.change(iPrevPivot != 0)
bool _pivotChange_pPrev = ta.change(pPrevPivot != 0)
bool _pivotChange_iLast = ta.change(iLastPivot != 0)
bool _pivotChange_pLast = ta.change(pLastPivot != 0)

// Historical pivot 1 - always compute, conditionally use
int _iMidPivot_hist_0 = ta.valuewhen(_pivotChange_iPrev, iPrevPivot, math.max(0, INPUT_HIST_PIVOT - 1))
float _pMidPivot_hist_0 = ta.valuewhen(_pivotChange_pPrev, pPrevPivot, math.max(0, INPUT_HIST_PIVOT - 1))
int _iEndBase_hist_0 = ta.valuewhen(_pivotChange_iLast, iLastPivot, math.max(0, INPUT_HIST_PIVOT - 1))
float _pEndBase_hist_0 = ta.valuewhen(_pivotChange_pLast, pLastPivot, math.max(0, INPUT_HIST_PIVOT - 1))

// Historical pivot 2 - always compute, conditionally use
int _iMidPivot_hist_1 = ta.valuewhen(_pivotChange_iPrev, iPrevPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))
float _pMidPivot_hist_1 = ta.valuewhen(_pivotChange_pPrev, pPrevPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))
int _iEndBase_hist_1 = ta.valuewhen(_pivotChange_iLast, iLastPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))
float _pEndBase_hist_1 = ta.valuewhen(_pivotChange_pLast, pLastPivot, math.max(0, INPUT_HIST_PIVOT_2 - 1))

// Apply conditional logic after function calls
temp_iMidPivot_hist = INPUT_HIST_PIVOT > 0 ? _iMidPivot_hist_0 : int(na)
temp_pMidPivot_hist = INPUT_HIST_PIVOT > 0 ? _pMidPivot_hist_0 : float(na)
temp_iEndBase_hist = INPUT_HIST_PIVOT > 0 ? _iEndBase_hist_0 : int(na)
temp_pEndBase_hist = INPUT_HIST_PIVOT > 0 ? _pEndBase_hist_0 : float(na)

temp_iMidPivot2_hist = INPUT_HIST_PIVOT_2 > 0 ? _iMidPivot_hist_1 : int(na)
temp_pMidPivot2_hist = INPUT_HIST_PIVOT_2 > 0 ? _pMidPivot_hist_1 : float(na)
temp_iEndBase2_hist = INPUT_HIST_PIVOT_2 > 0 ? _iEndBase_hist_1 : int(na)
temp_pEndBase2_hist = INPUT_HIST_PIVOT_2 > 0 ? _pEndBase_hist_1 : float(na)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN PIVOT DETECTION AND ZIGZAG CONSTRUCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pivotChanged := false

if not na(iH)
    if na(lineLast) and pLast == 0
        iLast := iH
        pLast := pH
        isHighLast := true
    else
        dev = calc_dev(pLast, pH)
        [id, isHigh] = pivotFound(dev, true, iH, pH)
        if not na(id)
            if id != lineLast
                if not na(lineLast)
                    iPrevPivot := line.get_x1(lineLast)
                    pPrevPivot := line.get_y1(lineLast)
                    iLastPivot := line.get_x2(lineLast)
                    pLastPivot := line.get_y2(lineLast)
                else
                    iPrevPivot := iLast
                    pPrevPivot := pLast
                    iLastPivot := iH
                    pLastPivot := pH
                
                pivotChanged := true
                
                cachedIMidPivot := INPUT_HIST_PIVOT > 0 ? temp_iMidPivot_hist : iPrevPivot
                cachedPMidPivot := INPUT_HIST_PIVOT > 0 ? temp_pMidPivot_hist : pPrevPivot
                cachedIEndBase := INPUT_HIST_PIVOT > 0 ? temp_iEndBase_hist : iLastPivot
                cachedPEndBase := INPUT_HIST_PIVOT > 0 ? temp_pEndBase_hist : pLastPivot
                
                cachedIMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? temp_iMidPivot2_hist : iPrevPivot
                cachedPMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? temp_pMidPivot2_hist : pPrevPivot
                cachedIEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? temp_iEndBase2_hist : iLastPivot
                cachedPEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? temp_pEndBase2_hist : pLastPivot

                if not INPUT_SHOW_ZIGZAG and not na(lineLast)
                    line.delete(lineLast)
            else
                if INPUT_HIST_PIVOT == 0
                    cachedIEndBase := iH
                    cachedPEndBase := pH
                    cachedIEndBase2 := iH
                    cachedPEndBase2 := pH
                    pivotChanged := true 

            lineLast := id
            isHighLast := isHigh
            iPrev := iLast
            iLast := iH
            pLast := pH
else
    if not na(iL)
        if na(lineLast) and pLast == 0
            iLast := iL
            pLast := pL
            isHighLast := false
        else
            dev = calc_dev(pLast, pL)
            [id, isHigh] = pivotFound(dev, false, iL, pL)
            if not na(id)
                if id != lineLast
                    if not na(lineLast)
                        iPrevPivot := line.get_x1(lineLast)
                        pPrevPivot := line.get_y1(lineLast)
                        iLastPivot := line.get_x2(lineLast)
                        pLastPivot := line.get_y2(lineLast)
                    else
                        iPrevPivot := iLast
                        pPrevPivot := pLast
                        iLastPivot := iL
                        pLastPivot := pL
                    
                    pivotChanged := true
                    
                    cachedIMidPivot := INPUT_HIST_PIVOT > 0 ? temp_iMidPivot_hist : iPrevPivot
                    cachedPMidPivot := INPUT_HIST_PIVOT > 0 ? temp_pMidPivot_hist : pPrevPivot
                    cachedIEndBase := INPUT_HIST_PIVOT > 0 ? temp_iEndBase_hist : iLastPivot
                    cachedPEndBase := INPUT_HIST_PIVOT > 0 ? temp_pEndBase_hist : pLastPivot
                    
                    cachedIMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? temp_iMidPivot2_hist : iPrevPivot
                    cachedPMidPivot2 := INPUT_HIST_PIVOT_2 > 0 ? temp_pMidPivot2_hist : pPrevPivot
                    cachedIEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? temp_iEndBase2_hist : iLastPivot
                    cachedPEndBase2 := INPUT_HIST_PIVOT_2 > 0 ? temp_pEndBase2_hist : pLastPivot

                    if not INPUT_SHOW_ZIGZAG and not na(lineLast)
                        line.delete(lineLast)
                else
                    if INPUT_HIST_PIVOT == 0
                        cachedIEndBase := iL
                        cachedPEndBase := pL
                        cachedIEndBase2 := iL
                        cachedPEndBase2 := pL
                        pivotChanged := true

                lineLast := id
                isHighLast := isHigh
                iPrev := iLast
                iLast := iL
                pLast := pL

f_htf_ohlc(string _htf) =>
    var htf_o  = 0.
    var htf_h  = 0.
    var htf_l  = 0.
    htf_c      = close
    
    var htf_ox = 0.
    var htf_hx = 0.
    var htf_lx = 0.
    var htf_cx = 0.

    if ta.change(time(_htf) !=0)
        htf_ox := htf_o
        htf_o  := open
        htf_hx := htf_h
        htf_h  := high
        htf_lx := htf_l
        htf_l  := low
        htf_cx := htf_c[1]
        htf_cx
    else
        htf_h := math.max(high, htf_h)
        htf_l := math.min(low , htf_l)
        htf_l

    [htf_ox, htf_hx, htf_lx, htf_cx, htf_o, htf_h, htf_l, htf_c]

[_, htf_h1, htf_l1, htf_c1, _, _, _, _] = f_htf_ohlc(htf)

f_get_level(float _ratio) =>
    float _diff = math.abs(cachedPMidPivot - cachedPEndBase)
    float _result = cachedPEndBase < cachedPMidPivot ? 
         (INPUT_REVERSE ? cachedPEndBase : cachedPMidPivot) - (INPUT_REVERSE ? -1 : 1) * _diff * _ratio : 
         (INPUT_REVERSE ? cachedPEndBase : cachedPMidPivot) + (INPUT_REVERSE ? -1 : 1) * _diff * _ratio
    _result

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PIVOT COORDINATE REFERENCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

iMidPivot  = cachedIMidPivot
pMidPivot  = cachedPMidPivot
iEndBase   = cachedIEndBase
pEndBase   = cachedPEndBase
iMidPivot2 = cachedIMidPivot2
pMidPivot2 = cachedPMidPivot2
iEndBase2  = cachedIEndBase2
pEndBase2  = cachedPEndBase2

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROJECTION PIVOT INTEGRATION (for Statistical Position Engine)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// When projection mode is active and we have a tentative pivot, use it for earlier Golden Pocket display
// The projection creates a "lookahead" pivot using the current bar as the new EndBase
var int   projIMidPivot = na
var float projPMidPivot = na
var int   projIEndBase = na
var float projPEndBase = na
var bool  projectionActive = false

// Update projection pivots when tentative pivot detected
if proj_tentative_high or proj_tentative_low
    // Tentative pivot becomes the new MidPivot, current price action becomes EndBase
    projIMidPivot := proj_pivot_bar
    projPMidPivot := proj_pivot_price
    projIEndBase := bar_index
    projPEndBase := proj_tentative_high ? low : high  // Current extreme in opposite direction
    projectionActive := true
else if pivotChanged
    // Confirmed pivot overrides projection
    projectionActive := false

// Effective pivot values: use projection if active, otherwise confirmed
int   effIMidPivot = projectionActive ? projIMidPivot : cachedIMidPivot
float effPMidPivot = projectionActive ? projPMidPivot : cachedPMidPivot
int   effIEndBase = projectionActive ? projIEndBase : cachedIEndBase
float effPEndBase = projectionActive ? projPEndBase : cachedPEndBase

// Function to get level using effective pivots (for projection mode)
f_get_level_eff(float _ratio) =>
    float _diff = math.abs(effPMidPivot - effPEndBase)
    float _result = effPEndBase < effPMidPivot ? 
         (INPUT_REVERSE ? effPEndBase : effPMidPivot) - (INPUT_REVERSE ? -1 : 1) * _diff * _ratio : 
         (INPUT_REVERSE ? effPEndBase : effPMidPivot) + (INPUT_REVERSE ? -1 : 1) * _diff * _ratio
    _result

f_crossingLevel(float _curret, float _level) =>
    _level > _curret and _level < _curret[1] or _level < _curret and _level > _curret[1]

if ta.change(time) != 0 and array.size(ln) > 0
    for i = 1 to array.size(ln) by 1
        line.delete(array.shift(ln))

if ta.change(time) != 0 and array.size(lb) > 0
    for i = 1 to array.size(lb) by 1
        label.delete(array.shift(lb))

f_drawLineTZ(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w) =>
    if _x1 - bar_index < 500
        array.push(ln, line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w))

f_drawLabelTZ(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    if _x - bar_index < 500
        array.push(lb, label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip))

f_drawLinePVT(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w) =>
    if _y1 > 0
        array.push(ln, line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _c, _s, _w))

f_drawLabelPVT(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    if _y > 0
        array.push(lb, label.new(_x, _y, INPUT_EXTEND_PVT or INPUT_LEVELS_PVT_POS == "Last Bar" ? _text + '\n\n' : _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip))

f_setLog(map<float, float> logMap) => 
    logMap.clear()

f_updateLevelsLog(map<float, float> logMap, float level, float value) =>
    logMap.put(level, value)

method draw(FibLevel this, int x1, float pMid, int x2, float pEnd, bool forceRedraw) =>
    if this.show and not na(x1) and not na(pMid) and not na(pEnd)
        pPivotDiff = math.abs(pMid - pEnd)
        price = 0.
        price := pEnd < pMid ? (INPUT_REVERSE ? pEnd : pMid) - (INPUT_REVERSE ? -1 : 1) * pPivotDiff * this.level : (INPUT_REVERSE ? pEnd : pMid) + (INPUT_REVERSE ? -1 : 1) * pPivotDiff * this.level
        price := math.round_to_mintick(price)
        
        if forceRedraw
            if not na(this.ln)
                line.delete(this.ln)
                this.ln := na
            if not na(this.lb)
                label.delete(this.lb)
                this.lb := na
            if price > 0
                this.ln := line.new(x1, price, x2, price, xloc.bar_index, INPUT_EXTEND_ER ? extend.both : extend.right, this.col, line.style_solid, this.level != 1 ? 1 : 2)
            if INPUT_LEVELS_LABEL != 'None' and price > 0
                bar_pos = INPUT_LEVELS_POS == "Last Bar" ? x2 : x1
                style_lbl = INPUT_LEVELS_POS == "Last Bar" ? label.style_label_left : label.style_label_right
                size_lbl = INPUT_LEVELS_SIZE == 'Small' ? size.small : size.normal
                text_str = (INPUT_LEVELS_LABEL == 'Prices' ? '' : 'RET ' + str.tostring(this.level)) + (INPUT_LEVELS_LABEL == 'Levels + Prices' or INPUT_LEVELS_LABEL == 'Prices' ? ' (' + str.tostring(price, format.mintick) + ')' : '')
                tooltip_str = str.tostring(price, format.mintick)
                this.lb := label.new(bar_pos, price, INPUT_EXTEND_PVT or INPUT_EXTEND_ER or INPUT_LEVELS_POS == 'Last Bar' ? text_str + '\n\n' : text_str, xloc.bar_index, yloc.price, color.new(COLOR_FG_MAIN, 100), style_lbl, color.new(COLOR_FG_MAIN, 0), size_lbl, text.align_right, tooltip_str)
        else
            if not na(this.ln) and price > 0
                line.set_x2(this.ln, x2)
            if INPUT_LEVELS_POS == "Last Bar" and not na(this.lb) and price > 0
                label.set_x(this.lb, x2)
        
        f_updateLevelsLog(GLOBAL_pivotLevelsLogRetracements, this.level, price)
        // Use pre-computed crossing result (computed globally for Pine v6 consistency)
        if this.crossed
            f_updateLevelsLog(GLOBAL_pivotLevelsLogCrossed, this.level, price)

f_logToJson(map<float, float> logMap) => 
    result = '{'
    for i = 0 to array.size(fibLevels) - 1
        lvl = array.get(fibLevels, i)
        val = logMap.get(lvl.level)
        levelKey = str.replace(str.tostring(lvl.level), '.', '_')
        if na(val)
            result := result + '"' + levelKey + '":null'
        else
            result := result + '"' + levelKey + '":' + str.tostring(val)
        if i < array.size(fibLevels) - 1
            result := result + ','
    result + '}'

f_getAlertMessage(string id) =>
    string barstate_json = (
        '{"is_new":' + (barstate.isnew ? 'true' : 'false') + 
        ',"is_first":' + (barstate.isfirst ? 'true' : 'false') + 
        ',"is_last":' + (barstate.islast ? 'true' : 'false') + 
        ',"is_confirmed":' + (barstate.isconfirmed ? 'true' : 'false') + 
        ',"is_history":' + (barstate.ishistory ? 'true' : 'false') + 
        '}')
    string ohlcv_json = (
        '{"open":' + str.tostring(open) + 
        ',"high":' + str.tostring(high) + 
        ',"low":' + str.tostring(low) + 
        ',"close":' + str.tostring(close) + 
        ',"hl2":' + str.tostring(hl2) + 
        ',"hlc3":' + str.tostring(hlc3) + 
        ',"hlcc4":' + str.tostring(hlcc4) + 
        ',"ohlc4":' + str.tostring(ohlc4) + 
        ',"volume":' + str.tostring(volume) + '}')
    string base_json = ('"event_id":"' + id + '"' +
                        ',"bar_index":' + str.tostring(bar_index) + 
                        ',"last_bar_index":' + str.tostring(last_bar_index) + 
                        ',"time_tradingday":' + str.tostring(time_tradingday) + 
                        ',"time_close":' + str.tostring(time_close) + 
                        ',"session_is_first_bar":' + (session.isfirstbar ? 'true' : 'false') + 
                        ',"barstate":' + barstate_json + 
                        ',"ohlcv":' + ohlcv_json)
    string log = ''
    if id == ALERT_ID_UPDATE
        log := ('{' + base_json + 
                ',"retracements":' + f_logToJson(GLOBAL_pivotLevelsLogRetracements) + 
                ',"crossed_retracements":' + f_logToJson(GLOBAL_pivotLevelsLogCrossed) + '}')
    if id == ALERT_ID_EXHAUSTION
        log := ('{' + base_json + 
                ',"bull_candle":' + (bullCandle ? 'true' : 'false') + 
                ',"bear_candle":' + (bearCandle ? 'true' : 'false') + 
                ',"exhaust_vol":' + (exhaustVol ? 'true' : 'false') + '}')
    if id == ALERT_ID_VOLATILITY
        log := ('{' + base_json + 
                ',"bull_candle":' + (bullCandle ? 'true' : 'false') + 
                ',"bear_candle":' + (bearCandle ? 'true' : 'false') + 
                ',"high_volatility":' + (highVolatility ? 'true' : 'false') + '}')
    if id == ALERT_ID_CROSSING
        log := ('{' + base_json + 
                ',"crossed_retracements":' + f_logToJson(GLOBAL_pivotLevelsLogCrossed) + '}')
    log

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOT EXECUTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if INPUT_SHOW_FIB_TIME
    t_lineTZ_style = line.style_dotted
    t_lineTZ_width = 1
    t_lineTZ_color = color.new(COLOR_FG_MAIN, 50)
    referance = math.round(iEndBase2 - iMidPivot2)
    f_drawLineTZ(_x1=iMidPivot2 - referance        , _y1=pEndBase2, _x2=iMidPivot2 - referance       , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2                    , _y1=pEndBase2, _x2=iMidPivot2                   , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=t_lineTZ_color, _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance        , _y1=pEndBase2, _x2=iMidPivot2 + referance       , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=t_lineTZ_color, _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 2    , _y1=pEndBase2, _x2=iMidPivot2 + referance * 2 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 3    , _y1=pEndBase2, _x2=iMidPivot2 + referance * 3 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 5    , _y1=pEndBase2, _x2=iMidPivot2 + referance * 5 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 8    , _y1=pEndBase2, _x2=iMidPivot2 + referance * 8 , _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 13   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 13, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 21   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 21, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 34   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 34, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 55   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 55, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)
    f_drawLineTZ(_x1=iMidPivot2 + referance * 89   , _y1=pEndBase2, _x2=iMidPivot2 + referance * 89, _y2=pMidPivot2, _xloc=xloc.bar_index, _extend=extend.both, _c=COLOR_TZ , _s=t_lineTZ_style, _w=t_lineTZ_width)

    if INPUT_FIB_TZ_LABEL
        t_labelTZ_background = color.new(COLOR_FG_MAIN, 100)
        t_labelTZ_text_align = text.align_center
        t_labelTZ_size = size.small
        t_labelTZ_color = color.new(COLOR_FG_MAIN, 0)
        f_drawLabelTZ(_x=iMidPivot2 + referance * -1, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='-1', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 0 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='0' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=t_labelTZ_color, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 1 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='1' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=t_labelTZ_color, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 2 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='2' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 3 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='3' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 5 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='5' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 8 , _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='8' , _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 13, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='13', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 21, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='21', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 34, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='34', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 55, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='55', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')
        f_drawLabelTZ(_x=iMidPivot2 + referance * 89, _y=INPUT_FIB_TZ_POS_Y == 'Bottom' ? math.min(pEndBase2, pMidPivot2) : math.max(pEndBase2, pMidPivot2), _text='89', _xloc=xloc.bar_index, _yloc=yloc.price, _color=t_labelTZ_background, _style=fib_tzlp, _textcolor=COLOR_TZ, _size=t_labelTZ_size, _textalign=t_labelTZ_text_align, _tooltip='')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CACHED COORDINATE INITIALIZATION AND UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if not na(lineLast)
    currentX1 = line.get_x1(lineLast)
    currentY1 = line.get_y1(lineLast)
    currentX2 = line.get_x2(lineLast)
    currentY2 = line.get_y2(lineLast)
    
    if na(cachedIMidPivot) or pivotChanged
        cachedIMidPivot := iPrevPivot != 0 ? iPrevPivot : currentX1
        cachedPMidPivot := pPrevPivot != 0 ? pPrevPivot : currentY1
        cachedIEndBase := iLastPivot != 0 ? iLastPivot : currentX2
        cachedPEndBase := pLastPivot != 0 ? pLastPivot : currentY2
        cachedIMidPivot2 := iPrevPivot != 0 ? iPrevPivot : currentX1
        cachedPMidPivot2 := pPrevPivot != 0 ? pPrevPivot : currentY1
        cachedIEndBase2 := iLastPivot != 0 ? iLastPivot : currentX2
        cachedPEndBase2 := pLastPivot != 0 ? pLastPivot : currentY2

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRE-COMPUTED RSI DIVERGENCE VALUES (Pine v6 - must be called on every bar)
// These ta.valuewhen calls capture RSI and price at pivot changes for divergence detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float GLOBAL_rsi_at_pivot = ta.valuewhen(pivotChanged, GLOBAL_rsi, 0)
float GLOBAL_priceAtPivot = ta.valuewhen(pivotChanged, close, 0)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIBONACCI LEVEL DRAWING (Pine v6 - all functions called unconditionally)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pre-compute crossing detection for all fib levels (Pine v6 - must call on every bar)
// f_crossingLevel uses history reference, so we compute it unconditionally for ALL levels
for lvl in fibLevels
    // Always compute the price for this level (even if not shown)
    float pPivotDiff = math.abs(nz(cachedPMidPivot) - nz(cachedPEndBase))
    float lvl_price = nz(cachedPEndBase) < nz(cachedPMidPivot) ? 
         (INPUT_REVERSE ? nz(cachedPEndBase) : nz(cachedPMidPivot)) - (INPUT_REVERSE ? -1 : 1) * pPivotDiff * lvl.level : 
         (INPUT_REVERSE ? nz(cachedPEndBase) : nz(cachedPMidPivot)) + (INPUT_REVERSE ? -1 : 1) * pPivotDiff * lvl.level
    lvl_price := math.round_to_mintick(lvl_price)
    // Always call f_crossingLevel (uses history reference - must be called on every bar)
    lvl.crossed := f_crossingLevel(close, lvl_price)

// Determine redraw need unconditionally
bool needsFullRedraw = pivotChanged or (fibLevels.size() > 0 ? na(array.get(fibLevels, 0).ln) : false)
bool canDrawFibs = not na(cachedIMidPivot) and not na(cachedPEndBase)

// Always call draw method on every bar (Pine v6 - methods must be called consistently)
for lvl in fibLevels
    lvl.draw(cachedIMidPivot, cachedPMidPivot, bar_index, cachedPEndBase, needsFullRedraw and canDrawFibs)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKTESTING ENGINE - Historical Trade Simulation Loop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This logic runs on EVERY bar to:
// 1. Manage the current simulation (current_sim) through its lifecycle
// 2. Spawn new trades when ZigZag pivots are confirmed
// 3. Build history_log with completed trades for learning analysis
// Uses RAW Fib levels (cachedPMidPivot, cachedPEndBase) - no learned adjustments

// Calculate RAW Golden Pocket levels using confirmed pivots only
float raw_price_618 = f_get_level(FIB_GOLDEN_RATIO)
float raw_price_65  = f_get_level(FIB_GOLDEN_POCKET_H)
float raw_zone_top = math.max(raw_price_618, raw_price_65)
float raw_zone_btm = math.min(raw_price_618, raw_price_65)
float raw_entry_mid = (raw_zone_top + raw_zone_btm) / 2

// Determine direction from RAW confirmed pivots (not projections)
// EndBase < MidPivot = downswing completed = LONG expected
bool raw_is_long = cachedPEndBase < cachedPMidPivot
int raw_direction = raw_is_long ? 1 : -1

// Calculate RAW SL/TP using default multipliers (pure data, no learning)
float raw_atr = nz(ta.atr(INPUT_ATR_LENGTH), 1.0)
float raw_sl_buffer = raw_atr * INPUT_POS_SL_MULT
float raw_tp_target = cachedPMidPivot  // Conservative TP = back to MidPivot (swing start)

float raw_sl_price = raw_is_long ? cachedPEndBase - raw_sl_buffer : cachedPEndBase + raw_sl_buffer
float raw_tp_price = raw_tp_target

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PART A: Spawning New Trades (FIRST - before management)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CRITICAL: Spawn BEFORE management so new trades don't get processed on spawn bar
// Only spawn when:
// 1. pivotChanged is true (ZigZag confirmed)
// 2. current_sim is na (not already in a simulation)
// 3. We have valid cached pivot data
if pivotChanged and na(current_sim) and not na(cachedIMidPivot) and not na(cachedPEndBase)
    // Build initial state_mask: PENDING + direction flag
    int init_state = FLAG_PENDING
    if raw_is_long
        init_state := f_setFlag(init_state, FLAG_IS_LONG)
    
    // Create a new BacktestTrade with RAW levels
    current_sim := BacktestTrade.new(
        cachedIMidPivot,       // id: Pivot bar index
        init_state,            // state_mask: FLAG_PENDING + FLAG_IS_LONG if long
        raw_entry_mid,         // entry_price: mid of Golden Pocket (updated on activation)
        raw_zone_top,          // entry_top: zone upper boundary
        raw_zone_btm,          // entry_btm: zone lower boundary
        raw_sl_price,          // sl_price: initial SL
        raw_tp_price,          // tp_price: initial TP
        0.0,                   // mae: starts at 0
        0.0,                   // mfe: starts at 0
        na,                    // entry_bar: not yet entered
        na                     // exit_bar: not yet exited
    )
    
    // DEBUG: Log trade spawn
    log.info("BACKTEST SPAWN: {0} trade #{1}, Zone=[{2}, {3}], SL={4}, TP={5}", 
             raw_is_long ? "LONG" : "SHORT", cachedIMidPivot, 
             raw_zone_btm, raw_zone_top, raw_sl_price, raw_tp_price)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PART B: Managing the Current Simulation (runs every bar AFTER spawn)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CRITICAL: Skip processing on the SAME bar the trade was spawned (pivotChanged bar)
// This prevents the trade from being immediately killed or activated on spawn bar
bool skip_this_bar = pivotChanged  // Don't process newly spawned trades on their creation bar

if not na(current_sim) and not skip_this_bar
    bool sim_is_long = f_hasFlag(current_sim.state_mask, FLAG_IS_LONG)
    
    // PENDING: Waiting for price to touch the Golden Pocket zone
    if f_hasFlag(current_sim.state_mask, FLAG_PENDING)
        bool zone_touched = false
        bool sl_breached_before_entry = false
        
        if sim_is_long  // LONG: waiting for price to dip INTO zone
            zone_touched := low <= current_sim.entry_top and high >= current_sim.entry_btm
            sl_breached_before_entry := low <= current_sim.sl_price and not zone_touched
        else  // SHORT: waiting for price to rise INTO zone
            zone_touched := high >= current_sim.entry_btm and low <= current_sim.entry_top
            sl_breached_before_entry := high >= current_sim.sl_price and not zone_touched
        
        // Handle SL breach before entry (trade invalidated)
        if sl_breached_before_entry
            log.info("BACKTEST KILLED: {0} trade #{1} - SL breached before entry", 
                     sim_is_long ? "LONG" : "SHORT", current_sim.id)
            current_sim := na
        // If zone touched, activate the trade (transition: PENDING -> ACTIVE)
        else if zone_touched
            current_sim.state_mask := f_setLifecycle(current_sim.state_mask, FLAG_ACTIVE)
            current_sim.state_mask := f_setFlag(current_sim.state_mask, FLAG_ZONE_TOUCHED)
            current_sim.entry_bar := bar_index
            current_sim.entry_price := sim_is_long ? current_sim.entry_top : current_sim.entry_btm
            current_sim.mae := 0.0
            current_sim.mfe := 0.0
            log.info("BACKTEST ACTIVATED: {0} trade #{1} at entry={2}", 
                     sim_is_long ? "LONG" : "SHORT", current_sim.id, current_sim.entry_price)
    
    // ACTIVE: In trade, tracking MAE/MFE and checking for exit
    else if f_hasFlag(current_sim.state_mask, FLAG_ACTIVE)
        // Update MAE (Max Adverse Excursion) - worst price against us
        if sim_is_long  // LONG: adverse = price going DOWN
            float adverse = current_sim.entry_price - low
            current_sim.mae := math.max(current_sim.mae, adverse)
        else  // SHORT: adverse = price going UP
            float adverse = high - current_sim.entry_price
            current_sim.mae := math.max(current_sim.mae, adverse)
        
        // Update MFE (Max Favorable Excursion) - best price in our favor
        if sim_is_long  // LONG: favorable = price going UP
            float favorable = high - current_sim.entry_price
            current_sim.mfe := math.max(current_sim.mfe, favorable)
        else  // SHORT: favorable = price going DOWN
            float favorable = current_sim.entry_price - low
            current_sim.mfe := math.max(current_sim.mfe, favorable)
        
        // Check for exit conditions (HTF level - used for initial screening)
        bool sl_hit = sim_is_long ? (low <= current_sim.sl_price) : (high >= current_sim.sl_price)
        bool tp_hit = sim_is_long ? (high >= current_sim.tp_price) : (low <= current_sim.tp_price)
        
        // Handle exits (transition: ACTIVE -> CLOSED)
        if sl_hit or tp_hit
            current_sim.state_mask := f_setLifecycle(current_sim.state_mask, FLAG_CLOSED)
            current_sim.exit_bar := bar_index
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // INTRABAR PRECISION: Resolve TP/SL order chronologically using LTF data
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            bool trade_won = false
            bool used_ltf_resolution = false
            int ltf_hit_idx = -1
            
            if sl_hit and tp_hit
                // Both TP and SL hit in same HTF bar - need to determine which came first
                if INPUT_INTRABAR_ENABLED and array.size(GLOBAL_ltfHighs) > 0
                    // Use intrabar resolution for chronological determination
                    bool conservative = INPUT_INTRABAR_TIEBREAK == "Conservative"
                    [ltf_outcome, ltf_resolved, hit_idx] = f_resolveIntrabar(GLOBAL_ltfHighs, GLOBAL_ltfLows, sim_is_long, current_sim.sl_price, current_sim.tp_price, conservative)
                    
                    if ltf_resolved
                        trade_won := ltf_outcome == 1  // 1 = TP first, -1 = SL first
                        used_ltf_resolution := true
                        ltf_hit_idx := hit_idx
                        current_sim.state_mask := f_setFlag(current_sim.state_mask, FLAG_LTF_RESOLVED)
                    else
                        // LTF data available but no decisive outcome - use HTF fallback
                        float dist_to_sl = math.abs(open - current_sim.sl_price)
                        float dist_to_tp = math.abs(open - current_sim.tp_price)
                        trade_won := dist_to_tp < dist_to_sl * 0.5
                else
                    // Intrabar disabled or no LTF data - use HTF heuristic (fallback per FR-7)
                    float dist_to_sl = math.abs(open - current_sim.sl_price)
                    float dist_to_tp = math.abs(open - current_sim.tp_price)
                    trade_won := dist_to_tp < dist_to_sl * 0.5
            else
                // Only one level hit - straightforward resolution
                trade_won := tp_hit
            
            // Set outcome flags using f_setOutcome for mutual exclusion (SL_HIT xor TP_HIT)
            if trade_won
                current_sim.state_mask := f_setOutcome(current_sim.state_mask, FLAG_TP_HIT)
                current_sim.state_mask := f_setFlag(current_sim.state_mask, FLAG_WON)
            else
                current_sim.state_mask := f_setOutcome(current_sim.state_mask, FLAG_SL_HIT)
            
            // Push completed trade to history_log
            array.push(history_log, current_sim)
            
            // DEBUG: Log trade completion with intrabar resolution info
            if used_ltf_resolution
                log.info("BACKTEST CLOSED (LTF): {0} #{1}, Won={2}, LTF_idx={3}/{4}, MAE={5}, MFE={6}", 
                         sim_is_long ? "LONG" : "SHORT", current_sim.id, trade_won,
                         ltf_hit_idx, array.size(GLOBAL_ltfHighs), current_sim.mae, current_sim.mfe)
            else
                log.info("BACKTEST CLOSED (HTF): {0} #{1}, Entry={2}, Won={3}, MAE={4}, MFE={5}", 
                         sim_is_long ? "LONG" : "SHORT", 
                         current_sim.id, current_sim.entry_price, trade_won, 
                         current_sim.mae, current_sim.mfe)
            
            // Clear current simulation
            current_sim := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTIMIZATION ENGINE - Calculate Stats from Backtest History (runs on barstate.islast)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// By this point, history_log contains all completed trades from chart history
// Now we analyze them to optimize the current real-time position

if barstate.islast and array.size(history_log) > 0 and not bt_stats_ready
    int total = array.size(history_log)
    int wins = 0
    float sum_winning_mae = 0.0
    float sum_losing_mae = 0.0
    int losing_count = 0
    
    // Loop through all completed trades
    for i = 0 to total - 1
        BacktestTrade trade = array.get(history_log, i)
        if f_hasFlag(trade.state_mask, FLAG_WON)
            wins += 1
            sum_winning_mae += trade.mae
        else
            losing_count += 1
            sum_losing_mae += trade.mae
    
    // Calculate statistics
    bt_total_trades := total
    bt_winning_trades := wins
    bt_win_rate := total > 0 ? float(wins) / float(total) : 0.0
    bt_avg_winning_mae := wins > 0 ? sum_winning_mae / float(wins) : 0.0
    bt_avg_losing_mae := losing_count > 0 ? sum_losing_mae / float(losing_count) : 0.0
    
    // Smart SL offset: Avg Winning MAE * 1.1 (give 10% buffer beyond typical drawdown)
    bt_smart_sl_offset := bt_avg_winning_mae * 1.1
    
    // Confidence flag: Low confidence if win rate < 40%
    bt_low_confidence := bt_win_rate < 0.40
    
    // Mark stats as ready
    bt_stats_ready := true
    
    // Log optimization results
    log.info("BACKTEST OPTIMIZATION: {0} trades, {1}% WR, Avg Winner MAE={2}, Smart SL Offset={3}, LowConf={4}", 
             bt_total_trades, math.round(bt_win_rate * 100), bt_avg_winning_mae, bt_smart_sl_offset, bt_low_confidence)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATISTICAL POSITION ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box box_entry = na
var line line_sl = na
var line line_smart_sl = na  // Smart SL line (based on backtest MAE optimization)
var line line_tp = na
var label lbl_risk = na

// Use effective pivots (projection if active, otherwise confirmed)
if INPUT_SHOW_POS and not na(effIMidPivot) and not na(effPEndBase)
    // Determine if this is a projection update (for visual feedback)
    bool isProjection = projectionActive
    
    // When EndBase > MidPivot, the last swing was UP (upswing completed), so we expect a retracement DOWN into the pocket â†’ SHORT
    // When EndBase < MidPivot, the last swing was DOWN (downswing completed), so we expect a retracement UP into the pocket â†’ LONG
    // f_get_level_eff uses effective pivots (projection or confirmed)
    bool is_long_setup = effPEndBase < effPMidPivot  // EndBase < MidPivot = downswing completed = LONG retracement expected
    float price_618 = f_get_level_eff(FIB_GOLDEN_RATIO)
    float price_65  = f_get_level_eff(FIB_GOLDEN_POCKET_H)
    
    // Reuse global ATR calculation (i_weightedATR = ta.atr(INPUT_ATR_LENGTH) * INPUT_ATR_MULT)
    float current_atr = GLOBAL_rawAtr
    
    // Dynamic SL: Use ATR percentile to scale SL buffer based on volatility regime
    // Use global pre-computed atr_percentile (C-optimized, called on every bar)
    float atr_percentile = GLOBAL_atrPercentile  // 0 = lowest vol, 100 = highest vol
    // Scale multiplier: at 50th percentile = base mult, at 0 = -50%, at 100 = +50%
    float dynamic_scale = INPUT_POS_SL_DYNAMIC ? (1 + (atr_percentile - 50) / 100) : 1.0
    
    // Phase 2: Use learned SL multiplier if enabled and sufficient data
    // GLOBAL_learnedSlMult is computed from: avg MAE of winning trades + SL_BUFFER_ATR buffer
    float base_sl_mult = INPUT_POS_SL_MULT
    bool use_learned = INPUT_USE_LEARNED_SL and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_SL and GLOBAL_learnedSlMult > 0
    if use_learned
        base_sl_mult := GLOBAL_learnedSlMult
        // Validation: if losing trades had larger MAE, consider widening SL
        // Only if losing MAE is significantly larger than winning MAE (indicating stops too tight)
        if GLOBAL_learnedLosingMae > 0 and GLOBAL_learnedLosingMae > GLOBAL_learnedAvgMae * SL_LOSING_MAE_FACTOR
            // Blend: use midpoint between learned SL and losing MAE to reduce premature stops
            base_sl_mult := (GLOBAL_learnedSlMult + GLOBAL_learnedLosingMae) / 2
    float effective_sl_mult = base_sl_mult * dynamic_scale
    
    // SL is placed beyond the swing extreme (EndBase) + ATR buffer
    // LONG: EndBase is swing LOW, SL goes below it
    // SHORT: EndBase is swing HIGH, SL goes above it
    float sl_price = is_long_setup ? effPEndBase - (current_atr * effective_sl_mult) : effPEndBase + (current_atr * effective_sl_mult)
    
    // Phase 3: Calculate both TP prices for comparison learning
    // TP targets: Conservative = back to MidPivot (start of swing), Aggressive = 1.272 extension beyond MidPivot
    // LONG: TP is ABOVE entry (toward and beyond MidPivot which is the HIGH)
    // SHORT: TP is BELOW entry (toward and beyond MidPivot which is the LOW)
    float tp_conservative = effPMidPivot
    // Extension goes BEYOND MidPivot (not calculated by f_get_level_eff which only does retracements)
    float swing_range = math.abs(effPMidPivot - effPEndBase)
    float extension_amount = swing_range * (FIB_EXTENSION_1272 - 1.0)  // The amount beyond 100%
    float tp_aggressive = is_long_setup ? effPMidPivot + extension_amount : effPMidPivot - extension_amount
    
    // Calculate distances for MFE comparison
    float cons_dist = math.abs(tp_conservative - (price_618 + price_65) / 2)
    float aggr_dist = math.abs(tp_aggressive - (price_618 + price_65) / 2)
    float mfe_dist = GLOBAL_learnedAvgMfe * current_atr  // MFE converted to price distance
    
    // Determine which TP mode to use (Phase 3: can be learned)
    bool use_aggressive_tp = INPUT_POS_TP_MODE == 'Aggressive'
    bool has_learned_tp = INPUT_LEARN_TP and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_learned_tp
        // Prefer learned EV-based decision if available
        if GLOBAL_learnedAggrEv != 0 or GLOBAL_learnedConsEv != 0
            use_aggressive_tp := GLOBAL_learnedTpAggressive
        // Fallback: if avg MFE exceeds conservative TP distance, use aggressive
        else if GLOBAL_learnedAvgMfe > 0 and mfe_dist > cons_dist * 1.2
            use_aggressive_tp := true
    float tp_price = use_aggressive_tp ? tp_aggressive : tp_conservative
    
    // Zone boundaries
    float box_top = math.max(price_618, price_65)
    float box_bottom = math.min(price_618, price_65)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LEARNING ENGINE: Near-miss detection and adaptive zone buffer
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Calculate adaptive zone buffer based on historical near-misses
    float zone_width = box_top - box_bottom
    // Start with previously learned buffer if available, otherwise base
    float adaptive_buffer = GLOBAL_learnedZoneBuffer > 0 ? GLOBAL_learnedZoneBuffer : INPUT_ZONE_BUFFER_BASE
    
    if INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_BUFFER
        // Count near-misses in recent history
        int near_misses = 0
        int total_valid = 0
        int max_check = math.min(INPUT_LEARNING_SAMPLES - 1, GLOBAL_setupHistory.size() - 1)
        for i = 0 to max_check
            SetupRecord rec = GLOBAL_setupHistory.get(i)
            if na(rec)
                continue
            if rec.closest_approach > 0 and rec.closest_approach < INPUT_NEAR_MISS_THRESH and not f_hasFlag(rec.state_mask, FLAG_ZONE_TOUCHED)
                near_misses += 1
            total_valid += 1
        
        // If >NEAR_MISS_RATE_THRESH are near-misses, expand zone proportionally
        float miss_rate = total_valid > 0 ? float(near_misses) / float(total_valid) : 0.0
        // Scale buffer: miss_rate * multiplier, capped at max
        float learned_buffer = 0.0
        if miss_rate > NEAR_MISS_RATE_THRESH
            learned_buffer := math.min(miss_rate * NEAR_MISS_BUFFER_MULT, NEAR_MISS_BUFFER_MAX)
        // Also consider average near-miss distance to determine buffer size
        // If near-misses are very close, expand more aggressively
        if near_misses > 0
            float avg_approach = 0.0
            int approach_count = 0
            for j = 0 to max_check
                SetupRecord rec2 = GLOBAL_setupHistory.get(j)
                if not na(rec2) and rec2.closest_approach > 0 and rec2.closest_approach < INPUT_NEAR_MISS_THRESH and not f_hasFlag(rec2.state_mask, FLAG_ZONE_TOUCHED)
                    avg_approach += rec2.closest_approach
                    approach_count += 1
            if approach_count > 0
                avg_approach := avg_approach / float(approach_count)
                // If avg near-miss is < NEAR_MISS_CLOSE_THRESH, add extra buffer
                if avg_approach < NEAR_MISS_CLOSE_THRESH
                    learned_buffer += (NEAR_MISS_CLOSE_THRESH - avg_approach) * 10  // Up to +3% extra
        adaptive_buffer := math.max(INPUT_ZONE_BUFFER_BASE, learned_buffer)
        GLOBAL_learnedZoneBuffer := adaptive_buffer
        GLOBAL_nearMissCount := near_misses
        GLOBAL_totalSetups := total_valid
    
    // Apply adaptive buffer to zone boundaries
    float buffer_amount = zone_width * (adaptive_buffer / 100)
    float adjusted_box_top = box_top + buffer_amount
    float adjusted_box_bottom = box_bottom - buffer_amount
    
    // DEBUG: Log learning engine values on bar confirmation
    if barstate.isconfirmed and INPUT_LEARNING_ENABLED
        int sample_count = GLOBAL_setupHistory.size()
        log.info("LEARNING: samples={0}, zone_buffer={1}%, sl_mult={2}, win_rate={3}%, sl_price={4}, tp_price={5}", 
                 sample_count, adaptive_buffer, effective_sl_mult, GLOBAL_learnedWinRate * 100, sl_price, tp_price)
    
    // Near-miss detection: how close did price get to the zone?
    // Distance is positive when price is OUTSIDE the zone, 0 or negative when INSIDE
    float dist_to_zone_pct = 0.0
    bool price_outside_zone = not (low <= adjusted_box_top and high >= adjusted_box_bottom)
    
    if price_outside_zone
        if is_long_setup
            // For longs (after downswing), zone is above current price. Measure how close high got to zone bottom.
            if high < adjusted_box_bottom
                dist_to_zone_pct := ((adjusted_box_bottom - high) / adjusted_box_bottom) * 100
        else
            // For shorts (after upswing), zone is below current price. Measure how close low got to zone top.
            if low > adjusted_box_top
                dist_to_zone_pct := ((low - adjusted_box_top) / adjusted_box_top) * 100
    // else: price is inside zone, distance = 0 (not a near-miss, it's a touch)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIRMED TRADE TRACKING (Learning Engine - NOT for projections)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Track minimum distance for CONFIRMED setup only (not projections)
    if not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        GLOBAL_activeTrade.min_distance := math.min(GLOBAL_activeTrade.min_distance, dist_to_zone_pct)
    
    // Zone activation: price is inside the (adjusted) Golden Pocket
    // For CONFIRMED trades: use stored zone boundaries for consistent tracking
    // For DISPLAY: use current calculated boundaries
    bool in_zone = false
    bool zone_entry = false
    
    // Check against CONFIRMED trade boundaries (for learning)
    bool confirmed_in_zone = false
    bool confirmed_zone_entry = false
    if not na(GLOBAL_activeTrade.setup_bar)
        confirmed_in_zone := low <= GLOBAL_activeTrade.zone_top and high >= GLOBAL_activeTrade.zone_bottom
        confirmed_zone_entry := confirmed_in_zone and not f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_ZONE_TOUCHED)
    
    // Check against CURRENT boundaries (for display)
    in_zone := low <= adjusted_box_top and high >= adjusted_box_bottom
    zone_entry := in_zone and (na(GLOBAL_activeTrade.setup_bar) or not f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_ZONE_TOUCHED))
    
    // Track if zone was touched for CONFIRMED setup only (not projections)
    if confirmed_in_zone and not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_ZONE_TOUCHED)
    
    // Track SL/TP hits for CONFIRMED setup only (not projections)
    // CRITICAL: Only track SL/TP AFTER zone is touched (entry occurred)
    // Use STORED sl/tp prices from setup formation for consistent tracking
    // CONSERVATIVE EXECUTION: If bar covers both SL and TP, assume SL hit UNLESS
    //   Open is at least 2x closer to TP than SL (dist_to_tp < dist_to_sl * 0.5)
    if not na(GLOBAL_activeTrade.setup_bar) and f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_ZONE_TOUCHED) and not isProjection
        if f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_IS_LONG)
            bool sl_touched = low <= GLOBAL_activeTrade.sl_price
            bool tp_touched = high >= GLOBAL_activeTrade.tp_price
            
            // Outcome detection with mutual exclusion (first outcome wins, per FR-4 invariant)
            // Skip if outcome already determined
            if not f_hasAny(GLOBAL_activeTrade.state_mask, MASK_OUTCOME)
                if sl_touched and tp_touched
                    // Conservative execution: when both hit in same bar, prioritize capital preservation
                    // Check if Open was closer to TP - only then assume TP hit first
                    float dist_to_sl = math.abs(open - GLOBAL_activeTrade.sl_price)
                    float dist_to_tp = math.abs(open - GLOBAL_activeTrade.tp_price)
                    // TP only wins if Open is significantly closer (50%+ closer) to TP
                    if dist_to_tp < dist_to_sl * 0.5
                        GLOBAL_activeTrade.state_mask := f_setOutcome(GLOBAL_activeTrade.state_mask, FLAG_TP_HIT)
                        GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_WON)
                    else
                        GLOBAL_activeTrade.state_mask := f_setOutcome(GLOBAL_activeTrade.state_mask, FLAG_SL_HIT)
                else if sl_touched
                    GLOBAL_activeTrade.state_mask := f_setOutcome(GLOBAL_activeTrade.state_mask, FLAG_SL_HIT)
                else if tp_touched
                    GLOBAL_activeTrade.state_mask := f_setOutcome(GLOBAL_activeTrade.state_mask, FLAG_TP_HIT)
                    GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_WON)
            
            // Phase 3: Track BOTH TP modes independently (for learning comparison)
            // These are analytics flags, not mutually exclusive with SL/TP outcome
            if high >= GLOBAL_activeTrade.tp_cons
                GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_CONS_TP_HIT)
            if high >= GLOBAL_activeTrade.tp_aggr
                GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_AGGR_TP_HIT)
        else
            bool sl_touched = high >= GLOBAL_activeTrade.sl_price
            bool tp_touched = low <= GLOBAL_activeTrade.tp_price
            
            // Outcome detection with mutual exclusion (first outcome wins, per FR-4 invariant)
            // Skip if outcome already determined
            if not f_hasAny(GLOBAL_activeTrade.state_mask, MASK_OUTCOME)
                if sl_touched and tp_touched
                    // Conservative execution: when both hit in same bar, prioritize capital preservation
                    float dist_to_sl = math.abs(open - GLOBAL_activeTrade.sl_price)
                    float dist_to_tp = math.abs(open - GLOBAL_activeTrade.tp_price)
                    if dist_to_tp < dist_to_sl * 0.5
                        GLOBAL_activeTrade.state_mask := f_setOutcome(GLOBAL_activeTrade.state_mask, FLAG_TP_HIT)
                        GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_WON)
                    else
                        GLOBAL_activeTrade.state_mask := f_setOutcome(GLOBAL_activeTrade.state_mask, FLAG_SL_HIT)
                else if sl_touched
                    GLOBAL_activeTrade.state_mask := f_setOutcome(GLOBAL_activeTrade.state_mask, FLAG_SL_HIT)
                else if tp_touched
                    GLOBAL_activeTrade.state_mask := f_setOutcome(GLOBAL_activeTrade.state_mask, FLAG_TP_HIT)
                    GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_WON)
            
            // Phase 3: Track BOTH TP modes independently (for learning comparison)
            // These are analytics flags, not mutually exclusive with SL/TP outcome
            if low <= GLOBAL_activeTrade.tp_cons
                GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_CONS_TP_HIT)
            if low <= GLOBAL_activeTrade.tp_aggr
                GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_AGGR_TP_HIT)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXTENDED LEARNING: MAE/MFE Tracking (Phase 1) - CONFIRMED TRADES ONLY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Track entry when zone is first touched (CONFIRMED trades only, not projections)
    if confirmed_zone_entry and not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        if na(GLOBAL_activeTrade.entry_bar)  // Only capture first touch
            GLOBAL_activeTrade.entry_bar := bar_index
            GLOBAL_activeTrade.entry_price := close
            GLOBAL_activeTrade.rsi_at_entry := GLOBAL_rsi  // Use global pre-computed RSI
    
    // Track MAE/MFE from entry (only after zone touched, CONFIRMED trades only)
    if not na(GLOBAL_activeTrade.entry_bar) and not na(GLOBAL_activeTrade.entry_price) and not na(GLOBAL_activeTrade.atr_at_setup) and not isProjection
        if not f_hasAny(GLOBAL_activeTrade.state_mask, MASK_OUTCOME)
            if f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_IS_LONG)
                // MAE: How much price moved against us (low - entry, negative is adverse)
                float adverse = (GLOBAL_activeTrade.entry_price - low) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_adverse := math.max(GLOBAL_activeTrade.max_adverse, adverse)
                // MFE: How much price moved in our favor (high - entry)
                float favorable = (high - GLOBAL_activeTrade.entry_price) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_favorable := math.max(GLOBAL_activeTrade.max_favorable, favorable)
            else
                // Short: adverse is when price goes up, favorable is when price goes down
                float adverse = (high - GLOBAL_activeTrade.entry_price) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_adverse := math.max(GLOBAL_activeTrade.max_adverse, adverse)
                float favorable = (GLOBAL_activeTrade.entry_price - low) / GLOBAL_activeTrade.atr_at_setup
                GLOBAL_activeTrade.max_favorable := math.max(GLOBAL_activeTrade.max_favorable, favorable)
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TASK 3 FIX: Time Decay Calculation
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PROBLEM: Previously used effIMidPivot which causes decay to "jump" when projection becomes confirmed.
    //          When projection mode: pivot is "now" (bar_index), decay = 0 (Fresh)
    //          When confirmed: pivot bar jumps back by pivotLength, decay jumps to Stale instantly
    //
    // SOLUTION: Use creation_bar for confirmed trades (tracks when WE created the setup)
    //           For projections: decay = 0 (always Fresh since we're projecting in real-time)
    //           For confirmed: decay = bar_index - creation_bar (smooth progression)
    //
    // NOTE: creation_bar is set to bar_index when pivotChanged fires, so the FIRST bar after
    //       confirmation starts at 0 bars since creation, then increments smoothly.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    int bars_since_creation = 0
    if isProjection
        // Projection mode: decay is always 0 (Fresh) since we're projecting in real-time
        bars_since_creation := 0
    else if not na(GLOBAL_activeTrade.creation_bar)
        // Confirmed mode: use stored creation_bar for smooth decay progression
        bars_since_creation := bar_index - GLOBAL_activeTrade.creation_bar
    else
        // Fallback: use effIMidPivot if no active trade (shouldn't happen often)
        bars_since_creation := bar_index - effIMidPivot
    
    // Dynamic time thresholds: scale Fib sequence by learned avg_bars if available
    float time_scale = 1.0
    bool has_learned_time = INPUT_LEARN_DECAY and INPUT_LEARNING_ENABLED and GLOBAL_learnedAvgBars > 0
    if has_learned_time
        // Reference: default assumes TIME_DECAY_REFERENCE_BARS is "mid" point (Fib threshold 2)
        time_scale := math.max(TIME_DECAY_SCALE_MIN, math.min(TIME_DECAY_SCALE_MAX, float(GLOBAL_learnedAvgBars) / TIME_DECAY_REFERENCE_BARS))
    
    // Fibonacci time thresholds and decay calculation (scaled by learned timing)
    // Each threshold passed reduces confidence by decay rate
    int t1 = int(TIME_DECAY_T1 * time_scale)
    int t2 = int(TIME_DECAY_T2 * time_scale)
    int t3 = int(TIME_DECAY_T3 * time_scale)
    int t4 = int(TIME_DECAY_T4 * time_scale)
    int t5 = int(TIME_DECAY_T5 * time_scale)
    int t6 = int(89 * time_scale)
    
    int time_phase = bars_since_creation >= t6 ? 6 : 
                     bars_since_creation >= t5 ? 5 : 
                     bars_since_creation >= t4 ? 4 : 
                     bars_since_creation >= t3 ? 3 : 
                     bars_since_creation >= t2 ? 2 : 
                     bars_since_creation >= t1 ? 1 : 0
    
    // Phase 3: Use learned decay rate if enabled and sufficient data
    float decay_rate = TIME_DECAY_DEFAULT_RATE
    bool has_learned_decay = INPUT_LEARN_DECAY and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_learned_decay and GLOBAL_learnedDecayRate > 0
        decay_rate := GLOBAL_learnedDecayRate
    float time_decay = INPUT_POS_TIME_DECAY ? math.pow(decay_rate, time_phase) : 1.0
    bool zone_expired = INPUT_POS_TIME_DECAY and time_phase >= 5  // Expired after t5+ bars
    
    // Time decay indicator for display (show learned rate if different)
    string decay_indicator = has_learned_decay ? ICON_HOURGLASS + "*" : ICON_HOURGLASS
    string time_status = not INPUT_POS_TIME_DECAY ? "" : 
                         time_phase == 0 ? " " + decay_indicator + TEXT_FRESH : 
                         time_phase <= 2 ? " " + decay_indicator + str.tostring(int(time_decay * 100)) + "%" : 
                         time_phase <= 4 ? " " + decay_indicator + TEXT_STALE : " " + decay_indicator + "EXPIRED"
    
    // SL breach invalidation (also invalidate on zone expiration)
    // Use CONFIRMED trade direction and SL for consistency (not projection)
    bool sl_check_long = not na(GLOBAL_activeTrade.setup_bar) ? f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_IS_LONG) : is_long_setup
    float sl_check_price = not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.sl_price : sl_price
    bool sl_breached = sl_check_long ? close < sl_check_price : close > sl_check_price
    bool is_invalid = sl_breached or zone_expired
    
    // Volume confluence
    bool vol_confirm = exhaustVol or crossover_exhaustion
    
    // RSI Divergence Confluence - Use global pre-computed values (Pine v6 best practice)
    float rsi = GLOBAL_rsi
    float rsi_at_pivot = GLOBAL_rsi_at_pivot
    float price_at_pivot = GLOBAL_priceAtPivot
    
    // Use CONFIRMED trade direction for divergence check (for learning consistency)
    bool check_long = not na(GLOBAL_activeTrade.setup_bar) ? f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_IS_LONG) : is_long_setup
    // Bullish divergence: price made lower low but RSI made higher low (momentum building)
    bool bullish_div = check_long and close < price_at_pivot and rsi > rsi_at_pivot
    // Bearish divergence: price made higher high but RSI made lower high (momentum fading)
    bool bearish_div = not check_long and close > price_at_pivot and rsi < rsi_at_pivot
    bool rsi_confirm = INPUT_POS_RSI_DIV ? ((check_long and bullish_div) or (not check_long and bearish_div)) : false
    
    // Capture RSI divergence flag for learning (CONFIRMED trades only, not projections)
    if confirmed_zone_entry and not na(GLOBAL_activeTrade.setup_bar) and not isProjection
        if bullish_div or bearish_div
            GLOBAL_activeTrade.state_mask := f_setFlag(GLOBAL_activeTrade.state_mask, FLAG_HAD_RSI_DIV)
    
    // Combined confluence: volume OR RSI divergence
    bool full_confirm = vol_confirm or rsi_confirm
    
    // Determine box color based on state (apply time decay to transparency)
    // Use current calculation for display (projection or confirmed)
    bool active_is_long = isProjection ? is_long_setup : (not na(GLOBAL_activeTrade.setup_bar) ? f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_IS_LONG) : is_long_setup)
    color base_color = active_is_long ? COLOR_BLUE : COLOR_RED
    int decay_trans_add = int((1 - time_decay) * 20)  // Add 0-20 transparency based on decay
    int bg_trans = is_invalid ? 90 : (in_zone ? (full_confirm ? 45 : (vol_confirm or rsi_confirm ? 55 : 65)) : 75) + decay_trans_add
    int border_trans = is_invalid ? 80 : (rsi_confirm ? 10 : 25) + decay_trans_add
    color bg_col = is_invalid ? color.new(COLOR_GRAY, math.min(bg_trans, 95)) : color.new(base_color, math.min(bg_trans, 95))
    color border_col = is_invalid ? color.new(COLOR_GRAY, math.min(border_trans, 90)) : color.new(base_color, math.min(border_trans, 90))
    
    // R:R calculation - use current calculated values (with learning adjustments)
    float mid_entry = (price_618 + price_65) / 2
    float risk = math.abs(mid_entry - sl_price)
    float reward = math.abs(tp_price - mid_entry)
    float rr_ratio = risk > 0 ? reward / risk : 0
    
    // Kelly Criterion: f* = (p * b - q) / b where p = win rate, q = 1-p, b = R:R ratio
    // This gives optimal fraction of bankroll to risk for geometric growth maximization
    // Apply time decay to win rate (stale setups have lower probability)
    float p_base = INPUT_POS_WIN_RATE / 100  // Convert percentage to decimal
    
    // Calculate empirical win rate from learning history
    // OPTIMIZATION: Only recalculate when new trade was recorded (flag set in should_record block)
    float p_empirical = p_base
    if INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_SL and GLOBAL_learningNeedsRecalc
        // Reset flag - we're about to recalculate
        GLOBAL_learningNeedsRecalc := false
        
        // Phase 1 counters
        int wins = 0
        int losses = 0
        float total_mae = 0.0
        float total_mfe = 0.0
        int total_bars = 0
        int outcome_count = 0
        // Phase 2 counters: RSI divergence effectiveness
        int wins_with_div = 0
        int losses_with_div = 0
        int wins_without_div = 0
        int losses_without_div = 0
        // Phase 2 counters: Direction-specific win rates
        int wins_long = 0
        int losses_long = 0
        int wins_short = 0
        int losses_short = 0
        // Phase 2: Losing trade MAE (to find where SL should have been)
        float losing_mae_total = 0.0
        int losing_count = 0
        // Phase 3: TP mode comparison counters
        int cons_tp_wins = 0       // Setups where Conservative TP was hit (without SL hit)
        int cons_tp_total = 0      // Total setups with valid Conservative TP tracking
        int aggr_tp_wins = 0       // Setups where Aggressive TP was hit (without SL hit)
        int aggr_tp_total = 0      // Total setups with valid Aggressive TP tracking
        // Phase 3: Time decay learning (bars_to_outcome distribution)
        int early_wins = 0         // Wins within first TIME_DECAY_T2 bars
        int late_wins = 0          // Wins after TIME_DECAY_T3 bars
        // Phase 4: Regime detection and performance metrics
        int wins_high_vol = 0      // Wins in high volatility regime (>VOL_REGIME_HIGH_THRESH percentile)
        int losses_high_vol = 0    // Losses in high volatility regime
        int wins_low_vol = 0       // Wins in low volatility regime (<40 percentile)
        int losses_low_vol = 0     // Losses in low volatility regime
        float total_r_won = 0.0    // Total R won (1R per win = TP hit)
        float total_r_lost = 0.0   // Total R lost (1R per loss = SL hit)
        int consecutive_wins = 0   // Consecutive wins from most recent
        int consecutive_losses = 0 // Consecutive losses from most recent
        int max_win_streak = 0     // Maximum winning streak found
        int max_loss_streak = 0    // Maximum losing streak found
        int streak_state = 0       // 0=unknown, 1=in_win_streak, -1=in_loss_streak
        bool streak_frozen = false // Once streak is broken, stop updating current streak
        
        // Iterate from NEWEST to OLDEST using CircularBuffer (get(0) = newest)
        int history_size = GLOBAL_setupHistory.size()
        int samples_to_check = math.min(INPUT_LEARNING_SAMPLES, history_size)
        for idx = 0 to samples_to_check - 1
            // CircularBuffer: idx=0 is newest, idx=samples_to_check-1 is oldest in window
            SetupRecord rec = GLOBAL_setupHistory.get(idx)
            // Skip if na (buffer not yet full at this index)
            if na(rec)
                continue
            // Setups where zone was never touched are "no trade" - don't affect win rate
            if not f_hasFlag(rec.state_mask, FLAG_ZONE_TOUCHED)
                continue  // Skip - no entry, no trade
            
            if f_hasFlag(rec.state_mask, FLAG_TP_HIT) and not f_hasFlag(rec.state_mask, FLAG_SL_HIT)
                wins += 1
                // Aggregate winning trade metrics for MAE/MFE analysis
                total_mae += rec.max_adverse
                total_mfe += rec.max_favorable
                total_bars += rec.bars_to_outcome
                outcome_count += 1
                // Phase 2: RSI divergence stratification
                if f_hasFlag(rec.state_mask, FLAG_HAD_RSI_DIV)
                    wins_with_div += 1
                else
                    wins_without_div += 1
                // Phase 2: Direction stratification
                if f_hasFlag(rec.state_mask, FLAG_IS_LONG)
                    wins_long += 1
                else
                    wins_short += 1
                // Phase 3: Time decay learning (when do wins happen?)
                if rec.bars_to_outcome <= TIME_DECAY_T2
                    early_wins += 1
                else if rec.bars_to_outcome > TIME_DECAY_T3
                    late_wins += 1
                // Phase 4: Volatility regime stratification
                if rec.vol_percentile >= VOL_REGIME_HIGH_THRESH
                    wins_high_vol += 1
                else if rec.vol_percentile <= VOL_REGIME_LOW_THRESH
                    wins_low_vol += 1
                // Phase 4: Profit factor tracking (1R per win since TP was hit)
                total_r_won += 1.0
                // Phase 4: Streak tracking (newest to oldest, freeze after break)
                if not streak_frozen
                    if streak_state == 0
                        streak_state := 1  // Start win streak
                        consecutive_wins := 1
                    else if streak_state == 1
                        consecutive_wins += 1  // Continue win streak
                    else
                        // Was in loss streak, this win breaks it
                        streak_frozen := true
            else if f_hasFlag(rec.state_mask, FLAG_SL_HIT)
                losses += 1
                // Phase 2: Track losing trade MAE
                losing_mae_total += rec.max_adverse
                losing_count += 1
                // Phase 2: RSI divergence stratification
                if f_hasFlag(rec.state_mask, FLAG_HAD_RSI_DIV)
                    losses_with_div += 1
                else
                    losses_without_div += 1
                // Phase 2: Direction stratification
                if f_hasFlag(rec.state_mask, FLAG_IS_LONG)
                    losses_long += 1
                else
                    losses_short += 1
                // Phase 4: Volatility regime stratification
                if rec.vol_percentile >= VOL_REGIME_HIGH_THRESH
                    losses_high_vol += 1
                else if rec.vol_percentile <= VOL_REGIME_LOW_THRESH
                    losses_low_vol += 1
                // Phase 4: Profit factor tracking (1R per loss since SL was hit)
                total_r_lost += 1.0
                // Phase 4: Streak tracking (newest to oldest, freeze after break)
                if not streak_frozen
                    if streak_state == 0
                        streak_state := -1  // Start loss streak
                        consecutive_losses := 1
                    else if streak_state == -1
                        consecutive_losses += 1  // Continue loss streak
                    else
                        // Was in win streak, this loss breaks it
                        streak_frozen := true
            
            // Phase 3: TP mode comparison (track both modes regardless of which was used)
            // Only count if SL wasn't hit first
            if not f_hasFlag(rec.state_mask, FLAG_SL_HIT)
                cons_tp_total += 1
                aggr_tp_total += 1
                if f_hasFlag(rec.state_mask, FLAG_CONS_TP_HIT)
                    cons_tp_wins += 1
                if f_hasFlag(rec.state_mask, FLAG_AGGR_TP_HIT)
                    aggr_tp_wins += 1
        
        int total_outcomes = wins + losses
        if total_outcomes >= LEARN_MIN_SAMPLES_WR and total_outcomes > 0
            p_empirical := float(wins) / float(total_outcomes)
            // Clamp win rate to prevent Kelly from returning wild values during streaks
            GLOBAL_learnedWinRate := math.max(0.30, math.min(0.70, p_empirical))
        
        // Extended learning: compute averages from winning trades
        if outcome_count >= LEARN_MIN_SAMPLES_MAE
            GLOBAL_learnedAvgMae := total_mae / float(outcome_count)
            GLOBAL_learnedAvgMfe := total_mfe / float(outcome_count)
            GLOBAL_learnedAvgBars := int(float(total_bars) / float(outcome_count))
            // Optimal SL = average MAE of winners + SL_BUFFER_ATR ATR buffer
            // This allows for typical drawdowns while avoiding premature stopouts
            GLOBAL_learnedSlMult := math.max(1.0, GLOBAL_learnedAvgMae + SL_BUFFER_ATR)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 2: Advanced Learning Analytics
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // RSI Divergence Effectiveness: Compare win rates with/without divergence
        int total_with_div = wins_with_div + losses_with_div
        int total_without_div = wins_without_div + losses_without_div
        if total_with_div >= LEARN_MIN_SAMPLES_DIV
            GLOBAL_learnedWrWithDiv := float(wins_with_div) / float(total_with_div)
        if total_without_div >= LEARN_MIN_SAMPLES_DIV
            GLOBAL_learnedWrWithoutDiv := float(wins_without_div) / float(total_without_div)
        // Edge from divergence = difference in win rates
        if total_with_div >= LEARN_MIN_SAMPLES_DIV and total_without_div >= LEARN_MIN_SAMPLES_DIV
            GLOBAL_learnedDivEdge := GLOBAL_learnedWrWithDiv - GLOBAL_learnedWrWithoutDiv
        
        // Direction-Specific Win Rates
        int total_long = wins_long + losses_long
        int total_short = wins_short + losses_short
        if total_long >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learnedWrLong := float(wins_long) / float(total_long)
        if total_short >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learnedWrShort := float(wins_short) / float(total_short)
        
        // Losing Trade MAE Analysis: Where should SL have been?
        if losing_count >= LEARN_MIN_SAMPLES_LOSING
            GLOBAL_learnedLosingMae := losing_mae_total / float(losing_count)
        
        // Optimal Holding Period: Use average bars to outcome
        if outcome_count >= LEARN_MIN_SAMPLES_MAE
            GLOBAL_learnedOptimalHold := GLOBAL_learnedAvgBars
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 3: Advanced Learning - TP Mode, Decay Rate, RSI Weight
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // TP Mode Comparison: Which mode has better expected value?
        if cons_tp_total >= LEARN_MIN_SAMPLES_TP_COMP and aggr_tp_total >= LEARN_MIN_SAMPLES_TP_COMP
            GLOBAL_learnedConsWr := float(cons_tp_wins) / float(cons_tp_total)
            GLOBAL_learnedAggrWr := float(aggr_tp_wins) / float(aggr_tp_total)
            // Calculate R:R for each mode (approximate using zone mid as entry)
            float cons_reward = math.abs(tp_conservative - mid_entry)
            float aggr_reward = math.abs(tp_aggressive - mid_entry)
            float cons_rr = risk > 0 ? cons_reward / risk : 0
            float aggr_rr = risk > 0 ? aggr_reward / risk : 0
            // Expected Value = (WinRate * Reward) - ((1-WinRate) * Risk) per unit risk
            GLOBAL_learnedConsEv := GLOBAL_learnedConsWr * cons_rr - (1 - GLOBAL_learnedConsWr)
            GLOBAL_learnedAggrEv := GLOBAL_learnedAggrWr * aggr_rr - (1 - GLOBAL_learnedAggrWr)
            // Choose mode with higher EV
            GLOBAL_learnedTpAggressive := GLOBAL_learnedAggrEv > GLOBAL_learnedConsEv
        
        // Time Decay Rate Learning: Based on when wins happen
        // If most wins are early, accelerate decay. If wins persist late, slow decay.
        int total_timed_wins = early_wins + late_wins
        if total_timed_wins >= LEARN_MIN_SAMPLES_TIME
            float early_ratio = float(early_wins) / float(total_timed_wins)
            // early_ratio > 0.6 means most wins are early â†’ accelerate decay (lower rate)
            // early_ratio < 0.4 means wins persist late â†’ slow decay (higher rate)
            // Map: early_ratio 0.3-0.7 â†’ decay_rate DECAY_RATE_MAX-DECAY_RATE_MIN
            GLOBAL_learnedDecayRate := DEFAULT_DECAY_RATE + (0.5 - early_ratio) * DECAY_RATE_ADJUST
            // Clamp to reasonable range [DECAY_RATE_MIN, DECAY_RATE_MAX]
            GLOBAL_learnedDecayRate := math.max(DECAY_RATE_MIN, math.min(DECAY_RATE_MAX, GLOBAL_learnedDecayRate))
        
        // RSI Weight Learning: How much edge does divergence provide?
        // Weight = normalized edge (0 if no edge, 1 if huge edge)
        if total_with_div >= LEARN_MIN_SAMPLES_DIV and total_without_div >= LEARN_MIN_SAMPLES_DIV
            // GLOBAL_learnedDivEdge is already computed above
            // Convert edge to weight: +20% edge â†’ weight 1.0, 0% edge â†’ weight 0.0
            GLOBAL_learnedRsiWeight := math.max(0, math.min(1.0, GLOBAL_learnedDivEdge * 5))
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 4: Confidence Scoring & Regime-Aware Analytics
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // 4.1 Volatility Regime Win Rates
        int total_high_vol = wins_high_vol + losses_high_vol
        int total_low_vol = wins_low_vol + losses_low_vol
        if total_high_vol >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learnedWrHighVol := float(wins_high_vol) / float(total_high_vol)
        if total_low_vol >= LEARN_MIN_SAMPLES_DIR
            GLOBAL_learnedWrLowVol := float(wins_low_vol) / float(total_low_vol)
        
        // 4.2 Profit Factor: Total R won / Total R lost (>1 = profitable)
        if total_r_lost > 0
            GLOBAL_learnedProfitFactor := total_r_won / total_r_lost
        else if total_r_won > 0
            GLOBAL_learnedProfitFactor := 10.0  // Cap at 10 if no losses
        
        // 4.3 Expectancy: (WR Ã— avg win) - ((1-WR) Ã— avg loss) per trade
        if total_outcomes >= LEARN_MIN_SAMPLES_WR
            float avg_win_r = wins > 0 ? total_r_won / float(wins) : 0
            float avg_loss_r = losses > 0 ? total_r_lost / float(losses) : 0
            GLOBAL_learnedExpectancy := (p_empirical * avg_win_r) - ((1 - p_empirical) * avg_loss_r)
        
        // 4.4 Streak Recording (consecutive from most recent + max historical)
        max_win_streak := math.max(max_win_streak, consecutive_wins)
        max_loss_streak := math.max(max_loss_streak, consecutive_losses)
        GLOBAL_learnedWinStreak := consecutive_wins    // Current streak from most recent
        GLOBAL_learnedLossStreak := consecutive_losses // Current streak from most recent
        
        // 4.5 Learning Health Check: Is system still performing?
        // Staleness: Flag if no outcomes for HEALTH_STALE_BARS+ bars
        int bars_since_outcome = bar_index - GLOBAL_learnedLastOutcomeBar
        bool is_stale = bars_since_outcome > HEALTH_STALE_BARS and GLOBAL_learnedLastOutcomeBar > 0
        // Sanity check: WR should be HEALTH_WR_MIN-HEALTH_WR_MAX, profit factor > HEALTH_PF_MIN
        bool sane_wr = GLOBAL_learnedWinRate >= HEALTH_WR_MIN and GLOBAL_learnedWinRate <= HEALTH_WR_MAX
        bool sane_pf = GLOBAL_learnedProfitFactor >= HEALTH_PF_MIN or GLOBAL_learnedProfitFactor == 0.0
        GLOBAL_learnedIsHealthy := not is_stale and sane_wr and sane_pf
        
        // 4.6 Unified Confidence Score (0-100) - Computed at analysis time
        // NOTE: Direction alignment and time decay will be recalculated in display section
        //       using current bar context. Here we compute the "base" confidence from learning data.
        // Components: WR (35%), RSI Edge (20%), Profit Factor (15%), Streak Status (15%), Health (15%)
        float conf_base = 0.0
        // WR Component: CONF_WR_WEIGHT% weight - map CONF_WR_MIN_MAP-CONF_WR_MAX_MAP â†’ 0-35
        conf_base += math.max(0, math.min(CONF_WR_WEIGHT, (GLOBAL_learnedWinRate - CONF_WR_MIN_MAP) * 70))
        // RSI Edge: CONF_RSI_WEIGHT% weight - map 0-0.2 edge â†’ 0-20
        conf_base += math.max(0, math.min(CONF_RSI_WEIGHT, GLOBAL_learnedDivEdge * 100))
        // Profit Factor: CONF_PF_WEIGHT% weight - map CONF_PF_MIN_MAP-CONF_PF_MAX_MAP â†’ 0-15
        float pf_norm = math.max(0, math.min(CONF_PF_WEIGHT, (GLOBAL_learnedProfitFactor - CONF_PF_MIN_MAP) * 10))
        conf_base += pf_norm
        // Streak Penalty: -15% if on losing streak of STREAK_LOSS_PENALTY_THRESH+, bonus for win streak
        float streak_adj = 0.0
        if consecutive_losses >= STREAK_LOSS_PENALTY_THRESH
            streak_adj := -math.min(STREAK_PENALTY_MAX, (consecutive_losses - STREAK_LOSS_PENALTY_BASE) * STREAK_PENALTY_RATE)
        else if consecutive_wins >= STREAK_WIN_BONUS_THRESH
            streak_adj := math.min(STREAK_BONUS_MAX, (consecutive_wins - STREAK_WIN_BONUS_BASE) * STREAK_BONUS_RATE)  // Smaller bonus than penalty
        conf_base += streak_adj
        // Health Component: CONF_HEALTH_WEIGHT% - full points if healthy, 0 if not
        bool is_healthy = not is_stale and sane_wr and sane_pf
        conf_base += is_healthy ? CONF_HEALTH_WEIGHT : 0
        // Final base confidence clamped to 0-100 (direction/decay adjustments done per-bar)
        GLOBAL_learnedConfidence := math.max(0, math.min(100, conf_base))
    
    // Use empirical win rate if learning enabled and sufficient data, otherwise use input
    // Phase 2: Use direction-specific win rate for more accurate Kelly sizing
    // NOTE: GLOBAL_learnedWinRate is already clamped to 0.30-0.70 above
    float p_effective = p_base
    if INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= LEARN_MIN_SAMPLES_SL
        // Use direction-specific win rate if we have enough samples per direction
        // Also clamp direction-specific rates to prevent wild Kelly values
        bool has_dir_data = (is_long_setup and GLOBAL_learnedWrLong != DEFAULT_WIN_RATE) or (not is_long_setup and GLOBAL_learnedWrShort != DEFAULT_WIN_RATE)
        if has_dir_data
            float raw_dir_wr = is_long_setup ? GLOBAL_learnedWrLong : GLOBAL_learnedWrShort
            p_effective := math.max(0.30, math.min(0.70, raw_dir_wr))
        else
            // Use clamped GLOBAL_learnedWinRate (already clamped during calculation)
            p_effective := na(GLOBAL_learnedWinRate) ? p_base : GLOBAL_learnedWinRate
    
    // Phase 4: Apply regime-specific win rate adjustment based on current volatility
    // If we have enough regime-specific data, blend towards the regime WR
    float p_regime_adjusted = p_effective
    float current_regime_percentile = GLOBAL_atrPercentile  // Use global pre-computed value (Pine v6)
    bool is_high_vol_regime = current_regime_percentile >= VOL_REGIME_HIGH_THRESH
    bool is_low_vol_regime = current_regime_percentile <= VOL_REGIME_LOW_THRESH
    bool has_regime_data = INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_regime_data
        if is_high_vol_regime and GLOBAL_learnedWrHighVol != DEFAULT_WIN_RATE
            // Blend: 70% direction WR + 30% regime WR for stability
            p_regime_adjusted := p_effective * 0.7 + GLOBAL_learnedWrHighVol * 0.3
        else if is_low_vol_regime and GLOBAL_learnedWrLowVol != DEFAULT_WIN_RATE
            p_regime_adjusted := p_effective * 0.7 + GLOBAL_learnedWrLowVol * 0.3
    
    // Phase 3: Apply learned RSI weight to boost probability when divergence is present
    // This adjusts the effective win rate based on the edge RSI divergence provides
    float p_rsi_adjusted = p_regime_adjusted
    bool has_learned_rsi_weight = INPUT_LEARN_RSI_WEIGHT and INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_learned_rsi_weight and rsi_confirm and GLOBAL_learnedRsiWeight > 0
        // Boost win rate by learned edge: p + (edge * weight * (1-p)) to stay bounded
        float boost = GLOBAL_learnedDivEdge * GLOBAL_learnedRsiWeight * (1 - p_regime_adjusted)
        p_rsi_adjusted := math.min(0.95, p_regime_adjusted + boost)  // Cap at 95%
    
    float p = p_rsi_adjusted * time_decay  // Time-decayed win probability
    float q = 1 - p
    float b = rr_ratio
    float kelly_full = b > 0 ? (p * b - q) / b : 0  // Full Kelly fraction
    
    // Phase 4: Apply confidence-based Kelly scaling
    // High confidence (>70) = full fraction, low confidence (<40) = reduced fraction
    float conf_scale = 1.0
    bool has_conf_data = INPUT_LEARNING_ENABLED and GLOBAL_setupHistory.size() >= INPUT_LEARN_MIN_SAMPLES
    if has_conf_data
        // Map confidence 30-80 â†’ scale 0.5-1.0
        conf_scale := math.max(0.5, math.min(1.0, (GLOBAL_learnedConfidence - 30) / 50))
    
    float kelly_adj = math.max(0, kelly_full) * INPUT_POS_KELLY_FRAC * conf_scale  // Apply fractional Kelly + confidence
    float kelly_pct = math.min(kelly_adj * 100, 25)  // Cap at 25% max risk per trade
    
    // Expected Value (EV) Calculation
    // EV = (P_win Ã— Reward) - (P_loss Ã— Risk) per unit risked
    float ev_absolute = (p * reward) - (q * risk)  // Absolute EV in price units (time-decay adjusted)
    float ev_per_risk = risk > 0 ? ev_absolute / risk : 0  // EV per unit of risk (normalized)
    float ev_percent = ev_per_risk * 100  // As percentage
    
    // Confidence interval using standard error approximation
    // Standard deviation of Bernoulli outcome scaled by payoff
    float variance = p * math.pow(reward, 2) + q * math.pow(risk, 2) - math.pow(ev_absolute, 2)
    float std_dev = math.sqrt(math.max(0, variance))
    // 95% confidence interval (1.96 standard errors) assuming ~20 trade sample
    float margin_of_error = 1.96 * std_dev / math.sqrt(20)
    float ev_lower_95 = ev_absolute - margin_of_error
    bool ev_significant = ev_lower_95 > 0  // True if 95% confident EV is positive
    
    // EV quality indicator
    string ev_grade = ev_percent <= 0 ? "âˆ’EV" : ev_percent < 10 ? "marginal" : ev_percent < 25 ? "decent" : ev_percent < 50 ? "strong" : "exceptional"
    string ev_conf = ev_significant ? "âœ“" : "?"
    
    // Kelly edge quality indicator
    string kelly_grade = kelly_pct <= 0 ? "NO EDGE" : kelly_pct < 5 ? "weak" : kelly_pct < 10 ? "decent" : kelly_pct < 15 ? "strong" : "excellent"
    
    // Confluence indicators for display
    string div_icon = rsi_confirm ? " âœ“DIV" : ""
    string vol_icon = vol_confirm ? " âœ“VOL" : ""
    
    // Status text (include time decay status)
    string invalid_reason = sl_breached ? TEXT_SL_HIT : (zone_expired ? TEXT_EXPIRED : "")
    string status = is_invalid ? invalid_reason : (in_zone ? TEXT_ACTIVE + div_icon + vol_icon + time_status : time_status)
    string kelly_text = kelly_pct > 0 ? "\nKelly: " + str.tostring(kelly_pct, "#.#") + "% (" + kelly_grade + ")" : "\nKelly: " + kelly_grade
    string ev_text = "\nEV: " + str.tostring(ev_percent, "#.#") + "% " + ev_conf + " (" + ev_grade + ")"
    
    // Learning stats for display
    string learn_text = ""
    if INPUT_LEARNING_ENABLED
        int sample_count = GLOBAL_setupHistory.size()
        if sample_count >= 10
            learn_text := "\nğŸ“Š " + str.tostring(sample_count) + " samples"
            if GLOBAL_learnedZoneBuffer > 0
                learn_text += " | Buf:+" + str.tostring(GLOBAL_learnedZoneBuffer, "#.##") + "%"
            if sample_count >= 20
                learn_text += " | WR:" + str.tostring(GLOBAL_learnedWinRate * 100, "#.#") + "%"
                // Extended metrics display (Phase 1)
                if GLOBAL_learnedAvgMae > 0
                    learn_text += "\n   MAE:" + str.tostring(GLOBAL_learnedAvgMae, "#.#") + "R"
                    learn_text += " MFE:" + str.tostring(GLOBAL_learnedAvgMfe, "#.#") + "R"
                    learn_text += " SL*:" + str.tostring(GLOBAL_learnedSlMult, "#.#") + "x"
                if GLOBAL_learnedAvgBars > 0
                    learn_text += " Ï„:" + str.tostring(GLOBAL_learnedAvgBars) + "bars"
                // Phase 2: Advanced analytics display
                // RSI Divergence Edge
                if GLOBAL_learnedDivEdge != 0
                    string div_sign = GLOBAL_learnedDivEdge > 0 ? "+" : ""
                    learn_text += "\n   DIV:" + div_sign + str.tostring(GLOBAL_learnedDivEdge * 100, "#.#") + "% edge"
                // Direction-specific win rates (show if significant difference)
                float dir_diff = math.abs(GLOBAL_learnedWrLong - GLOBAL_learnedWrShort)
                if dir_diff > 0.05  // >5% difference
                    learn_text += "\n   L:" + str.tostring(GLOBAL_learnedWrLong * 100, "#") + "% S:" + str.tostring(GLOBAL_learnedWrShort * 100, "#") + "%"
                // Losing MAE (informative: where trades went wrong)
                if GLOBAL_learnedLosingMae > 0
                    learn_text += " âœ—MAE:" + str.tostring(GLOBAL_learnedLosingMae, "#.#") + "R"
                // Phase 3: Show learned parameters
                if sample_count >= INPUT_LEARN_MIN_SAMPLES
                    string p3_text = ""
                    // Show learned TP mode recommendation
                    if INPUT_LEARN_TP and (GLOBAL_learnedConsEv != 0 or GLOBAL_learnedAggrEv != 0)
                        string tp_rec = GLOBAL_learnedTpAggressive ? "Aggr" : "Cons"
                        p3_text += "\n   ğŸ§  TP:" + tp_rec + "âœ“"
                    // Show learned decay rate if different from default
                    if INPUT_LEARN_DECAY and math.abs(GLOBAL_learnedDecayRate - DEFAULT_DECAY_RATE) > 0.02
                        p3_text += " Decay:" + str.tostring(GLOBAL_learnedDecayRate, "#.##")
                    // Show learned RSI weight if significant
                    if INPUT_LEARN_RSI_WEIGHT and GLOBAL_learnedRsiWeight > 0.1
                        p3_text += " RSIwt:" + str.tostring(GLOBAL_learnedRsiWeight, "#.#")
                    if str.length(p3_text) > 0
                        learn_text += p3_text
                    // Phase 4: Confidence scoring and regime analytics
                    string p4_text = ""
                    // Calculate per-bar adjusted confidence (add direction alignment + time decay + regime)
                    float adjusted_conf = GLOBAL_learnedConfidence
                    // Direction Alignment Adjustment: Â±10% based on current direction's relative WR
                    float dir_wr = is_long_setup ? GLOBAL_learnedWrLong : GLOBAL_learnedWrShort
                    float opp_wr = is_long_setup ? GLOBAL_learnedWrShort : GLOBAL_learnedWrLong
                    float dir_edge = dir_wr - opp_wr
                    adjusted_conf += dir_edge * 50  // Â±10% edge â†’ Â±5 points
                    // Time Decay Adjustment: Â±10% (fresh setup = +10, expired = -10)
                    adjusted_conf += (time_decay - 0.5) * 20  // 1.0â†’+10, 0.5â†’0, 0â†’-10
                    // Regime Adjustment: Â±5% based on current vol regime performance
                    float regime_wr = current_regime_percentile >= VOL_REGIME_HIGH_THRESH ? GLOBAL_learnedWrHighVol : 
                                      current_regime_percentile <= VOL_REGIME_LOW_THRESH ? GLOBAL_learnedWrLowVol : GLOBAL_learnedWinRate
                    if regime_wr != DEFAULT_WIN_RATE  // Only if we have regime data
                        float regime_edge = regime_wr - GLOBAL_learnedWinRate
                        adjusted_conf += regime_edge * 50  // Â±10% edge â†’ Â±5 points
                    adjusted_conf := math.max(0, math.min(100, adjusted_conf))
                    // Unified Confidence Score with grade
                    string conf_grade = adjusted_conf < CONF_GRADE_D_THRESH ? "D" : adjusted_conf < CONF_GRADE_C_THRESH ? "C" : adjusted_conf < CONF_GRADE_B_THRESH ? "B" : adjusted_conf < CONF_GRADE_A_THRESH ? "A" : "A+"
                    string health_icon = GLOBAL_learnedIsHealthy ? "âœ“" : "âš "
                    p4_text += "\n   ğŸ¯ Conf:" + str.tostring(adjusted_conf, "#") + "% " + conf_grade + " " + health_icon
                    // Profit Factor (only show if meaningful)
                    if GLOBAL_learnedProfitFactor > 0
                        string pf_rating = GLOBAL_learnedProfitFactor < 1.0 ? "âˆ’" : GLOBAL_learnedProfitFactor < 1.5 ? "â—‹" : GLOBAL_learnedProfitFactor < 2.0 ? "+" : "++"
                        p4_text += "\n   PF:" + str.tostring(GLOBAL_learnedProfitFactor, "#.##") + pf_rating
                    // Expectancy per trade
                    if GLOBAL_learnedExpectancy != 0
                        string exp_sign = GLOBAL_learnedExpectancy > 0 ? "+" : ""
                        p4_text += " Exp:" + exp_sign + str.tostring(GLOBAL_learnedExpectancy, "#.##") + "R"
                    // Regime indicator: Show if we're in favorable/unfavorable vol regime (use real-time percentile)
                    if current_regime_percentile >= VOL_REGIME_HIGH_THRESH and GLOBAL_learnedWrHighVol != DEFAULT_WIN_RATE
                        string vol_edge = GLOBAL_learnedWrHighVol > GLOBAL_learnedWinRate ? "â–²" : GLOBAL_learnedWrHighVol < GLOBAL_learnedWinRate ? "â–¼" : "="
                        p4_text += "\n   âš¡HighVol" + vol_edge + " " + str.tostring(GLOBAL_learnedWrHighVol * 100, "#") + "%"
                    else if current_regime_percentile <= VOL_REGIME_LOW_THRESH and GLOBAL_learnedWrLowVol != DEFAULT_WIN_RATE
                        string vol_edge = GLOBAL_learnedWrLowVol > GLOBAL_learnedWinRate ? "â–²" : GLOBAL_learnedWrLowVol < GLOBAL_learnedWinRate ? "â–¼" : "="
                        p4_text += "\n   ğŸŒŠ LowVol" + vol_edge + " " + str.tostring(GLOBAL_learnedWrLowVol * 100, "#") + "%"
                    // Streak warning (show win streak as positive indicator too)
                    if GLOBAL_learnedLossStreak >= STREAK_LOSS_PENALTY_THRESH
                        p4_text += "\n   âš  " + str.tostring(GLOBAL_learnedLossStreak) + "L streak"
                    else if GLOBAL_learnedWinStreak >= STREAK_WIN_BONUS_THRESH
                        p4_text += "\n   ğŸ”¥ " + str.tostring(GLOBAL_learnedWinStreak) + "W streak"
                    if str.length(p4_text) > 0
                        learn_text += p4_text
        else
            learn_text := "\nğŸ“Š Learning... (" + str.tostring(sample_count) + "/" + str.tostring(INPUT_LEARNING_SAMPLES) + ")"
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TASK 4: Status Label - Distinguish Confirmed vs Projected
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Use stored values when setup is active for display consistency with tracking
    // BUT show current calculated values (with learning) so user sees adjusted prices
    float display_tp_text = tp_price  // Always show current calculation with learning
    float display_sl_text = sl_price  // Always show current calculation with learning
    // Use current calculation for display (projection shows current direction)
    bool display_is_long = isProjection ? is_long_setup : (not na(GLOBAL_activeTrade.setup_bar) ? f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_IS_LONG) : is_long_setup)
    
    // Status prefix: clearly distinguish between Confirmed Active and Projected trades
    // âš¡PROJ = Projection (tentative, not recorded to learning)
    // âœ“ACTIVE = Confirmed Active (tracked, will be recorded)
    string trade_state_indicator = isProjection ? " âš¡PROJ" : (not na(GLOBAL_activeTrade.setup_bar) ? " âœ“ACTIVE" : "")
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BACKTEST STATS DISPLAY - Show optimization results on the dashboard
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    string backtest_text = ""
    if bt_stats_ready and bt_total_trades > 0
        // Low confidence warning
        string conf_warning = bt_low_confidence ? " âš ï¸LOW" : ""
        backtest_text := "\nğŸ“ˆ Backtested " + str.tostring(bt_total_trades) + " Trades: " + str.tostring(math.round(bt_win_rate * 100)) + "% WR" + conf_warning
        // Show Smart SL if available
        if bt_smart_sl_offset > 0
            float smart_sl_price = display_is_long ? mid_entry - bt_smart_sl_offset : mid_entry + bt_smart_sl_offset
            backtest_text += "\n   ğŸ¯ Smart SL: " + str.tostring(smart_sl_price, format.mintick)
    else if bt_total_trades == 0
        backtest_text := "\nğŸ“ˆ Backtesting... (0 trades)"
    
    string pos_text = (display_is_long ? TEXT_LONG : TEXT_SHORT) + TEXT_SETUP + trade_state_indicator + status + "\nğŸ¯ TP: " + str.tostring(display_tp_text, format.mintick) + "\nğŸ›‘ SL: " + str.tostring(display_sl_text, format.mintick) + "\nâš–ï¸ R:R " + str.tostring(rr_ratio, "#.##") + ev_text + kelly_text + learn_text + backtest_text
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LEARNING ENGINE: Record CONFIRMED setup outcome on pivot change (NEVER projections)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Record previous CONFIRMED setup BEFORE resetting state (order matters!)
    // CRITICAL: Only record from GLOBAL_activeTrade - NEVER from projection data
    bool should_record = INPUT_LEARNING_ENABLED and pivotChanged and not na(GLOBAL_activeTrade.setup_bar)
    if should_record
        // Calculate bars to outcome (0 if neither SL nor TP hit)
        int bars_to_out = f_hasAny(GLOBAL_activeTrade.state_mask, MASK_OUTCOME) and not na(GLOBAL_activeTrade.entry_bar) ? 
                          (bar_index - GLOBAL_activeTrade.entry_bar) : 0
        
        // Record the previous CONFIRMED setup's outcome before it changes
        // Copy state_mask directly from GLOBAL_activeTrade (contains is_long, zone_touched, sl_hit, tp_hit, had_rsi_div, etc.)
        SetupRecord completed_setup = SetupRecord.new(
            GLOBAL_activeTrade.setup_bar,           // setup_bar
            GLOBAL_activeTrade.state_mask,          // state_mask (copy all flags directly)
            GLOBAL_activeTrade.zone_top,            // zone_top
            GLOBAL_activeTrade.zone_bottom,         // zone_bottom
            GLOBAL_activeTrade.sl_price,            // sl_level
            GLOBAL_activeTrade.tp_price,            // tp_level
            GLOBAL_activeTrade.min_distance,        // closest_approach
            bars_to_out,                        // bars_to_outcome
            GLOBAL_activeTrade.max_adverse,         // max_adverse (ATR units)
            GLOBAL_activeTrade.max_favorable,       // max_favorable (ATR units)
            nz(GLOBAL_activeTrade.entry_price, (GLOBAL_activeTrade.zone_top + GLOBAL_activeTrade.zone_bottom) / 2),  // entry_price
            nz(GLOBAL_activeTrade.atr_at_setup, 1.0),        // atr_at_setup
            nz(GLOBAL_activeTrade.rsi_at_entry, 50.0),       // rsi_at_entry
            GLOBAL_activeTrade.tp_cons,             // tp_conservative
            GLOBAL_activeTrade.tp_aggr,             // tp_aggressive
            GLOBAL_activeTrade.vol_percentile       // vol_percentile
        )
        
        // Phase 4: Record last outcome bar for staleness detection
        GLOBAL_learnedLastOutcomeBar := bar_index
        
        // Add to circular buffer (O(1) operation, auto-overwrites oldest when full)
        GLOBAL_setupHistory.push(completed_setup)
        
        // OPTIMIZATION: Set flag to trigger learning recalculation (only on new trade)
        GLOBAL_learningNeedsRecalc := true
        
        // DEBUG: Log when setup is recorded (using state_mask flags)
        log.info("RECORDED: bar={0}, mask={1}, samples={2}, long={3}, touched={4}, sl={5}, tp={6}, won={7}", 
                 GLOBAL_activeTrade.setup_bar, GLOBAL_activeTrade.state_mask, GLOBAL_setupHistory.size(),
                 f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_IS_LONG),
                 f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_ZONE_TOUCHED),
                 f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_SL_HIT),
                 f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_TP_HIT),
                 f_hasFlag(GLOBAL_activeTrade.state_mask, FLAG_WON))
    
    // Initialize CONFIRMED trade tracking - ONLY reset on pivotChanged (never for projections)
    // This ensures Learning Engine data is ONLY from confirmed ZigZag pivots
    if pivotChanged
        // Use CONFIRMED pivot (cachedIMidPivot), NOT effective pivot (which includes projections)
        GLOBAL_activeTrade.setup_bar := cachedIMidPivot
        // TASK 3 FIX: Store creation_bar = current bar_index for proper time decay
        // Confirmed pivots are detected pivotLength bars AFTER they occur
        // So cachedIMidPivot is typically bar_index - pivotLength
        // creation_bar tracks when WE created the setup, not when the pivot occurred
        GLOBAL_activeTrade.creation_bar := bar_index
        // Build initial state_mask: direction + TP mode (all event flags start cleared)
        int new_state = is_long_setup ? FLAG_IS_LONG : 0
        new_state := use_aggressive_tp ? f_setFlag(new_state, FLAG_TP_AGGRESSIVE) : new_state
        GLOBAL_activeTrade.state_mask := new_state
        GLOBAL_activeTrade.zone_top := adjusted_box_top
        GLOBAL_activeTrade.zone_bottom := adjusted_box_bottom
        GLOBAL_activeTrade.sl_price := sl_price
        GLOBAL_activeTrade.tp_price := tp_price
        GLOBAL_activeTrade.tp_cons := tp_conservative
        GLOBAL_activeTrade.tp_aggr := tp_aggressive
        GLOBAL_activeTrade.min_distance := DEFAULT_MIN_DISTANCE
        // Extended tracking reset (Phase 1)
        GLOBAL_activeTrade.entry_bar := na
        GLOBAL_activeTrade.entry_price := na
        GLOBAL_activeTrade.max_adverse := 0.0
        GLOBAL_activeTrade.max_favorable := 0.0
        GLOBAL_activeTrade.atr_at_setup := nz(GLOBAL_rawAtr, 1.0)  // Use global pre-computed ATR (Pine v6)
        GLOBAL_activeTrade.rsi_at_entry := na
        // Phase 4: Regime tracking reset
        GLOBAL_activeTrade.vol_percentile := atr_percentile  // Capture current volatility regime

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TASK 4: Visual Styling - Confirmed vs Projection
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIRMED (GLOBAL_activeTrade valid): Solid/dotted lines with full opacity
    // PROJECTION (tentative preview):    Dashed lines with higher transparency
    // This provides clear visual distinction between actionable vs tentative setups
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Determine which state we're displaying
    bool hasConfirmedTrade = not na(GLOBAL_activeTrade.setup_bar)
    bool showingProjection = isProjection
    
    // Visual style settings based on state
    // Confirmed: dotted (standard), Projection: dashed (tentative)
    var string box_style = line.style_dotted
    box_style := showingProjection ? line.style_dotted : line.style_solid
    
    // Transparency: Scale by INPUT_PROJ_SENSITIVITY for projections
    // Lower sensitivity (more stable) = more opaque. Higher sensitivity (more volatile) = more transparent.
    // Formula: 80 - (sensitivity * 40) â†’ at 0.5 sens = 60 trans, at 1.0 sens = 40 trans, at 0.1 sens = 76 trans
    int sl_tp_transparency = showingProjection ? int(80 - INPUT_PROJ_SENSITIVITY * 40) : 5
    color sl_line_col = is_invalid ? color.new(COLOR_GRAY, 60) : color.new(COLOR_RED, sl_tp_transparency)
    color tp_line_col = is_invalid ? color.new(COLOR_GRAY, 60) : color.new(COLOR_GREEN, sl_tp_transparency)
    
    // Display current calculated values (with learning) for SL/TP lines
    // Zone boundaries: for projection mode, use current calculated; otherwise use confirmed trade values
    float display_sl = sl_price  // Show learning-adjusted SL
    float display_tp = tp_price  // Show learning-adjusted TP
    float display_zone_top = isProjection ? adjusted_box_top : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.zone_top : adjusted_box_top)
    float display_zone_bottom = isProjection ? adjusted_box_bottom : (not na(GLOBAL_activeTrade.setup_bar) ? GLOBAL_activeTrade.zone_bottom : adjusted_box_bottom)
    
    // Calculate Smart SL price based on backtest optimization
    float smart_sl_price = na
    bool show_smart_sl = bt_stats_ready and bt_smart_sl_offset > 0
    if show_smart_sl
        smart_sl_price := is_long_setup ? mid_entry - bt_smart_sl_offset : mid_entry + bt_smart_sl_offset
    color smart_sl_col = color.new(color.orange, 20)  // Orange for Smart SL (distinct from red structural SL)
    
    // Track projection state changes for object recreation
    var bool wasProjection = false
    bool projectionStateChanged = isProjection != wasProjection
    wasProjection := isProjection
    
    // On pivot change OR projection state change, delete old objects and create fresh ones
    bool needsRecreate = pivotChanged or projectionStateChanged or (isProjection and (proj_tentative_high or proj_tentative_low))
    if needsRecreate
        if not na(box_entry)
            box.delete(box_entry)
        if not na(line_sl)
            line.delete(line_sl)
        if not na(line_smart_sl)
            line.delete(line_smart_sl)
        if not na(line_tp)
            line.delete(line_tp)
        if not na(lbl_risk)
            label.delete(lbl_risk)
        box_entry := box.new(bar_index, display_zone_top, bar_index + 5, display_zone_bottom, bgcolor=bg_col, border_color=border_col, border_style=box_style)
        line_sl := line.new(bar_index, display_sl, bar_index + 5, display_sl, color=sl_line_col, style=box_style, width=2)
        // Smart SL line (only if backtest data available)
        if show_smart_sl
            line_smart_sl := line.new(bar_index, smart_sl_price, bar_index + 5, smart_sl_price, color=smart_sl_col, style=line.style_dotted, width=3)
        line_tp := line.new(bar_index, display_tp, bar_index + 5, display_tp, color=tp_line_col, style=box_style, width=3)
        lbl_risk := label.new(bar_index + 5, mid_entry, pos_text, xloc.bar_index, yloc.price, color.new(COLOR_FG_MAIN, 100), label.style_label_left, color.new(COLOR_FG_MAIN, 0), size.small, text.align_left)
    else if na(box_entry)
        // First time creation (no pivot change yet)
        box_entry := box.new(bar_index, display_zone_top, bar_index + 5, display_zone_bottom, bgcolor=bg_col, border_color=border_col, border_style=line.style_dotted)
        line_sl := line.new(bar_index, display_sl, bar_index + 5, display_sl, color=sl_line_col, style=line.style_dotted, width=3)
        if show_smart_sl
            line_smart_sl := line.new(bar_index, smart_sl_price, bar_index + 5, smart_sl_price, color=smart_sl_col, style=line.style_dotted, width=3)
        line_tp := line.new(bar_index, display_tp, bar_index + 5, display_tp, color=tp_line_col, style=line.style_dotted, width=3)
        lbl_risk := label.new(bar_index + 5, mid_entry, pos_text, xloc.bar_index, yloc.price, color.new(COLOR_FG_MAIN, 100), label.style_label_left, color.new(COLOR_FG_MAIN, 0), size.small, text.align_left)
    else
        // Update existing objects with current values (dynamic learning adjustments)
        box.set_top(box_entry, display_zone_top)
        box.set_bottom(box_entry, display_zone_bottom)
        box.set_right(box_entry, bar_index + 5)
        box.set_bgcolor(box_entry, bg_col)
        box.set_border_color(box_entry, border_col)
        
        // Update SL line - price and color (dynamic learning adjustments)
        line.set_x2(line_sl, bar_index + 5)
        line.set_y1(line_sl, display_sl)
        line.set_y2(line_sl, display_sl)
        line.set_color(line_sl, sl_line_col)
        
        // Update Smart SL line (if available)
        if show_smart_sl and not na(line_smart_sl)
            line.set_x2(line_smart_sl, bar_index + 5)
            line.set_y1(line_smart_sl, smart_sl_price)
            line.set_y2(line_smart_sl, smart_sl_price)
        else if show_smart_sl and na(line_smart_sl)
            line_smart_sl := line.new(bar_index, smart_sl_price, bar_index + 5, smart_sl_price, color=smart_sl_col, style=line.style_dotted, width=2)
        
        // Update TP line - price and color (dynamic learning adjustments)
        line.set_x2(line_tp, bar_index + 5)
        line.set_y1(line_tp, display_tp)
        line.set_y2(line_tp, display_tp)
        line.set_color(line_tp, tp_line_col)
        
        // Update label
        label.set_x(lbl_risk, bar_index + 5)
        label.set_y(lbl_risk, mid_entry)
        label.set_text(lbl_risk, pos_text)
    
    // Alert on zone entry
    if zone_entry and INPUT_ALERT_ENABLED
        alert("Price entered Golden Pocket - " + (active_is_long ? TEXT_LONG : TEXT_SHORT) + " setup active", alert.freq_once_per_bar)

// AddOns
plotchar(INPUT_SHOW_VOL_SPIKE and nzVolume != 0 ? exhaustVol : false, 'Exhaustion Bar', 'ğŸš¦', location.abovebar, size=size.tiny, display = display.pane)
plotchar(INPUT_SHOW_HIGH_ATR ? highVolatility : false, 'High Volatile Bar', 'âš¡', location.belowbar, size=size.tiny, display = display.pane)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATUS LINE VALUES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

v_start = cachedPMidPivot
v_end   = cachedPEndBase
v_50    = f_get_level(0.5)
v_618   = f_get_level(FIB_GOLDEN_RATIO)

plot(v_start, "Pivot Start", color = color.new(color.gray, 0), display = display.data_window + display.status_line)
plot(v_end,   "Pivot End",   color = color.new(color.white, 0), display = display.data_window + display.status_line)
plot(v_50,    "Fib 0.50",    color = color.new(color.yellow, 0), display = display.data_window + display.status_line)
plot(v_618,   "Fib 0.618",   color = color.new(color.orange, 0), display = display.data_window + display.status_line)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if INPUT_ALERT_ENABLED and INPUT_ALERT_MODE == 'calculateAlertUpdates'
    if barstate.isconfirmed
        alert(f_getAlertMessage(ALERT_ID_UPDATE), alert.freq_once_per_bar) 
    
    if barstate.ishistory
        f_setLog(GLOBAL_pivotLevelsLogRetracements)
        f_setLog(GLOBAL_pivotLevelsLogCrossed)